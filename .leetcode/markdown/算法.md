# 动态规划

## [509. 斐波那契数列](https://leetcode.cn/problems/fibonacci-number/description/)

## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

### 描述解析

#### 1. 509 斐波那契数列

`dp[i] = dp[i - 1] + dp[i - 2];`

```
call fibonacci(n)
```

#### 2. 70 爬楼梯

##### 分析

每次只能爬1阶、2阶，比如4阶楼梯，只能由2阶或者3阶楼梯爬到，前面的爬楼梯的状态可以转移给后面使用，后面的状态依赖于前面的状态，按照列举数据是斐波那契数列

```
1 2 3 4 5 给出楼梯层数
1 2 3 5 8 可以使用多少种方法爬到层数
```

```
call fibonacci(n + 1)
```

##### `dp[i]`含义

`达到 i 阶 有 dp[i] 种方法`

### 解题方法

#### 1. 递归

```c++
class Solution {
    constexpr std::size_t fibonacci(std::size_t n) {
        if (n == 0)return 0;
        if (n == 1) return 1;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```



#### 2. 迭代

```c++
class Solution {
    constexpr std::size_t fibonacci(std::size_t n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        std::size_t a = 0, b = 1, c;
        for (int i = 2; i <= n; ++i) {
            c = a + b;
            a = b;
            b = c;
        }
        return b;
    }
}
```



#### 3. 矩阵快速幂

```C++
class Solution {
public:
    struct Matrix2D {
        std::array<std::array<std::size_t, 2>, 2> data;// will be plain array

        constexpr Matrix2D() : data{ {{1, 0}, {0, 1}} } {}

        constexpr Matrix2D(std::size_t a, std::size_t b,
            std::size_t c, std::size_t d)
            : data{ {{a, b}, {c, d}} } {
        }

        constexpr Matrix2D operator*(const Matrix2D& other) const {
            return Matrix2D(
                data[0][0] * other.data[0][0] + data[0][1] * other.data[1][0],
                data[0][0] * other.data[0][1] + data[0][1] * other.data[1][1],
                data[1][0] * other.data[0][0] + data[1][1] * other.data[1][0],
                data[1][0] * other.data[0][1] + data[1][1] * other.data[1][1]
            );
        }
    };

    constexpr Matrix2D matrixPower(const Matrix2D& base, std::size_t exponent) {
        Matrix2D result;
        Matrix2D temp = base;
        std::size_t n = exponent;

        while (n > 0) {
            if (n % 2 == 1) {
                result = result * temp;
            }
            temp = temp * temp;
            n >>= 1;
        }
        return result;
    }

    constexpr std::size_t fibonacci(std::size_t n) {
        if (n == 0) return 0;

        Matrix2D fibMatrix(1, 1, 1, 0);
        Matrix2D result = matrixPower(fibMatrix, n - 1);

        return result.data[0][0];
    }
};
```



#### 4. 动态规划（可以优化为迭代）

```
class Solution {
public:
	std::size_t fibonacci(std::size_t n) {
		std::vector<std::size_t> dp(n + 1, 0);
		dp[0] = 0, dp[1] = 1;
		for (int i = 2; i < dp.size(); ++i) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp.back();
	}
};
```

## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

### 描述解析

#### 分析

可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

意味着，初始状态站在 第一层、第二层楼梯不花费用，**只有往上跳的时候**，才花费费用，

我们需要取最小花费，**注意到达最后一层的时候，还需要再跳一次到达顶楼**

```
0层 不花费 跳 花费 cost[0]
1层 不花费 跳 花费 cost[1]
2层 由 cost[0] or cost[1] 最小花费决定 ，跳到3层 花费 cost[2]
3层 假设顶楼， 结束

即跳一层 花费 cost[i]
当前层 由前两层的 min(cost[i - 1], cost[i - 2]) 决定
```



#### `dp[i]` 含义

`到达 i 位置 花费为 dp[i]`

初始化大小为`cost.size() + 1`，为什么？试着思考如果只有一层楼梯，你还需要再跳一次到达顶楼，存储数据是第一层的0花费，以及跳之后的 0 + cost[0]的花费存到 size为2的 dp 中

### 解题方法

#### 常规DP

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        std::vector<int> dp(cost.size() + 1);
        dp[0] = 0, dp[1] = 0;
        for(int i = 2; i < dp.size(); ++i) {
            dp[i] = std::min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp.back();
    }
};
```

#### 状态压缩

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int prev2 = 0;  // dp[i-2]
        int prev1 = 0;  // dp[i-1]
        
        for (int i = 2; i <= cost.size(); ++i) {
            int current = min(prev1 + cost[i - 1], prev2 + cost[i - 2]);
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
};
```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/description/)





## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

### 描述解析

##### 分析

n等于3 时候的二叉搜索树

```
1 		1            2         3        3
 \       \          / \       /        /
  3        2       1   3     2        1
 /          \               /          \
2            3             1             2
头节点为1的二叉树 + 头节点为2的二叉树 + 头节点为3的二叉树
 
头节点为1的二叉树 = 左子树0节点树 * 右子树2节点数 （笛卡尔积）
头节点为2的二叉树 = 左子树1节点树 * 右子树1节点数
...

dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2][0]
```

n等于2 时候的二叉搜索树

```
  2       2   
 /         \ 
1           1 
```

n等于1 时候的二叉搜索树

```
1
```

**n等于0 时候二叉搜索树是1**

观察，**不考虑数字**，n为2可以由n为1的情况得到， n为 3可以由n为1、2的情况得到（它们的左右子树有关系）



##### `dp[i]`含义

`i种不同的二叉树 `

### 解题方法

#### 1. 动态规划

```C++
class Solution {
public:
    std::size_t numTrees(std::size_t n) {
        std::vector<std::size_t> dp(n + 1);
        dp[0] = 1;
        
        for (std::size_t i = 1; i <= n; ++i) {
            for (std::size_t j = 0; j < i; ++j) {
                dp[i] += dp[j] * dp[i - 1 - j];
            }
        }
        
        return dp.back();
    }
};
```

#### 2. 卡特兰数迭代（基于通项公式）

```C++
inline constexpr auto [[nodiscard]] catalan(std::size_t n) -> std::size_t {
    if (n == 0) return 1;

    std::size_t result = 1;
    // 使用迭代公式: C(n) = (2n)! / (n!(n+1)!)
    // 等价于: C(n) = ∏(i=1 to n) (4i-2)/(i+1)
    for (std::size_t i = 1; i <= n; ++i) {
    	result = result * (4 * i - 2) / (i + 1);
    }

    return result;
}
```

#### 3. 卡特兰数递归（动态规划空间优化）

```C++
inline constexpr auto [[nodiscard]] catalan(std::size_t n) -> std::size_t {
    if (n == 0) return 1;

    std::size_t result = 0;
    for (std::size_t i = 0; i < n; ++i) {
        result += catalan(i) * catalan(n - 1 - i);
    }
    return result;
}
```



# 背包DP

## [343. 整数拆分](https://leetcode.cn/problems/integer-break/description/)

### 描述解析

#### 分析

你需要不断拆分数字进行乘积

```C++
j * (i - j) 拆分两个数
/*
将i直接拆分为j和(i-j)两个数

不继续拆分剩余部分
*/
例如：i=6, j=3 → 3×3=9
    
拆分三个数
拆分四个数
...不断相乘

dp(n + 1) 大小

j * dp[i - j] 总结为 拆分 3个即以上的数字，为什么？ 请思考dp[i]的含义，我们顺序存储每个 i的最大乘积，/*一个数字大的数字都可以拆分为比他小的数字*/，那么/*意味着dp[i - j]已经包含了先前的被拆分的数字乘积结果*/了
/*
将i拆分为j和剩余部分(i-j)

对剩余部分(i-j)继续进行最优拆分

使用之前计算好的dp[i-j]值
*/
    
例如：i=6, j=2 → 2×dp[4]=2×4=8 // 复用我们之前已经拆分的结果
```



#### `dp[i]` 含义

`i 拆得的 最大乘积为 dp[i]`

### 解题方法

#### 1. 动态规划

##### 基础

```C++
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 4) return std::pow(2, n - 2);
        std::vector<int> dp(n + 1, 0);
        dp[0] = 0, dp[1] = 0, dp[2] = 1, dp[3] = 2, dp[4] = 4;

        for (int i = 5; i <= n; ++i) {
            /*
                对于每个数字i，尝试所有可能的拆分方式
                j代表第一个拆分数，i-j代表剩余部分
                j从1遍历到i-1，考虑所有可能的拆分组合
            */
            for(int j = 1; j < i ; ++j) {
                dp[i] = std::max({j * (i - j), j * dp[i - j], dp[i]});
            }
        }
        return dp.back();
    }
};
```

##### 优化

```
仅在内层for修改

for(int j = 1; j <= i / 2; ++j)
```

数学原理

- 对于任意拆分 `j` 和 `i-j`，当 `j > i/2` 时，实际上与 `i-j` 和 `j` 的情况是重复的
- 例如：i=8
  - j=3 和 j=5 实际上是相同的拆分（3×5 vs 5×3）
  - j=2 和 j=6 也是相同的（2×6 vs 6×2）

具体例子

以 **n=8** 为例：

**优化前** (j=1 to 7):

- j=1: 1×7, 1×dp[7]
- j=2: 2×6, 2×dp[6]
- j=3: 3×5, 3×dp[5]
- j=4: 4×4, 4×dp[4]
- j=5: 5×3, 5×dp[3] ← 与j=3重复
- j=6: 6×2, 6×dp[2] ← 与j=2重复
- j=7: 7×1, 7×dp[1] ← 与j=1重复

**优化后** (j=1 to 4):

- 只需要计算前一半，避免了重复计算

#### 2. 数学思想

拆得越多，越大，可以使用手机计算器运算就知道了，拆为3的时候乘积最大，注意考虑特殊情况即可，具体数学证明略。

```C++
class Solution {
public:
    int integerBreak(int n) {
        if (n <= 4) return std::pow(2, n - 2);
        std::div_t divResult = std::div(n, 3);
        return divResult.rem == 0 
            ? std::pow(3, divResult.quot)  
            : divResult.rem == 1 
                ? std::pow(3, divResult.quot - 1) * 4
                : std::pow(3, divResult.quot) * divResult.rem;
    }
};
```



## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)（0-1背包）

### 描述解析

#### 分析

分割为两个子集，这两个子集的和相等返回true，否则true；

那么 先计算总和，然后除以二 得到 **maxSubSum**，这个**就是我们背包的容量**

至于物品值以及重量，则是每一个num的值，值和重量相等



```
考虑特殊情况
如果总和为奇数，那么不可能有两个子集合的和相等
如果给定的nums集合种的最大元素num 比 总和一半（背包容量） 还要大，说明 两个子集的和不可能相等
示例 [2 4] 一半 3 ，最大元素值num是4，不可能分割为[2] == [4]
```



#### `dp[i]` 含义

`容量为 i 的最大价值 dp[i]`

### 解题方法

#### 1. 动态规划

##### 标准

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        std::size_t totalSum{ 0 };
        std::size_t maxNum{ 0 };
        #pragma GCC unroll 8
        for(int num : nums) {
            totalSum += num;
            if (num > maxNum) maxNum = num;
        }
        // 如果总和为奇数，无法分成两个相等的子集
        if (totalSum & 0x1ULL) return false;

        std::size_t maxSubSum{ totalSum >> 1 };
        // 如果nums集合最大元素比 一半和大 无法满足两个相等子集
        if (maxNum > maxSubSum) return false;
		
        // 0-1背包 一维数组优化，存储背包 j 中 的容纳的 最大价值
        // 初始化，0必然是0，其余非0下标，因为我们需要max比较，所以都填充为0
        std::vector<std::size_t> dp(maxSubSum + 1, 0);

        for(int num : nums) {
            #pragma GCC unroll 8
            for (int j = maxSubSum; j >= num; --j) {
                // dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
                if(int value = dp[j - num] + num; value > dp[j])
                    dp[i] = value;
            }
        }
        
        return dp[maxSubSum] == maxSubSum;
    }
};
```

##### 运算优化

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        std::size_t totalSum{ 0 };
        std::size_t maxNum{ 0 };
        #pragma GCC unroll 8
        for(int num : nums) {
            totalSum += num;
            if (num > maxNum) maxNum = num;
        }

        if (totalSum & 0x1ULL) return false;

        std::size_t maxSubSum{ totalSum >> 1 };

        if (maxNum > maxSubSum) return false;
		 // dp[i]表示是否可以选择一些数字使它们的和为i
        std::vector<uint8_t> dp(maxSubSum + 1, false);
        dp.front() = true; // 不选择任何数字，和为0是可能的

        std::size_t currBagCapacity{ 0 };
        for(int num : nums) {
            // 不选择任何数字，和为0是可能的
            currBagCapacity = std::min(currBagCapacity + num, maxSubSum);
            #pragma GCC unroll 8
            for (int i = currBagCapacity; i >= num; --i) {
                // 状态转移：如果dp[i-num]为true，则dp[i]也为true
                dp[i] |= dp[i - num];
            }
        }
        return dp.back();
    }
};
```

##### 进一步位运算优化

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        std::size_t totalSum{ 0 };
        std::size_t maxNum{ 0 };
        #pragma GCC unroll 8
        for(int num : nums) {
            totalSum += num;
            if (num > maxNum) maxNum = num;
        }

        if (totalSum & 0x1ULL) return false;

        std::size_t maxSubSum{ totalSum >> 1 };

        if (maxNum > maxSubSum) return false;
		// dp[i]表示是否可以选择一些数字使它们的和为i
        // 映射题目给出的数据，每个bit代表一个子集和，如果为1意味着可达
        std::bitset<10001> dp{};
        dp[0] = true; // 不选择任何数字，和为0是可能的
		
        #pragma GCC unroll 8
        for(int num : nums) {
            dp |= dp << num; // 通过移位 和 或运算表示 +法 得到的子集和
        }
        return dp[maxSubSum];// 查看 一半和 是否可达
    }
};
```

## [1049. 最后一块石头重量II](https://leetcode.cn/problems/last-stone-weight-ii/description/)（0-1背包）

### 描述解析

#### 分析

**拆分为石头总和 的一半，重量大的减掉重量小的**

石头的值就是物品的价值和重量

```

```



#### `dp[i]` 含义

`容量为 i 的最重量 dp[i]`

### 解题方法

#### 1. 动态规划

```C++
class Solution {
public:
    int lastStoneWeightII(std::vector<int>& stones) {
        std::size_t totalSum{0};

        #pragma GCC unroll 8
        for(int num : stones) totalSum += num;

        std::size_t half{ totalSum >> 1 };
        std::vector<std::size_t> dp(half + 1, 0);
        
        for(int num : stones) {
            #pragma GCC unroll 4
            for(std::size_t j = half; j >= num; --j) {
                if(int value = dp[j - num] + num; value > dp[j])
                    dp[j] = value;
            }
        }
        // 凑完成之后，一堆石头的重量是 dp[totalSum] 那么另一对的石头重量是 totalSum - dp[totalSum]
        // 并且 应为 half 除以 2的原因，则totalSum - dp[totalSum]的值一定比 dp[totalSum] 大
        // 所以 totalSum - dp[totalSum] - dp[totalSum]得到最终最小结果
        return totalSum - (dp.back() << 1);
    }
};
```

## [494. 目标和](https://leetcode.cn/problems/target-sum/description/)（0-1背包）

### 描述解析

#### 分析

给定一个正数集合，每个数可以添加加号减号视为正/负，集合中能够得到 target的正负数集合个数

正数集合positive、负数集合negative（仍旧是正数，只是视为负数集合）

```
positive + negative = Sum；

positive - negative = target；

positive - （Sum - positive）= target；

positive = （target + Sum）/ 2 //正数集合的个数，那么其余的就是负数集合的个数了

// 注意事项
如果  （target + Sum）/ 2  不能被整除 说明找不到集合满足 等于target
举例 
[1 1 1 1 1]
Sum = 5 target = 2 
7 / 2
正 负
1  4 3
2  3 1
3  2 -1
4  1 -3

正数positive的集合个数就是背包的容量
1 dp[4]
2 dp[3]
..
5 dp[0]

dp[5]的方法等于 dp[4]+...+dp[0]
递推公式dp[j] += dp[j - num];
```



#### `dp[i]` 含义

`装满背包容量为 i 有 dp[i]种方法`

### 解题方法

#### 1. 动态规划

```C++
class Solution {
public:
    int findTargetSumWays(std::vector<int>& nums, int target) {
        int sum{0};
        #pragma GCC unroll 8
        for (int num : nums) sum += num;

        if (std::abs(target) > sum) return 0;

        int positiveSize = sum + target;
        // 奇数不能被整除 说明无法满足
        if (positiveSize & 1) return 0;
        positiveSize >>= 1;

        std::vector<int> dp(positiveSize + 1, 0);
        dp[0] = 1;
        for(int num : nums)
        {
            #pragma GCC unroll 4
            for(int j = positiveSize; j >= num; --j)
            {
                dp[j] += dp[j - num];
            }
        }
        return dp[positiveSize];
    }
};
```

## [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)（0-1背包）

### 描述解析

#### 分析

m、n是两个背包容量，每个物品有两个属性0、1要尽可能大满足m、n，只能选一次是0-1背包变种

物品的重量是每个str的x个0和y个1

```

```



#### `dp[i][j]` 含义

`装满i个0 j 个1 最多背了dp[i][j]个物品`

### 解题方法

#### 1. 动态规划

##### 二维

```C++
class Solution {
public:
    int findMaxForm(std::vector<std::string>& strs, int m, int n) {
        std::vector<std::vector<int>> dp(m + 1, std::vector<int> (n + 1, 0));
        // 0-1 背包 变种 一个物品装在两个背包中，满足价值最大
        #pragma GCC unroll 8
        for (auto& str : strs) { // 一个物品
            int oneCount = 0, zeroCount = 0;
            #pragma GCC unroll 8
            for (char c : str) {
                c == '0' ? ++zeroCount : ++oneCount;
            }
            #pragma GCC unroll 8
            for (int i = m; i >= zeroCount; --i) { // 两个背包
                for (int j = n; j >= oneCount; --j) {
                    // dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
                    // value[i] 是1，因为如果大于你需要将物品个数加进来
                    // 两个背包 dp[j - weight[i] -> dp[i - zeroCount][j - oneCount]
                    // 这里 dp[i][j] 是和 标准的0-1背包的 dp[j]对应，都是背包
                    dp[i][j] = std::max(dp[i][j], dp[i - zeroCount][j - oneCount] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```



##### 一维缓存优化（实际还是二维大小）

```C++
class Solution {
public:
    int findMaxForm(std::vector<std::string>& strs, int m, int n) {
        std::vector<int> dp((m + 1) * (n + 1), 0);
        // 0-1 背包 变种 一个物品装在两个背包中，满足价值最大
        #pragma clang loop vectorize(enable) interleave(enable) unroll_count(8)
        for (auto& str : strs) { // 一个物品
            int zeroCount = 0, oneCount = 0;
            #pragma clang loop vectorize(enable) interleave(enable) unroll_count(8)
            for (char c : str) {
                c == '0' ? ++zeroCount : ++oneCount;
            }
            #pragma clang loop vectorize(enable) interleave(enable) unroll_count(8)
            for (int i = m; i >= zeroCount; --i) { // 两个背包
                #pragma clang loop vectorize(enable) interleave(enable) unroll_count(8)
                for (int j = n; j >= oneCount; --j) {
                     int idx = i * (n + 1) + j;
                    int prev_idx = (i - zeroCount) * (n + 1) + (j - oneCount);
                    dp[idx] = std::max(dp[idx], dp[prev_idx] + 1);
                }
            }
        }
        return dp.back(); // dp[m * (n + 1) + n];
    }
};
```

## [518. 零钱兑换II](https://leetcode.cn/problems/coin-change-ii/)（完全背包）组合数

> 可见 [494. 目标和](https://leetcode.cn/problems/target-sum/description/)（0-1背包） 思想类似，都是求多少种方法

### 描述解析

#### 分析

需要求组合数，[1 2] 和 [2 1] 一样，没有顺序

### 解题方法

#### 1. 动态规划

```C++
class Solution {
public:
    int change(int amount, std::vector<int>& coins) {
        std::vector<std::size_t> dp(amount + 1, 0);
        dp[0] = 1;
        // 不能颠倒，如果是颠倒的，就是求排列数可以重复，[1 2] [2 1]
        for(int num : coins) { // 物品
            #pragma clang loop vectorize(enable) unroll_count(8)
            for(int j = num; j <= amount; ++j) { // 背包
                dp[j] += dp[j - num];
            }
        }
        /*
        	for(j = 0; j <= amount; ++j)
        		for(i = 0; i < coins.size(); ++i)
        */
        return dp.back();
    }
};
```

## [377. 组合总数 IV](https://leetcode.cn/problems/combination-sum-iv/)（完全背包）排列数

### 描述解析

#### 分析

需要求排列数，有顺序，并且是求多少种

### 解题方法

#### 1. 动态规划

```C++
class Solution {
public:
    int combinationSum4(std::vector<int>& nums, int target) {
        std::vector<std::size_t> dp(target + 1, 0);
        dp.front() = 1;

        for(int j = 0; j <= target; ++j) {
            #pragma clang loop vectorize(enable) unroll_count(8)
            for(int num : nums) {
                if (j - num >= 0) dp[j] += dp[j - num];
            }
        }
        return dp.back();
    }
};
```

## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)（完全背包）

### 描述解析

#### 分析



### 解题方法

#### 1. 动态规划

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if (amount == 0) return 0;
        
        // 取最小，我们就设置最大
        std::vector<std::size_t> dp(amount + 1, amount + 1);
        // amount == 0 就是0
        dp[0] = 0;
        #pragma clang loop interleave(enable) unroll_count(8)
        for (int coin : coins) {
            #pragma clang loop interleave(enable) unroll_count(8)
            for (int j = coin; j <= amount; ++j) {
                // + 1 加上本身，及值，coin的值则是weight，取最小
                if(auto value = dp[j - coin] + 1; value < dp[j]) dp[j] = value;
            }
        }
        
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
```



## [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/)（完全背包）

### 描述解析

#### 分析



### 解题方法

#### 1. 动态规划

```C++
class Solution {
public:
    int numSquares(int n) {
        std::vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        #pragma clang loop interleave(enable) unroll_count(8)
        for(int i = 1; i * i <= n; ++i) { // 物品 完全平方数
            #pragma clang loop vectorize(enable) interleave(enable) unroll_count(8)
            for(int j = i * i; j <= n; ++j) { // 背包
                if(std::size_t val = dp[j - i * i] + 1; val < dp[j]) dp[j] = val;
            }
        }
        return dp.back();
    }
};

// 更优
class Solution {
public:
    int numSquares(int n) {
        std::vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        #pragma clang loop interleave(enable) unroll_count(8)
        for(int i = 1; i <= n; ++i) { // 背包
            #pragma clang loop vectorize(enable) interleave(enable) unroll_count(8)
            for(int j = 1; j * j <= i; ++j) { // 物品
                if(std::size_t val = dp[i - j * j] + 1; val < dp[i]) dp[i] = val;
            }
        }
        return dp.back();
    }
};
```



## [139. 单词拆分](https://leetcode.cn/problems/word-break/description/)（完全背包）排列数

### 描述解析

#### 分析

区间

```
—— —— ——
  j  i
如果dp[j] true，那么需要判断 区间 j-i 的这个字符串是否在字典内，如果是，那么dp[i]则是true

if([j i] && dp[j]) dp[i] = true;

初始化 dp[0] = true，如果是false，那么 意味着 dp[j]始终是false，则影响到之后的dp计算，所以应该设置为true
即使题目中 s至少是一长度，dp[0]没有实际意义，但是为了递推进行应该设置为true

其他非0的下标 初始化为 false，它们需要由先前的状态推到而来

要求顺序
appleandapple
1 2 1
不能是 112
```



#### `dp[i]` 含义

`串长度为i的时候是否能够由物品拼接为它`

### 解题方法

#### 1. 动态规划

##### 标准

```C++
class Solution {
public:
    bool wordBreak(std::string s, std::vector<std::string> wordDict) {
        std::vector<uint8_t> dp(s.size() + 1, false); //  背包问题 + 1，需要适用dp[0]
        dp[0] = true;
        
        for(int j = 1; j <= s.size(); ++j) {
            for(int i = 0; i < j; ++i) { // 物品重量不可能超过背包容量
                if (dp[i] && std::find(wordDict.begin(), wordDict.end(), s.substr(i, j - i)) != wordDict.end()) {
                    dp[j] = true; break;
                }
            }
        }
        return dp.back();
    }
};
```



##### 查询优化

* 优化原理

这个优化的核心思想是：**只检查可能存在于字典中的子字符串长度**。

* 为什么需要这个优化？

1. **避免无效检查**：
   - 如果 `j - i > maxLength`，那么这个子字符串的长度超过了字典中最长单词的长度
   - 这样的子字符串**绝对不可能**在字典中找到
   - 直接跳过这些检查可以节省大量时间
2. **减少循环次数**：
   - 没有优化时：内层循环从 `i = 0` 到 `i = j-1`，共 `j` 次迭代
   - 优化后：内层循环从 `i = max(0, j - maxLength)` 到 `i = j-1`，最多 `maxLength` 次迭代

举例说明

假设：

- `s = "leetcode"`
- `wordDict = ["leet", "code"]`
- `maxLength = 4`（"leet"的长度）

当 `j = 5` 时：

- 没有优化：检查 `i = 0,1,2,3,4`
- 优化后：`max(0, 5-4) = 1`，只检查 `i = 1,2,3,4`

跳过 `i=0` 是因为子字符串 `s[0:5] = "leetc"` 长度为5，超过了最大单词长度4，肯定不在字典中。

```C++
class Solution {
public:
    bool wordBreak(std::string s, std::vector<std::string> wordDict) {
        std::size_t maxLength{ 0 };
        std::unordered_set<std::string_view> wordSet;
        for (const std::string& word : wordDict) {
            if (maxLength < word.size()) maxLength = word.size();
            wordSet.emplace(word.data(), word.size());
        }

        std::vector<std::uint8_t> dp(s.size() + 1, false);
        dp.front() = true;
        for (int j = 1; j <= s.size(); ++j) {
            for (int i = std::max(0, j - (int)maxLength); i < j; ++i) {
                if (dp[i] && wordSet.contains(std::string_view(s.data() + i, j - i))) {
                    dp[j] = true;
                    break;
                }
            }
        }
        return dp.back();
    }
};
```

# 状态机DP

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

### 描述解析

#### 分析

选与不选

```
偷i dp[i - 2] + nums[i]
不偷i dp[i - 1] （注意这里我们不一定偷 i - 1的值，而是将其纳入考虑范围内，i - 1 及i - n的区间内都可以是dp[i - 1]）
```



#### `dp[i]` 含义

`**考虑**下标 i (包含) 偷的最大金币`

### 解题方法

#### 1. 动态规划

##### 标准

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        std::vector<int> dp(nums.size(), 0);
        dp[0] = nums[0], dp[1] = std::max(nums[0], nums[1]);

        for(int i = 2; i < nums.size(); ++i) {
            dp[i] = std::max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp.back();;
    }
};
```



##### 状态压缩优化

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int rob = nums[0], not_rob = 0, maxMoney = rob;

        for(int i = 1; i < nums.size(); ++i) {
            if(int currMoney = not_rob + nums[i]; currMoney > rob) maxMoney = currMoney;
            not_rob = rob;
            rob = maxMoney;
        }
        return maxMoney;
    }
};
```

## [213. 打家劫舍II](https://leetcode.cn/problems/house-robber-ii/description/)

### 描述解析

#### 分析

选与不选

### 解题方法

#### 1. 动态规划

##### 标准



##### 两次动态规划

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int rob = nums[0], not_rob = 0, maxMoney = rob;
        // 情况1：抢劫第一个房子，不抢劫最后一个房子
        for (int i = 1; i < nums.size() - 1; ++i) {
            if(int currMoney = not_rob + nums[i]; currMoney > maxMoney)
                maxMoney = currMoney;
            not_rob = rob;
            rob = maxMoney;
        }
        // 情况2：不抢劫第一个房子，可以抢劫最后一个房子
        if(nums.size() >= 2) {
            int rob2 = nums[1], not_rob2 = 0, maxMoney2 = rob2;
            for (int i = 2; i < nums.size(); ++i) {
                if(int currMoney2 = not_rob2 + nums[i]; currMoney2 > maxMoney2)
                    maxMoney2 = currMoney2;
                not_rob2 = rob2;
                rob2 = maxMoney2;
            }

            return maxMoney2 > maxMoney ? maxMoney2 : maxMoney;
        }
        
        return rob;
    }
};
```

##### 优化

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        
        // 情况1：抢劫第一个房子，不抢劫最后一个房子
        int rob1 = nums[0], not_rob1 = 0;
        int max1 = rob1;
        
        // 情况2：不抢劫第一个房子，可以抢劫最后一个房子
        int rob2 = 0, not_rob2 = 0;
        int max2 = 0;
        
        #pragma clang lool unroll_count(8)
        for (int i = 1; i < nums.size(); ++i) {
            // 更新情况1（不包含最后一个房子）
            if (i < nums.size() - 1) [[likely]] {
                int curr1 = not_rob1 + nums[i];
                if (curr1 > max1) max1 = curr1;
                not_rob1 = rob1;
                rob1 = max1;
            }
            
            // 更新情况2（不包含第一个房子）
            int curr2 = not_rob2 + nums[i];
            if (curr2 > max2) max2 = curr2;
            not_rob2 = rob2;
            rob2 = max2;
        }
        
        return max1 > max2 ? max1 : max2;
    }
};
```

## [337. 打家劫舍III](https://leetcode.cn/problems/house-robber-iii/)（树形DP）



```c++
class Solution {
public:
    int rob(TreeNode* root) {
        auto [root_rob, root_not_rob] = dfs(root);
        return std::max(root_rob, root_not_rob); // 根节点选或不选的最大值
    }

    // 后续遍历，自底向上需要传递状态
    std::pair<int, int> dfs(TreeNode* node) {
        if (node == nullptr) { // 递归边界
            return {0, 0}; // 没有节点，怎么选都是 0
        }

        auto [l_rob, l_not_rob] = dfs(node->left); // 递归左子树
        auto [r_rob, r_not_rob] = dfs(node->right); // 递归右子树
        int rob = l_not_rob + r_not_rob + node->val; // 选当前，加上先前值
        // **当前不偷**的情况，意味着左右有间隔，从**左右孩子**选择偷与不偷的最大相加
        int not_rob = std::max(l_rob, l_not_rob) + std::max(r_rob, r_not_rob); // 不选

        return {rob, not_rob};
    }
};
```



## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

### 描述解析

#### 分析

买卖股票1（单次交易）

  只能买卖一次，所以买入时没有"先前状态"的概念

  买入时的成本就是 -prices[i]（从0现金开始）

  不能利用之前卖出股票的利润来再次买入



`状态机，买或不买，仅能买卖一次`



### 解题方法

#### 1. 动态规划

##### 标准1

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        
        // dp[i][0]: 第i天不持有股票的最大利润
        // dp[i][1]: 第i天持有股票的最大利润
        vector<vector<int>> dp(n, vector<int>(2, 0));
        
        // 初始化
        dp[0][0] = 0;           // 第0天不持有股票
        dp[0][1] = -prices[0];  // 第0天持有股票（买入）
        
        for (int i = 1; i < n; i++) {
            // 第i天不持有股票：昨天就不持有，或者昨天持有今天卖出
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // 第i天持有股票：昨天就持有，或者今天买入（注意：只能交易一次，所以是 -prices[i]）
            dp[i][1] = max(dp[i-1][1], -prices[i]);
        }
        
        return dp[n-1][0];  // 最后一天不持有股票的最大利润
    }
};
```

##### 标准2（dp + 贪心思想）

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        
        vector<int> dp(n, 0);  // dp[i]: 前i天的最大利润
        int minPrice = prices[0];
        
        for (int i = 1; i < n; i++) {
            minPrice = min(minPrice, prices[i]);
            dp[i] = max(dp[i-1], prices[i] - minPrice);
        }
        
        return dp[n-1];
    }
};
```

##### 标准1 plain数组优化

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        struct Profit {
            int sell{0};
            int buy{0};
        };
        std::vector<Profit> dp(prices.size());
        auto& [sell, buy] = dp.front();  
        buy = -prices.front();

        for(int i = 1; i < prices.size(); ++i) {
            auto [prev_sell, prev_buy] = dp[i - 1];
            auto& [curr_sell, curr_buy] = dp[i];
            int price = prices[i];
            curr_sell = std::max(prev_sell, prev_buy + price);
            curr_buy = std::max(prev_buy, -price);
        }
        return dp.back().sell;
    }
};
```

##### 标准1 状态压缩最优

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int not_hold_stock_profit{ 0 };            // 不持有股票的最大利润
        int hold_stock_profit{ -prices.front() };  // 持有股票的最大利润
        
        for (int i = 1; i < prices.size(); ++i) {
            int curr_price = prices[i];

            int curr_profit;
            // 更新不持有股票的最大利润
            if (int curr_profit = hold_stock_profit + curr_price;
                curr_profit > not_hold_stock_profit)
                not_hold_stock_profit = curr_profit;
            // 更新持有股票的最大利润
            if (curr_profit = -curr_price;
                curr_profit > hold_stock_profit)
                hold_stock_profit = curr_profit;  
        }
        
        return not_hold_stock_profit;
    }
};
```

##### 标准2 状态压缩最优

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price{ prices.front() }, max_profit{ 0 };
        #pragma GCC unroll 8
        for(auto it = std::next(prices.begin()); it != prices.end(); ++it) {
            if (*it < min_price) {
                min_price = *it;
                continue;
            }
            if (int curr_profit = *it - min_price; curr_profit > max_profit) max_profit = curr_profit;
        }
        return max_profit;
    }
};
```



## [122. 买卖股票的最佳时机II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

### 描述解析

#### 分析

买卖股票2（多次交易）

  可以买卖多次，所以买入时要考虑之前的利润

  dp[i - 1].no - prices[i] 表示用之前卖出股票获得的利润来买入新股

  这样可以实现"滚动投资"，用前一笔交易的利润进行下一笔投资



`状态机，买或不买，能够利用先前的卖出的利润再买入`

### 解题方法

#### 1. 动态规划

##### 标准1

```c++
int maxProfit(vector<int>& prices) {
    int n = prices.size();
    vector<vector<int>> dp(n, vector<int>(2));
    // dp[i][0]: 第i天结束时未持有股票的最大利润
    // dp[i][1]: 第i天结束时持有股票的最大利润
    
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    
    for(int i = 1; i < n; i++) {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]); // 卖出
        dp[i][1] = max(dp[i-1][1], dp[i-0][0] - prices[i]); // 买入
    }
    
    return dp[n-1][0];
}
```



##### 标准1 状态压缩最优

```C++
int maxProfit(vector<int>& prices) {
    // 前一天结束时持有股票的最大利润, 前一天结束时未持有股票的最大利润
    int buy{ -prices.front() }, sell{ 0 };

    #pragma GCC unroll 8
    for(auto it = std::next(prices.begin()); it != prices.end(); ++it) {
        // 今天未持有：昨天未持有或今天卖出
        if (int val = sell - *it; val > buy) buy = val;
        // 今天持有：昨天持有或今天买入
        if (int val = buy + *it; val > sell) sell = val;
    }

    return sell;
}
```

##### 标准2

```C++
int maxProfit(vector<int>& prices) {
    int n = prices.size();
    if (n <= 1) return 0;
    
    // dp[i] 表示到第i天为止能获得的最大利润
    vector<int> dp(n, 0);
    // min_price[i] 表示到第i天为止遇到的最小价格
    vector<int> min_price(n, 0);
    
    // 初始化
    min_price[0] = prices[0];
    dp[0] = 0;
    
    for (int i = 1; i < n; i++) {
        // 更新最小价格
        min_price[i] = min(min_price[i-1], prices[i]);
        
        // 计算今天的利润选择：要么不操作，要么在今天卖出（如果有利可图）
        int profit_if_sell = prices[i] - min_price[i];
        
        if (profit_if_sell > 0) {
            // 如果今天卖出有利可图，我们选择卖出并重置最小价格
            dp[i] = dp[i-1] + profit_if_sell;
            min_price[i] = prices[i]; // 重置最小价格为当前价格
        } else {
            // 如果今天卖出无利可图，保持之前的利润
            dp[i] = dp[i-1];
        }
    }
    
    return dp[n-1];
}
```



##### 标准2 状态压缩最优

```C++
int maxProfit(vector<int>& prices) {
    int totalProfit = 0;
    int min_price = prices.front();
    int prev_price = min_price, curr_price{ -1 }; // 需要赋值处理prices.size() == 1的情况 即最后一天
    #pragma GCC unroll 8
    for (int i = 1; i < prices.size(); ++i) {
        prev_price = prices[i - 1];
        curr_price = prices[i];
        // 如果价格下跌，重置最小价格并累加之前的利润
        if (curr_price < prev_price) {
            totalProfit += prev_price - min_price;
            min_price = curr_price;
        }
    }
    // 最后一天的特殊处理
    if (curr_price >= prev_price) {
        totalProfit += curr_price - min_price;
    }
    
    return totalProfit;
}
```



#### 2. 贪心（由标准2 状态压缩最优推到而来）

只需要收集盈利的即可

```c++
int maxProfit(vector<int>& prices) {
    int result{0};
    #pragma GCC unroll 8;
    for(int i = 1; i < prices.size(); ++i) {
        if(auto positive = prices[i] - prices[i - 1]; positive > 0) {
            result += positive;
        }
    }
    return result;
}
```



## [123. 买卖股票的最佳时机III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/) 

### 描述解析

#### 分析

第一次买入，在初始状态下买入，本金是0，所以 -prices.front()，第一次卖出 必须是买入了才能卖，所以又买又卖是0

第二次买入，在第一次买入再买（不符合题意在买入下一次之前必须卖出前一次），在第一次卖出再买，所以 -prices.front()，第二次卖出 必须是买入了才能卖，所以又买又卖是0



`状态机，买或不买，买卖两次，第二次买必须再第一次卖之后`

### 解题方法

#### 1. 动态规划

##### 状态压缩最优

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy1{ -prices.front() }, sell1{ 0 };
        int buy2{ -prices.front() }, sell2{ 0 };

        #pragma GCC unroll 8
        for(auto it = std::next(prices.begin()); it != prices.end(); ++it) {
            if (-*it > buy1) buy1 = -*it;
            if (int val = buy1 + *it; val > sell1) sell1 = val;

            if (int val = sell1 - *it; val > buy2) buy2 = val;
            if (int val = buy2 + *it; val > sell2) sell2 = val;
        }

        return sell2;
    }
};
```

## [188. 买卖股票的最佳时机IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/) 

### 描述解析

#### 分析

`状态机，买或不买，买卖多次，可以使用之前的卖的利润买入新的股票，但是在买之前必须卖`

### 解题方法

#### 1. 动态规划

```C++
int maxProfit(int k, vector<int>& prices) {
    std::vector<int> buy(k + 1, -prices[0]), sell(k + 1, 0);
    #pragma clang loog unroll_count(4)
    for(int i = 1; i < prices.size(); ++i) {
        #pragma clang loop interleave(enable) unroll_count(4)
        for(int j = 1; j <= k; ++j) {
            if (int val = sell[j - 1] - prices[i]; val > buy[j]) buy[j] = val;
            if (int val = buy[j] + price[i]; val > sell[j]) sell[j] = val;
        }
    }
    return sell.back();
}
```

## [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

### 描述解析

#### 分析

> 买卖股票的最佳时机II的变种

分为四种状态， 持有股票，保持卖出股票状态，卖出股票状态，冷冻期

> 在买卖股票的最佳时机II中， 保持卖出股票状态，卖出股票状态统称为不持有股票状态



初始化

```
		  取最大
dp[i][0]  保持先前的持有股票状态 dp[i - 1][0]
		  在冷冻期之后（立即）买入股票变为持有股票状态  dp[i - 1][3] - prices[i]
		  在冷冻期之后（延时）一直保持卖出股票的状态然后买入  dp[i - 1][2] - prices[i]

dp[i][1]  保持先前的卖出股票状态 dp[i - 1][1]
		  在冷冻期之后变为卖出股票状态  dp[i - 1][3]

dp[i][2]  持有股票的状态卖出 dp[i - 1][0] + prices[i]

dp[i][3]  前一天必定是先持有股票再卖出的状态 dp[i - 1][2] 
```

### 解题方法

#### 1. 动态规划

##### 标准

```C++
int maxProfit(const std::vector<int>& prices) {
    if (prices.empty()) {
        return 0;
    }

    int n = prices.size();

    // dp[i][j]: 第i天在状态j下的最大收益
    // 状态定义:
    // 0: 持有股票状态
    // 1: 不持有股票，且不在冷冻期
    // 2: 今天卖出股票（即将进入冷冻期）
    // 3: 处于冷冻期
    std::vector<std::vector<int>> dp(n, std::vector<int>(4, 0));

    // 初始化第一天
    dp[0][0] = -prices[0]; // 第一天买入股票
    dp[0][1] = 0;          // 第一天不操作
    dp[0][2] = 0;          // 第一天不可能卖出
    dp[0][3] = 0;          // 第一天不可能在冷冻期

    for (int i = 1; i < n; ++i) {
        // 状态0: 持有股票
        // 可能情况:
        // 1. 保持前一天的持有状态
        // 2. 从冷冻期结束后立即买入
        // 3. 从非冷冻期状态买入
        dp[i][0] = std::max({
            dp[i - 1][0],                    // 保持持有
            dp[i - 1][3] - prices[i],        // 冷冻期结束后买入
            dp[i - 1][1] - prices[i]         // 非冷冻期买入
        });

        // 状态1: 不持有股票，且不在冷冻期
        // 可能情况:
        // 1. 保持前一天的不持有状态
        // 2. 从前一天的冷冻期结束
        dp[i][1] = std::max(
            dp[i - 1][1],  // 保持不持有
            dp[i - 1][3]   // 冷冻期结束
        );

        // 状态2: 今天卖出股票
        // 只能从前一天的持有状态卖出
        dp[i][2] = dp[i - 1][0] + prices[i];

        // 状态3: 处于冷冻期
        // 只能是前一天卖出了股票
        dp[i][3] = dp[i - 1][2];
    }

    // 最后一天的最大收益来自不持有股票的三种状态
    return std::max({
        dp[n - 1][1],  // 不持有，非冷冻期
        dp[n - 1][2],  // 今天卖出
        dp[n - 1][3]   // 冷冻期
    });
}
```



##### 扁平化优化

```C++
int maxProfit(const std::vector<int>& prices) 
    struct TradingState {
        int hold_stock;       // 状态0: 持有股票
        int not_hold;         // 状态1: 不持有股票，非冷冻期  
        int sell_today;       // 状态2: 今天卖出
        int cooldown;         // 状态3: 冷冻期
    };
    if (prices.empty()) {
        return 0;
    }

    int n = prices.size();
    // 使用扁平化数组存储状态，提高缓存友好性
    std::vector<TradingState> dp(n);

    // 初始化第一天状态
    dp[0].hold_stock = -prices[0];  // 第一天买入
    dp[0].not_hold = 0;             // 第一天不操作
    dp[0].sell_today = 0;           // 第一天不可能卖出
    dp[0].cooldown = 0;             // 第一天不可能冷冻

    for (int i = 1; i < n; ++i) {
        const TradingState& prev = dp[i - 1];
        TradingState& current = dp[i];

        // 状态转移逻辑
        current.hold_stock = std::max({
            prev.hold_stock,              // 保持持有
            prev.cooldown - prices[i],    // 冷冻期结束后买入
            prev.not_hold - prices[i]     // 非冷冻期买入
        });

        current.not_hold = std::max(
            prev.not_hold,  // 保持不持有
            prev.cooldown   // 冷冻期结束
        );

        current.sell_today = prev.hold_stock + prices[i];  // 卖出持有股票

        current.cooldown = prev.sell_today;  // 进入冷冻期
    }

    const TradingState& final_state = dp[n - 1];
    return std::max({
        final_state.not_hold,
        final_state.sell_today, 
        final_state.cooldown
    });
}
```



##### 最优 状态压缩优化

```c++
int maxProfit(const std::vector<int>& prices) {
    if (prices.empty()) {
        return 0;
    }

    // 使用单个变量记录前一天的状态，减少内存占用
    int hold_stock = -prices[0];  // 持有股票
    int not_hold = 0;             // 不持有，非冷冻期
    int sell_today = 0;           // 今天卖出
    int cooldown = 0;             // 冷冻期
	#pragma clang loop unroll_count(8)
    for (int i = 1; i < prices.size(); ++i) {
        int prev_hold = hold_stock;
        int prev_not_hold = not_hold;
        int prev_sell = sell_today;
        int prev_cool = cooldown;

        // 更新当前状态
        hold_stock = std::max({
            prev_hold,
            prev_cool - prices[i],
            prev_not_hold - prices[i]
        });

        not_hold = std::max(prev_not_hold, prev_cool);
        sell_today = prev_hold + prices[i];
        cooldown = prev_sell;
    }

    return std::max({not_hold, sell_today, cooldown});
}
```

## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

### 描述解析

#### 分析

> 买卖股票的最佳时机II的变种

在卖出的时候付手续费即可

### 解题方法

#### 1. 动态规划

```C++
int maxProfit(vector<int>& prices, int fee) {
    int buy{ -prices.front() }, sell{ 0 };

    #pragma clang loop unroll_count(8)
    for(auto it = std::next(prices.begin()); it != prices.end(); ++it) {
        if (int val = sell - *it; val > buy) buy = val;
        if (int val = buy + *it - fee; val > sell) sell = val;
    }

    return sell;
}
```

# 子序列

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

### 描述解析

#### 分析



```
—— —— ——
  j  i
如果dp[j] 是一个递增子序列
考虑区间 [j, i]， 如果 dp[i] > dp[j]，那么， dp[j] + 1得到dp[i]的递增子序列长度
区间[j, i]之间有多个元素，遍历j不断靠近i，每个元素都要 dp[j] < dp[i]比较，dp[i] 需要取最大值 = max(dp[j] + 1, dp[i])
因为 i 是固定的，j从头开始，不断的更新了dp[i]，所以需要从dp[j] + 1, dp[i]二者取最大

至少包含一个num，我们初始化都是1

每次遍历一个j i区间结束之后，都要更新最大长度，我们的dp.back()存储的仅仅是 i 对应的最长递增子序列长度，但是不意味着是全局最长的

  0 1 0 3 2
0 1 1 1 1 1
1 1 2 1 1 1 
0 1 2 1 1 1
3 1 2 1 3 1
2 1 2 1 3 3
```



#### `dp[i]` 含义

以nums[i] 为结尾的最长递增子序列的长度



### 解题方法

#### 1. 动态规划

```C++
int lengthOfLIS(vector<int>& nums) {
    // dp[i]表示以nums[i]结尾的最长递增子序列的长度
    std::vector<int> dp(nums.size(), 1);

    int maxLength{ 1 };
    for(int i = 1; i < nums.size(); ++i) {
        //考虑从数组开始到当前位置的所有可能的子序列
        for(int j = 0; j < i; ++j) {
            //可以将 nums[i] 接在以 nums[j] 结尾的子序列后面，形成一个更长的递增子序列
            if(nums[i] > nums[j] && dp[j] + 1 > dp[i])
                dp[i] = dp[j] + 1;
        }
        if (dp[i] > maxLength) maxLength = dp[i];
    }
    return maxLength;
}
```



#### 2. 贪心+二分查找+滑动窗口

类似原地hash映射思想，滑动窗口只增大

```C++
int lengthOfLIS(vector<int>& nums) {
    // window[i]表示长度为i+1的递增子序列的最小结尾元素
    std::vector<int> window; window.reserve(nums.size());

    for(int num : nums) {
        // 使用二分查找找到第一个大于等于num的位置
        auto it = std::lower_bound(window.begin(), window.end(), num);
		
        // 如果没有找到大于等于num的元素，说明num比所有window元素都大
        // 将num添加到window末尾，表示找到了一个更长的递增子序列
        if (it != window.end()) {
            *it = num;
        }
        // 否则，更新该位置的值为num
        // 这意味着我们找到了一个更小的结尾元素，可以形成相同长度的递增子序列
        else {
            window.emplace_back(num);
        }
    }
    // window的长度就是最长递增子序列的长度
    return window.size();
}
```

## 674. 最长连续递增序列

### 描述解析

#### 分析

定义dp[i]为以第i个元素结尾的最长连续递增子序列的长度。
那么状态转移方程为：
如果nums[i] > nums[i-1]，那么dp[i] = dp[i-1] + 1；
否则，dp[i] = 1。
然后我们取dp数组中的最大值即可。

### 解题方法

#### 1. 双指针

```C++
int findLengthOfLCIS(vector<int>& nums) {
    int left = 0, right = 1, max = 1;
    while(right < nums.size()) {
        // 递减
        if (nums[right] <= nums[right - 1]){
            if (int val = right - left; val > max) max = val;
            left = right;
        }

        ++right;
    }
    // 连续增
    if (int val = right - left; val > max) max = val;
    return max;
}
```

#### 2. 动态规划

##### 标准

```C++
int findLengthOfLCIS(vector<int>& nums) {
    // dp[i] 表示以 nums[i] 结尾的最长连续递增子序列的长度
    vector<int> dp(nums.size(), 1);
    int maxLen = 1;
    
    for (int i = 1; i < nums.size(); ++i) {
        dp[i] = nums[i] > nums[i - 1] ? dp[i - 1] + 1 : 1;
        if(maxLen < dp[i]) maxLen = dp[i];
    }
    
    return maxLen;
}
```

##### 空间优化

```C++
int findLengthOfLCIS(vector<int>& nums) {
    int currLen = 1;  // 当前连续递增序列长度
    int maxLen = 1;   // 全局最大长度
    
    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > nums[i - 1]) {
            ++currLen;
            if(maxLen < currLen) maxLen = currLen;
        } else {
            currLen = 1;  // 重置当前长度
        }
    }
    
    return maxLen;
}
```

## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/)

### 描述解析

#### 分析

```
1 2 3 2 1
    ^ ^ ^
3 2 1 4 7
^ ^ ^

  3 2 1 4 7 x
1 0 0 1 0 0
2 0 1 0 0 0
3 1 0 0 0 0
2 0 2 0 0 0
1 0 0 3 0 0

if (nums[i - 1] == nums[j - 1]) d[i][j] = dp[i - 1]dp[j - 1] + 1
如果两个数相等，我们要根据前一个的dp[i - 1]dp[j - 1] 进行 + 1，为什么因为子数组相等必定是两个指针进行一起移动而不是单个指针移动，不是dp[i][j - 1] 或 dp[i - 1][j]

下标从1开始遍历，我们初始化第一行第一列都为0，因为其他需要根据第一行第一列+1 计算，其他也是0则是因为可以直接更新
如果是下标从0开始遍历，则需要更新第一行和第一列的值，需要进行比较初始化，相等时1否则是0，比较麻烦，并且性能低

为了这样我们其实的第一行第一列是不需要遍历的，i = 1 j = 1
但是为了让size满足nums.size， < 变为 <=

需要注意的是dp含义，dp.back().back()不是我们想要的数据，看例子就是知道了，nums2的最后的结果不是321
```



#### `dp[i][j]` 含义

以 i - 1 结尾的nums1和以 j - 1 结尾的nums2 的最长重复子数组

### 解题方法

#### 1. 动态规划

##### 标准1

```C++
int findLength(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.empty() || nums2.empty()) return 0;
    int result = 0;
    std::vector<std::vector<int>> dp(nums1.size() + 1, std::vector<int>(nums2.size() + 1));
    for (int i = 0; i < nums1.size(); ++i) if (nums1[i] == nums2[0]) dp[i][0] = 1;
    for (int j = 0; j < nums2.size(); ++j) if (nums1[0] == nums2[j]) dp[0][j] = 1;

    for (int i = 0; i < nums1.size(); ++i) {
        for (int j = 0; j < nums2.size(); ++j) {
            if (nums1[i] == nums2[j] && i > 0 && j > 0) { // 防⽌ i-1 出现负数
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if (dp[i][j] > result) result = dp[i][j];
        }
    }
    return result;
}
```

##### 标准2

```C++
int findLength(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.empty() || nums2.empty()) return 0;
    int result = 0;
    std::vector<std::vector<int>> dp(nums1.size() + 1, std::vector<int>(nums2.size() + 1, 0));
    
    for (int i = 1; i <= nums1.size(); ++i) {
        for (int j = 1; j <= nums2.size(); ++j) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if (dp[i][j] > result) result = dp[i][j];
        }
    }
    return result;
}
```

##### 标准2扁平化优化

```C++
int findLength(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.empty() || nums2.empty()) return 0;
    int result = 0;
    std::vector<int> dp((nums1.size() + 1) * (nums2.size() + 1), 0);

    for (int i = 1; i <= nums1.size(); ++i) {
        for (int j = 1; j <= nums2.size(); ++j) {
            int idx = i * (nums2.size() + 1) + j;
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[idx] = dp[(i - 1) * (nums2.size() + 1) + (j - 1)] + 1;
            }
            if (dp[idx] > result) result = dp[idx];
        }
    }
    return result;
}
```

##### 标准2滚动数组优化

```C++
int findLength(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.empty() || nums2.empty()) return 0;
    int result = 0;
    std::vector<int> dp(nums2.size() + 1, 0);

    for (int i = 1; i <= nums1.size(); ++i) {
        // 从后往前遍历，避免覆盖
        #pragma clang loop unroll_count(4)
        for (int j = nums2.size(); j >= 1; --j) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[j] = dp[j - 1] + 1;
                if (dp[j] > result) result = dp[j];
            } else {
                dp[j] = 0;  // 重置为0
            }
        }
    }
    return result;
}
```

##### 对角线扫描优化(性能略优滚动数组优化，空间复杂度是O(1))

> 对角扫描优化方法：
> 想象一个矩阵，其中行对应第一个序列，列对应第二个序列。矩阵中的每个元素(i, j)表示第一个序列的第i个元素和第二个序列的第j个元素是否相等。
> 我们注意到，对于每条对角线，行索引和列索引的差是常数。我们可以按对角线来遍历这个矩阵，从而将二维遍历转化为一维遍历。
>
> 具体步骤：
>
> 1. 确定对角线的范围：从矩阵的左上角开始，到右下角结束。对角线的数量为 (m + n - 1)。
> 2. 对于每条对角线，我们确定起始位置，然后沿着对角线移动，同时记录当前匹配的连续长度。
>
> 与动态规划方法的区别：
>
> - 动态规划方法：我们使用一个二维数组dp，其中dp[i][j]表示以nums1[i-1]和nums2[j-1]结尾的最长公共子数组的长度。我们需要填充整个表格，然后找到最大值。
> - 对角扫描方法：我们按对角线顺序遍历，只需要一个变量来记录当前对角线上连续匹配的长度，不需要额外的表格空间（除了几个变量）。
>
> 举例说明：
> 假设有两个数组：
> nums1 = [1, 2, 3, 4]
> nums2 = [2, 3, 4, 5]
>
> 动态规划表格（dp）如下（省略第一行和第一列的0）：
> 2  3  4  5
> 1 0  0  0  0
> 2 1  0  0  0
> 3 0  2  0  0
> 4 0  0  3  0

delta = -4: 比较 (4,0) ✓ | 长度: 1
delta = -3: 比较 (3,0) ✗ (4,1) ✓ | 长度: 1  
delta = -2: 比较 (2,0) ✓ (3,1) ✓ (4,2) ✓ | 长度: 3 ← 找到最长!
delta = -1: 比较 (1,0) ✗ (2,1) ✗ (3,2) ✗ (4,3) ✗ | 长度: 0
delta = 0:  比较 (0,0) ✗ (1,1) ✗ (2,2) ✗ (3,3) ✗ (4,4) ✗ | 长度: 0
delta = 1:  比较 (0,1) ✗ (1,2) ✗ (2,3) ✗ (3,4) ✗ | 长度: 0
delta = 2:  比较 (0,2) ✗ (1,3) ✗ (2,4) ✗ | 长度: 0
delta = 3:  比较 (0,3) ✗ (1,4) ✗ | 长度: 0
delta = 4:  比较 (0,4) ✗ | 长度: 0

**对角扫描的核心优势**：通过按对角线遍历，自然避免了重复比较，每个位置只访问一次，同时利用连续性在遇到不匹配时立即重置计数。

```C++
// 最优版本
int findLength(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.empty() || nums2.empty()) return 0;
    int m = nums1.size(), n = nums2.size();
    int maxLen = 0;

    #pragma omp parallel for reduction(max:maxLen) schedule(dynamic)
    for (int delta = -(m - 1); delta <= n - 1; ++delta) {
        // 预计算起始位置和循环次数
        const int start_i = delta < 0 ? -delta : 0;
        const int start_j = delta > 0 ? delta : 0;
        const int steps = std::min(m - start_i, n - start_j);

        int len = 0;
        // 使用局部变量减少内存访问
        int i = start_i, j = start_j;
        #pragma clang loop unroll_count(4)
        for (int k = 0; k < steps; ++k, ++i, ++j) {
            // 减少分支预测失败
            bool match = (nums1[i] == nums2[j]);
            if (match) { if (++len > maxLen) maxLen = len; }
            else len = 0;
        }
    }

    return maxLen;
}

//

int findLength(vector<int>& nums1, vector<int>& nums2) {
    if (nums1.empty() || nums2.empty()) return 0;
    int m = nums1.size(), n = nums2.size();
    int maxLen = 0;

    for (int start1 = 0; start1 < m; ++start1) {
        int i = start1, j = 0;
        int len = 0;
        #pragma clang loop unroll_count(4)
        while (i < m && j < n) {
            if (nums1[i] == nums2[j]) {
                len++;
                if (len > maxLen) maxLen = len;
            } else {
                len = 0;
            }
            i++; j++;
        }
    }

    for (int start2 = 1; start2 < n; ++start2) {
        int i = 0, j = start2;
        int len = 0;
        #pragma clang loop unroll_count(4)
        while (i < m && j < n) {
            if (nums1[i] == nums2[j]) {
                len++;
                if (len > maxLen) maxLen = len;
            } else {
                len = 0;
            }
            i++; j++;
        }
    }

    return maxLen;
}
```





#### 2. 滑动窗口(`O(m*n*l)`)

```C++
int findLength(const std::vector<int>& nums1, const std::vector<int>& nums2) {
    int m = nums1.size(), n = nums2.size();
    int maxLen = 0;
    
    // 基础滑动窗口方法
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            int len = 0;
            while (i + len < m && j + len < n && 
                   nums1[i + len] == nums2[j + len]) {
                ++len;
            }
            maxLen = std::max(maxLen, len);
        }
    }
    
    return maxLen;
}
```

#### 3. 后缀自机(`O(m+n)`)

```C++
class Solution {
public:
    struct State {
        int len;
        int link;
        std::unordered_map<int, int> next;
    };

    class SuffixAutomaton {
    private:
        std::vector<State> st;
        int last;
        int size;

    public:
        SuffixAutomaton(int maxSize) {
            st.resize(maxSize * 2);
            last = 0;
            size = 1;
            st[0].len = 0;
            st[0].link = -1;
        }

        void extend(int c) {
            int cur = size++;
            st[cur].len = st[last].len + 1;
            int p = last;
            while (p != -1 && st[p].next.find(c) == st[p].next.end()) {
                st[p].next[c] = cur;
                p = st[p].link;
            }
            if (p == -1) {
                st[cur].link = 0;
            } else {
                int q = st[p].next[c];
                if (st[p].len + 1 == st[q].len) {
                    st[cur].link = q;
                } else {
                    int clone = size++;
                    st[clone].len = st[p].len + 1;
                    st[clone].next = st[q].next;
                    st[clone].link = st[q].link;
                    while (p != -1 && st[p].next[c] == q) {
                        st[p].next[c] = clone;
                        p = st[p].link;
                    }
                    st[q].link = st[cur].link = clone;
                }
            }
            last = cur;
        }

        int findLongestCommonSubstring(const std::vector<int>& s) {
            int v = 0, l = 0, best = 0;
            for (int i = 0; i < s.size(); ++i) {
                int c = s[i];
                while (v != 0 && st[v].next.find(c) == st[v].next.end()) {
                    v = st[v].link;
                    l = st[v].len;
                }
                if (st[v].next.find(c) != st[v].next.end()) {
                    v = st[v].next[c];
                    l++;
                }
                if (l > best) {
                    best = l;
                }
            }
            return best;
        }
    };
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        SuffixAutomaton sam(nums1.size());
        for (int num : nums1) {
            sam.extend(num);
        }
        return sam.findLongestCommonSubstring(nums2);
    }
};

```

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

### 描述解析

#### 分析

```
主要就是两⼤情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同
如果text1[i - 1] 与 text2[j - 1]相同，那么找到了⼀个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;
如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最⻓公共⼦序列 和 text1[0, i - 1]与
text2[0, j - 2]的最⻓公共⼦序列，取最⼤的。
即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
    a c e
  0 0 0 0
a 0 1 1 1
b 0 1 1 1
c 0 1 2 2
d 0 1 2 2
e 0 1 2 3

举例说明不相等情况
abc|de
ace
  ^
不看e，比较abc ac那么最长公共子序列是 ac
不看c，比较ab ace那么最长公共子序列是 ac

初始化
空字符串和不空字符串最长公共子序列是0，行列都初始化为0
```



#### `dp[i][j]` 含义

⻓度为[0, i - 1]的字符串text1与⻓度为[0, j - 1]的字符串text2的最⻓公共⼦序列为dp[i][j]



### 解题方法

#### 1. 动态规划

##### 标准

```C++
int longestCommonSubsequence(string text1, string text2) {
    const int M = text1.size();
    const int N = text2.size();
    vector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));
    for (int i = 1; i <= M; ++i) {
        for (int j = 1; j <= N; ++j) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[M][N];
}
```

##### 滚动数组优化

```C++
int longestCommonSubsequence(std::string text1, std::string text2) {
    int text1Len = text1.length();
    int text2Len = text2.length();
    if(text1Len > text2Len) return longestCommonSubsequence(std::move(text2), std::move(text1));

    std::vector<int> dp(text2Len + 1, 0);

    for(int i = 1; i <= text1Len; ++i) {
        int topLeft = dp[0];
        #pragma clang loop unroll_count(4)
        for(int j = 1; j <= text2Len; ++j) {
            int top = dp[j];
            dp[j] = text1[i - 1] == text2[j - 1] 
                ? topLeft + 1 
                : std::max(dp[j - 1], top);
            topLeft = top;
        }
    }
    return dp[text2Len];
}
```

## [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/description/)

> 和 1143 最长公共子序列一样的思路 换汤不换药

### 描述解析

#### 分析

连接的线不能相交，保证顺序就是子序列问题，找到最长公共子序列，自然不会相交，因为子序列保证和我们的数组顺序一样

```C++
int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    int numsLen = nums1.size();
    int numtLen = nums2.size();
    if(numsLen > numtLen) return maxUncrossedLines(nums2, nums1);

    std::vector<int> dp(numtLen + 1, 0);

    for(int i = 1; i <= numsLen; ++i) {
        int topLeft = dp[0];
        #pragma clang loop unroll_count(4)
        for(int j = 1; j <= numtLen; ++j) {
            int top = dp[j];
            dp[j] = nums1[i - 1] == nums2[j - 1] 
                ? topLeft + 1 
                : std::max(dp[j - 1], top);
            topLeft = top;
        }
    }
    return dp[numtLen];
}
```

## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

### 描述解析

#### 分析

```
-2 1 -3 4 -1 2 1 -5 4
        ^      ^
             ^
**延续之前计算的子序列，或者从头开始作为子序列计算**
例如 4 -1 2 我们需要计算 4 -1 2 1，因为当前加上新的数字后，子序列大小不变，延续之前计算的大小
例如 -2 1 原来子序列是-2，当前是1 加上之后是-1 比 1 小 我们应该以1作为子序列重新计算大小   

max (dp[i-1]+nums[i], nums[i])

dp[0] = nums[0]，非零下标都会被覆盖初始化为0即可

dp.back()未必是最大的子序列和，所以实时更新maxlen
```



#### `dp[i]` 含义

以元素nums[i] 为结尾的最大子序列和

### 解题方法

#### 1. 动态规划

```C++
int maxSubArray(vector<int>& nums) {
    int current_max = nums.front();
    int global_max = current_max;
    for(auto it = nums.begin() + 1; it != nums.end(); ++it) {
        current_max = std::max(*it, current_max + *it);
        if (current_max > global_max) global_max = current_max;
    }
    return global_max;
}
```

#### 2. 贪心

```C++
int maxSubArray(const std::vector<int>& nums) {
    int current_sum = 0;
    int max_sum = INT_MIN;
    
    for (int num : nums) {
        current_sum += num;
        if (current_sum > max_sum) max_sum = current_sum;
        
        // 如果当前和为负数，重置窗口（因为负数会拖累后续和）
        if (current_sum < 0) current_sum = 0;
    }
    
    return max_sum;
}
```

#### 3. 前缀和

```C++
int maxSubArray(vector<int>& nums) {
    int curr_pre = 0;      // 当前前缀和
    int min_pre = 0;       // 当前遇到的最小前缀和
    int max_sum = INT_MIN; // 全局最大子数组和
    #pragma clang loop unroll_count(4)
    for (int x : nums) {
        curr_pre += x;   // 更新前缀和
        if (int candidate = curr_pre - min_pre; candidate > max_sum) {
            max_sum = candidate; // 更新最大子数组和
        }
        if (curr_pre < min_pre) min_pre = curr_pre;   // 更新最小前缀和
    }
    return max_sum;
}
```

## 152. 乘积最大子数组

### 描述解析

#### 分析

```
/*

- 当遇到负数时，最小乘积（可能是负数）乘以负数可能变成最大乘积

- 当遇到正数时，最大乘积乘以正数仍然是最大乘积

- 当遇到0时，重新开始计算（通过直接选择nums[i]实现）

*/

与最大子数组和不同，乘积需要考虑正负号的影响：
- 正数 × 正数 = 更大的正数
- 负数 × 负数 = 正数
- 当前的最大乘积可能来自：
  1. 前一个最大乘积 × 当前正数
  2. 前一个最小乘积 × 当前负数（负负得正）
  3. 当前数字本身（重新开始）

因此需要同时维护最大乘积和最小乘积两个状态
```



#### `dp_max[i]` 和 `dp_min[i]` 含义

- `dp_max[i]`: 以元素 `nums[i]` 为结尾的最大乘积子数组
- `dp_min[i]`: 以元素 `nums[i]` 为结尾的最小乘积子数组

### 解题方法

#### 1. 动态规划

##### 标准

```C++
int maxProduct(vector<int>& nums) {
    std::vector<int> dp_max(nums.size());
    std::vector<int> dp_min(nums.size());
    
    dp_max[0] = nums[0];
    dp_min[0] = nums[0];
    int result = nums[0];
    
    for (int i = 1; i <  nums.size(); i++) {
        dp_max[i] = std::max({nums[i], dp_max[i-1] * nums[i], dp_min[i-1] * nums[i]});
        dp_min[i] = std::min({nums[i], dp_max[i-1] * nums[i], dp_min[i-1] * nums[i]});
        result = std::max(result, dp_max[i]);
    }
    
    return result;
}
```

##### 空间优化

```C++
int maxProduct(vector<int>& nums) {
    int max_prod = nums[0];
    int min_prod = nums[0];
    int result = nums[0];
    
    for (int i = 1; i < nums.size(); ++i) {
        // 保存临时值，因为max_prod更新后会影响min_prod的计算
        int temp_max = max_prod;
        int temp_min = min_prod;
        
        // 三种可能：当前数本身、当前数×前一个最大值、当前数×前一个最小值
        max_prod = std::max({nums[i], temp_max * nums[i], temp_min * nums[i]});
        min_prod = std::min({nums[i], temp_max * nums[i], temp_min * nums[i]});
        
        result = std::max(result, max_prod);
    }
    
    return result;
}
```

#### 2. 前后缀扫描法（最优）

对于数组 `[a, b, c, d, e]`：

- **前缀乘积**：`a, a×b, a×b×c, a×b×c×d, a×b×c×d×e`
- **后缀乘积**：`e, e×d, e×d×c, e×d×c×b, e×d×c×b×a`

当遇到负数时，最大最小值会**互换**，前后缀扫描正好覆盖了这两种可能性。

**为什么这个算法有效？**

1. **覆盖所有子数组**：任何子数组 `nums[i..j]` 的乘积要么是某个前缀的一部分，要么是某个后缀的一部分，或者两者的组合。
2. **处理符号变化**：负数会反转最大最小值，前后缀扫描确保我们不会错过因符号变化而产生的新的最大值。
3. **0值处理**：遇到0时重置，相当于以0为边界重新开始寻找最大乘积子数组。

```C++
int maxProduct(vector<int>& nums) {
    int result = nums[0];
    int prefix = 1, suffix = 1;
    
    for (int i = 0; i < nums.size(); ++i) {
        // 如果遇到0就重置乘积
        prefix = (prefix == 0) ? nums[i] : prefix * nums[i];
        suffix = (suffix == 0) ? nums[nums.size()-1-i] : suffix * nums[nums.size()-1-i];
        
        result = std::max({result, prefix, suffix});
    }
    
    return result;
}
```

#### 3. 贪心思想（类似Kadane算法）（其次）

**为什么交换？**

- 负数会反转符号关系

- 当前最小值（很可能是负数）乘以负数可能变成最大值

- 当前最大值（正数）乘以负数可能变成最小值

- **示例**：

  ```
  当前: current_max = 6, current_min = -2
  遇到: nums[i] = -3
  
  不交换的情况：
  6 × (-3) = -18  (变小)
  -2 × (-3) = 6   (变大)
  
  交换后：
  current_max = -2, current_min = 6
  然后：
  current_max = max(-3, -2 × -3) = max(-3, 6) = 6 ✓
  current_min = min(-3, 6 × -3) = min(-3, -18) = -18
  ```

  当 `nums[i] = 0` 时：

  - `current_max * 0 = 0`，与 `nums[i] = 0` 比较，取 `max(0, 0) = 0`
  - `current_min * 0 = 0`，与 `nums[i] = 0` 比较，取 `min(0, 0) = 0`

  **效果**：乘积归零，相当于重新开始计算子数组。

```c++
int maxProduct(vector<int>& nums) {
    int current_max = nums[0];
    int current_min = nums[0];
    int global_max = nums[0];
    
    for (int i = 1; i < nums.size(); ++i) {
        // 如果是负数，交换最大最小值（因为负负得正）
        if (nums[i] < 0) {
            std::swap(current_max, current_min);
        }
        
        // 更新当前最大最小值
        current_max = std::max(nums[i], current_max * nums[i]);
        current_min = std::min(nums[i], current_min * nums[i]);
        
        // 更新全局最大值
        global_max = std::max(global_max, current_max);
    }
    
    return global_max;
}
```



# 编辑距离

## [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/description/)

### 描述解析

#### 分析

```
s是t的子序列，意味着s是t的最长公共子序列
```



#### `dp[i][j]` 含义



### 解题方法

#### 1. 双指针

```C++
bool isSubsequence(string s, string t) {
    int sLen = s.size(), tLen = t.size();
    if (sLen > tLen) return false;

    int ptr1 = 0, ptr2 = 0;
    while (ptr1 < sLen && ptr2 < tLen)
    {
        if (s[ptr1] == t[ptr2]) ++ptr1;
        ++ptr2;
    }
    return ptr1 == sLen;
}
```

#### 2. 动态规划

```C++
bool isSubsequence(string s, string t) {
    const int M = text1.size();
    const int N = text2.size();
    vector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));
    for (int i = 1; i <= M; ++i) {
        for (int j = 1; j <= N; ++j) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = dp[i][j - 1]; // 最长公共子序列中少了max比较取最大
            }
        }
    }
    return dp[M][N];
}

```



#### 3. 后缀自机

```C++
class SuffixAutomaton {
private:
    struct State {
        int len, link;
        std::array<int, 26> next;
        State() : len(0), link(-1) { next.fill(-1); }
    };
    
    std::vector<State> states;
    int last;
    
public:
    SuffixAutomaton() : last(0) {
        states.emplace_back();
        states[0].len = 0;
        states[0].link = -1;
    }
    
    void extend(char c) {
        int curr = states.size();
        states.emplace_back();
        states[curr].len = states[last].len + 1;
        
        int p = last;
        int char_idx = c - 'a';
        
        while (p != -1 && states[p].next[char_idx] == -1) {
            states[p].next[char_idx] = curr;
            p = states[p].link;
        }
        
        if (p == -1) {
            states[curr].link = 0;
        } else {
            int q = states[p].next[char_idx];
            if (states[p].len + 1 == states[q].len) {
                states[curr].link = q;
            } else {
                int clone = states.size();
                states.emplace_back(states[q]);
                states[clone].len = states[p].len + 1;
                
                while (p != -1 && states[p].next[char_idx] == q) {
                    states[p].next[char_idx] = clone;
                    p = states[p].link;
                }
                states[q].link = states[curr].link = clone;
            }
        }
        last = curr;
    }
    
    bool isSubsequence(const std::string& s) {
        int current_state = 0;
        for (char c : s) {
            int char_idx = c - 'a';
            if (states[current_state].next[char_idx] == -1) {
                return false;
            }
            current_state = states[current_state].next[char_idx];
        }
        return true;
    }
};
```

## [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

### 描述解析

#### 分析

```
s删除元素能不能变成t
相等的时候考虑使用s[i - 1]和不使用s[i - 1]
bag
012
bag

bagg
0123
bag
s[3] == t[2]，不考虑 s[3] 相当于删除，仍旧是bag能够判断相等
s[i - 1] == s[j - 1] dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]

不相同就删除它
dp[i][j] = dp[i - 1][j]

dp[i][0] t是空，s删除完成之后能够匹配，初始化为1
dp[0][j] s是空，不能匹配，初始化为0
dp[0][0] 都是空，匹配，初始化为1
行为0
列为1

    b a g
  1 0 0 0
b 1 1 0 0     
a 1 1 1 0     
e 1 1 1 0     
g 1 1 1 1     
g 1 1 1 2  

对于每个i从1到6，计算j的范围：
    j的起始值：std::min(i, tLen)
    j的结束值：std::max(tLen - sLen + i, 1) 下界的剪枝待考证，但本题目有效
具体计算：
    i=1:
        min(1,3)=1
        max(3-6+1,1)=max(-2,1)=1
        j范围：1 to 1
        只更新j=1，减少了对j=2和j-3的判断。
    i=2:
        min(2,3)=2
        max(3-6+2,1)=max(-1,1)=1
        j范围：2 to 1
        更新j=2和j=1，减少了对j=3的判断。
    i=3:
        min(3,3)=3
        max(3-6+3,1)=max(0,1)=1
        j范围：3 to 1
        更新j=3、j=2和j-1，没有减少判断。
    i=4:
        min(4,3)=3
        max(3-6+4,1)=max(1,1)=1
        j范围：3 to 1
        更新j=3、j=2和j-1，没有减少判断。
    i=5:
        min(5,3)=3
        max(3-6+5,1)=max(2,1)=2
        j范围：3 to 2
        更新j=3和j=2，减少了对j=1的判断。
    i=6:
        min(6,3)=3
        max(3-6+6,1)=max(3,1)=3
        j范围：3 to 3
        只更新j=3，减少了对j=2和j-1的判断。
剪枝内容总结
修改后的循环通过j的范围限制，剪枝了以下判断：
    i=1时：剪枝了j=2和j=3的判断。
    i=2时：剪枝了j=3的判断。
    i=5时：剪枝了j=1的判断。
    i=6时：剪枝了j=2和j=1的判断。
总更新次数从18次减少到12次，减少了6次判断
```



#### `dp[i][j]` 含义

t作为列 s作为行

以 i - 1 为结尾的s 有以 j -1 为结尾的 t 的个数

s[0] ~ s[i - j] 中有几个 t[0] ~ t[j - 1]

### 解题方法

#### 1. 动态规划

##### 标准

```C++
int numDistinct(string s, string t) {
    int sLen = s.size(), tLen = t.size();
    if (sLen < tLen) return 0;

    std::vector<std::size_t> v(t.size() + 1, 0);
    v[0] = 1;
    std::vector<std::vector<std::size_t>> dp(s.size() + 1, v);

    for(int i = 1; i <= sLen; ++i) {
        for(int j = 1; j <= tLen; ++j) {
            if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            else dp[i][j] = dp[i - 1][j];
        }
    }
    return dp.back().back();
}
```

##### 扁平化

```C++
int numDistinct(string s, string t) {
    int sLen = s.size(), tLen = t.size();
    if (sLen < tLen) return 0;

    // 使用二维向量更清晰，或者正确计算一维索引
    std::vector<std::size_t> dp((sLen + 1) * (tLen + 1), 0);

    // 初始化：当t为空字符串时，s的任何子序列都包含1个空字符串
    #pragma clang loop unroll_count(8)
    for (int i = 0; i <= sLen; ++i) {
        dp[i * (tLen + 1)] = 1;  // dp[i][0] = 1
    }

    for(int i = 1; i <= sLen; ++i) {
        #pragma clang loop unroll_count(4)
        for(int j = 1; j <= tLen; ++j) {
            // 正确的索引计算：i * 列数 + j
            int idx = i * (tLen + 1) + j;
            int prevIdx1 = (i - 1) * (tLen + 1) + j;      // dp[i-1][j]
            int prevIdx2 = (i - 1) * (tLen + 1) + (j - 1); // dp[i-1][j-1]

            if (s[i - 1] == t[j - 1]) {
                dp[idx] = dp[prevIdx2] + dp[prevIdx1];
            } else {
                dp[idx] = dp[prevIdx1];
            }
        }
    }

    return dp.back();//dp[sLen * (tLen + 1) + tLen];  // dp[sLen][tLen]
}
```

##### 滚动数组

**优化原理分析**

**边界条件解释：**

- `std::min(i, tLen)`: 当前s的前i个字符最多能匹配t的前min(i, tLen)个字符
- `std::max(tLen - sLen + i, 1)`: 确保剩余字符足够完成匹配

**具体例子说明**

假设：

- `s = "rabbbit"` (长度7)
- `t = "rabbit"` (长度6)

**当 i=3 (处理s的前3个字符 "rab") 时：**

**优化循环范围：**

- 上界: `min(3, 6) = 3`
- 下界: `max(6-7+3, 1) = max(2, 1) = 2`
- 循环: `j = 3, 2`

**为什么跳过其他位置：**

- `j=4,5,6`: 不可能匹配，因为s只有3个字符，无法匹配t的4个以上字符
- `j=1`: 虽然可能匹配第一个字符，但我们需要确保剩余字符足够完成整个匹配

**当 i=5 (处理s的前5个字符 "rabbb") 时：**

**优化循环范围：**

- 上界: `min(5, 6) = 5`
- 下界: `max(6-7+5, 1) = max(4, 1) = 4`
- 循环: `j = 5, 4`

**跳过的位置：**

- `j=6`: 需要匹配完整的"rabbit"，但s只剩2个字符，不够
- `j=1,2,3`: 虽然可能部分匹配，但剩余字符不足以完成整个t的匹配

```C++
    int numDistinct(string s, string t) {
        int sLen = s.size(), tLen = t.size();
        if (sLen < tLen) return 0;
        
        // 使用一维数组，大小为 tLen + 1
        std::vector<std::size_t> dp(tLen + 1, 0);
        dp[0] = 1;  // 空字符串是任何字符串的子序列
        
        for (int i = 1; i <= sLen; ++i) {
            // 从后往前遍历，避免覆盖需要的数据
            #pragma clang loop interleave(enable) unroll_count(8)
            // 内层循环从min(i, tLen)到1，减少不必要的计算，max确保剩余字符足够完成匹配
            for (int j = std::min(i, tLen); j >= std::max(tLen - sLen + i, 1); --j) {
                if (s[i - 1] == t[j - 1]) {
                    dp[j] = dp[j] + dp[j - 1];
                }
                // 不相等时，dp[j] 保持不变（相当于二维数组中的 dp[i-1][j]）
            }
        }
        return dp.back();
    }

// 从前往后
int numDistinct(string s, string t) {
    int sLen = s.size(), tLen = t.size();
    if (sLen < tLen) return 0;
    
    std::vector<std::size_t> dp(tLen + 1, 0);
    dp[0] = 1;
    
    for (int i = 1; i <= sLen; ++i) {
        // 保存前一个值作为左上角值
        std::size_t prev = dp[0];  // 相当于 dp[i-1][0]
        
        for (int j = 1; j <= tLen; ++j) {
            std::size_t temp = dp[j];  // 保存当前值，下一轮作为左上角值
            
            if (s[i - 1] == t[j - 1]) {
                dp[j] = prev + dp[j];  // prev 相当于 dp[i-1][j-1]
            }
            // 不相等时 dp[j] 保持不变
            
            prev = temp;  // 更新 prev 为下一轮的左上角值
        }
    }
    
    return dp[tLen];
}
```

## [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

> 1143 . 最长公共子序列变种

### 描述解析

#### 分析

```
删除字符得到相等的区域，相等的区域是最长公共子序列，我们求出最长公共子序列的长度，然后使用
len1 + len2 - 2* 最长公共子序列长度就是我们所求的删除次数

另一种思路
相同删除元素，

if (nums[i - 1] == nums[j - 1]) dp[i][j] = dp[i - 1][j - 1]
else dp[i][j] = min(dp[i - 1][j], dp[i][j] + 1. dp[i - 1][j - 1] + 2)

三个方向（左上、上、左）推到出dp[i][j]，那么第一行第一列需要初始化
第一行、第一列都初始化为操作的次数，1 2 3 4 5 6... iota
dp[0][j] = j
dp[i][0] = i
非这两个下标初始化为什么都可以
```



#### `dp[i][j]` 含义



### 解题方法

#### 1. 动态规划

##### 标准思路（滚动数组优化）

```C++
int minDistance(string word1, string word2) {
    int w1Len = word1.size(), w2Len = word2.size();
    if (w1Len > w2Len) return minDistance(std::move(word2), std::move(word1));

    std::vector<int> dp(w2Len + 1, 0);
    #pragma clang loop unroll_count(8)
    for (int j = 0; j <= w2Len; ++j) dp[j] = j; // 操作第一行初始化为操作次数

    for(int i = 1; i <= word1.size(); ++i) {
        int topLeft = dp[0];
        dp[0] = i; // 更新当前行的第一个元素
        #pragma clang loop unroll_count(4)
        for(int j = 1; j <= word2.size(); ++j) {
            int top = dp[j];
            dp[j] = word1[i - 1] == word2[j - 1]
                ? topLeft
                : std::min({top + 1, dp[j - 1] + 1, topLeft + 2}); 
            // 可以优化为 (top + 1, dp[j - 1] + 1)，因为 dp[i][j - 1] = dp[i - 1][j - 1] + 1，优化之后比最长公共子序列思路快，否则慢
            topLeft = top;
        }
    }
    return dp.back();
}
```



##### 最长公共子序列

```C++
int minDistance(string word1, string word2) {
    int w1Len = word1.size(), w2Len = word2.size();
    if (w1Len > w2Len) return minDistance(std::move(word2), std::move(word1));

    std::vector<int> dp(w2Len + 1, 0);

    for(int i = 1; i <= word1.size(); ++i) {
        int topLeft = dp[0];
        #pragma clang loop unroll_count(4)
        for(int j = 1; j <= word2.size(); ++j) {
            int top = dp[j];
            dp[j] = word1[i - 1] == word2[j - 1]
                ? topLeft + 1
                : std::max(top, dp[j - 1]);
            topLeft = top;
        }
    }
    return w1Len + w2Len - dp.back() - dp.back();
}
```



## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

> 1143 . 两个字符串的删除操作变种

### 描述解析

#### 分析

```
可以增删改，让两个字符串相等

if (nums[i - 1] == nums[j - 1]) dp[i][j] = dp[i - 1][j - 1]
else dp[i][j] = min(dp[i - 1][j], dp[i][j]. dp[i - 1][j - 1]) + 1

三个方向（左上、上、左）推到出dp[i][j]，那么第一行第一列需要初始化
第一行、第一列都初始化为操作的次数，1 2 3 4 5 6... iota
dp[0][j] = j
dp[i][0] = i
非这两个下标初始化为什么都可以

观察规律
不相等取三个方向最小 + 1，相等取左上方，因为当前不需要任何的操作，应该取决于先前的值
删除 左、上
添加逻辑和删除逻辑一样，当前删除得到先前，先前添加得到当前

替换 左上相等状态延续下来 例如 ab  ac ，延续a + 1替换一次就可以得到当前
						   ^   ^
	 r o s
   0 1 2 3
h  1 1 2 3
o  2 2 1 2
r  3 2 2 2
s  4 3 3 2
e  5 
```



#### `dp[i][j]` 含义



### 解题方法

#### 1. 动态规划

##### 标准思路（滚动数组优化）

```C++
int minDistance(string word1, string word2) {
    int w1Len = word1.size(), w2Len = word2.size();
    if (w1Len == 0) return w2Len;
    if (w2Len == 0) return w1Len;
    if (word1 > word2) return minDistance(std::move(word2), std::move(word1));

    std::vector<int> dp(w2Len + 1);
    #pragma clang loop unroll_count(8)
    for(int i = 0; i <= w2Len; ++i) dp[i] = i;

    for(int i = 1; i <= w1Len; ++i) {
        int topLeft = dp[0];
        dp[0] = i;
        #pragma clang loop unroll_count(8)
        for(int j = 1; j <= w2Len; ++j) {
            int top = dp[j];
            if (word1[i - 1] == word2[j - 1]) dp[j] = topLeft;
            else dp[j] = std::min({topLeft, top, dp[j - 1]}) + 1;
            topLeft = top;
        }
    }
    return dp.back();
}
```

## [712.两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/?envType=daily-question&envId=2026-01-10)

### 描述解析

编辑距离换汤不换药

#### 分析

```
原代码解决的是：将 word1 转换成 word2 所需的最少操作数（插入、删除、替换）。新问题要求的是：删除字符使得 s1 和 s2 相等，且删除字符的 ASCII 总和最小。

核心修改点：

    原 DP 数组含义：dp[j] 表示 word1 [0..i-1] 和 word2 [0..j-1] 的最小操作数。
    新 DP 数组含义：dp[j] 表示 s1 [0..i-1] 和 s2 [0..j-1] 达到相等所需删除字符的最小 ASCII 和。
    状态转移修改：
        字符相等时：无需删除，继承左上角值。
        字符不等时：选择 “删 s1 字符”“删 s2 字符”“删两者字符” 中 ASCII 和最小的方案。
```



#### `dp[i][j]` 含义

`dp[j]` 表示 s1 [0..i-1] 和 s2 [0..j-1] 达到相等所需删除字符的最小 ASCII 和。

### 解题方法

#### 1. 动态规划

##### 标准二维

```c++
int minimumDeleteSum(string& s1, string& s2) {
    int m = s1.size(), n = s2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // 初始化第一行和第一列
    for (int i = 1; i <= m; ++i)
        dp[i][0] = dp[i - 1][0] + s1[i - 1];
    for (int j = 1; j <= n; ++j)
        dp[0][j] = dp[0][j - 1] + s2[j - 1];

    // 状态转移
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(
                    dp[i - 1][j] + s1[i - 1],
                    dp[i][j - 1] + s2[j - 1]
                );
            }
        }
    }

    return dp[m][n];
}
```



##### 标准思路（滚动数组优化）

```c++
int minimumDeleteSum(string& s1, string& s2) {
    // 保持原代码的小优化：让短字符串作为s1，减少空间/时间消耗
    if (s1.size() > s2.size()) std::swap(s1, s2);
    int s1Len = s1.size(), s2Len = s2.size();

    // DP数组：dp[j] 表示s1[0..i-1]和s2[0..j-1]的最小ASCII删除和
    std::vector<int> dp;
    dp.reserve(s2Len + 1);

    // 初始化：s1为空时，需要删除s2[0..j-1]所有字符，累加ASCII值
    dp.emplace_back(0); // dp[0] = 0（s2也为空）
    #pragma clang loop unroll_count(8)
    for (int j = 1; j <= s2Len; ++j) {
        dp.emplace_back(dp[j-1] + s2[j-1]);
    }

    // 遍历s1的每个字符
    for (int i = 1; i <= s1Len; ++i) {
        int topLeft = dp[0]; // 保存dp[i-1][j-1]的值
        dp[0] += s1[i-1];    // s2为空时，需要删除s1[0..i-1]所有字符
        #pragma clang loop unroll_count(4)
        // 遍历s2的每个字符
        for (int j = 1; j <= s2Len; ++j) {
            int top = dp[j]; // 保存dp[i-1][j]的值
            if (s1[i-1] == s2[j-1]) {
                // 字符相等，无需删除，继承左上角值
                dp[j] = topLeft;
            } else {
                // 字符不等：选择三种方案中最小的
                // 1. 删s1[i-1]：dp[i-1][j] + s1[i-1]
                // 2. 删s2[j-1]：dp[i][j-1] + s2[j-1]
                // （原编辑距离的替换操作，对应这里删s1[i-1]+删s2[j-1]，已包含在min中）
                dp[j] = min(top + s1[i-1], dp[j-1] + s2[j-1]);
            }
            topLeft = top; // 更新左上角值，供下一个j使用
        }
    }
    return dp.back();
}
```



## [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/description/)

> 见 131. 分割回文串的思路

### 描述解析

#### 分析

```
整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。
当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]⼀定是false。
当s[i]与s[j]相等时，这就复杂⼀些了，有如下三种情况
	情况⼀：下标i 与 j相同，同⼀个字符例如a，当然是回⽂⼦串
	情况⼆：下标i 与 j相差为1，例如aa，也是回⽂⼦串
	情况三：下标：i 与 j相差⼤于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回⽂⼦串就看aba是不是回⽂就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回⽂就看dp[i + 1][j - 1]是否为true。
```



#### `dp[i][j]` 含义

[i, j] 区间子串是回文串



### 解题方法

#### 132. 分割回文串 II （中心扩展法）

```C++
int countSubstrings(std::string s) {
    int str_len = static_cast<int>(s.size());
    int count = 0;

    // 遍历每个可能的中心点
    for (int center = 0; center < str_len; ++center) {
        // 奇数长度回文，以单个字符为中心
        int left = center;
        int right = center;

        #pragma GCC unroll 4
        while (left >= 0 && right < str_len && s[left] == s[right]) {
            ++count;
            --left;
            ++right;
        }

        // 偶数长度回文，以两个相同字符之间的空隙为中心
        left = center;
        right = center + 1;

        #pragma GCC unroll 4
        while (left >= 0 && right < str_len && s[left] == s[right]) {
            ++count;
            --left;
            ++right;
        }
    }

    return count;
}

// or

int countSubstrings(string s) {
    int count = 0;
    for (int i = 0; i < s.length(); i++) {
        // 奇数长度回文
        count += expandAroundCenter(s, i, i);
        // 偶数长度回文
        count += expandAroundCenter(s, i, i + 1);
    }

    return count;
}
int expandAroundCenter(const string& s, int left, int right) {
    int count = 0;
    while (left >= 0 && right < s.length() && s[left] == s[right]) {
        count++;
        left--;
        right++;
    }
    return count;
}


// or
    
int countSubstrings(string s) {
    int count = 0;

    // 遍历所有可能的中心点
    for (int center = 0; center < s.size(); ++center) {
        // 奇数长度回文，以单个字符为中心
        for (int offset = 0; center - offset >= 0 && center + offset < s.size() && s[center - offset] == s[center + offset]; ++offset) {
            ++count;
        }

        // 偶数长度回文，以两个字符之间的空隙为中心
        for (int offset = 1; center - offset + 1 >= 0 && center + offset < s.size() && s[center - offset + 1] == s[center + offset]; ++offset) {
            ++count;
        }
    }

    return count;
}
```



#### 131. 分割回文串（回溯）

```C++
int countSubstrings(string s) {
    int count{0};
    for (auto start = s.begin(); start != s.end(); ++start) {
        backtrack(s, count, start);
    }
    return count;
}

void backtrack(const auto& s, int& count, auto start) {
    if (start == s.end()) return;

    for (auto it = start; it != s.end(); ++it) {
        if (isPal(start, std::next(it))) {
            ++count;
        }
    }
}

template<typename RanIter>
bool isPal(RanIter start, RanIter end) {
    for(--end; start < end; ++start, --end) {
        if (*start != *end) return false;
    }
    return true;
}
```

#### 131 132 动态规划

##### 标准

```C++
int countSubstrings(std::string s) {
    int str_len = static_cast<int>(s.size());
    if (str_len == 0) return 0;

    std::vector<std::vector<uint8_t>> is_palindrome(str_len, std::vector<uint8_t>(str_len, 0));
    int count = 0;

    // 初始化长度为1的回文
    #pragma GCC unroll 8
    for (int i = 0; i < str_len; ++i) {
        is_palindrome[i][i] = 1;
        ++count;
    }

    // 初始化长度为2的回文
    #pragma GCC unroll 8
    for (int i = 0; i < str_len - 1; ++i) {
        if (s[i] == s[i + 1]) {
            is_palindrome[i][i + 1] = 1;
            ++count;
        }
    }

    // 处理长度>=3的回文
    for (int length = 3; length <= str_len; ++length) {
        #pragma GCC unroll 4
        for (int start = 0; start <= str_len - length; ++start) {
            int end = start + length - 1;

            if (s[start] == s[end] && is_palindrome[start + 1][end - 1]) {
                is_palindrome[start][end] = 1;
                ++count;
            }
        }
    }

    return count;
}

//or
void func {
    for (int i = s.size() - 1; i >= 0; --i) { // 注意遍历顺序
        for (int j = i; j < s.size(); ++j) {
            if (s[i] == s[j]) {
                 if (j - i <= 1) { // 情况⼀ 和 情况⼆
                    result++;
                    dp[i][j] = true;
                 } else if (dp[i + 1][j - 1]) { // 情况三
                    result++;
                    dp[i][j] = true;
                 }
             }
         }
    }
}
```

##### 扁平化数组

```C++
int countSubstrings(std::string s) {
    int str_len = static_cast<int>(s.size());
    int count = 0;

    std::vector<uint8_t> dp_prev(str_len, 0);
    std::vector<uint8_t> dp_curr(str_len, 0);

    for (int start = str_len - 1; start >= 0; --start) {
        #pragma GCC unroll 8
        for (int end = start; end < str_len; ++end) {
            if (s[start] == s[end]) {
                // 长度1、2的情况，或者内部是回文
                if (end - start <= 2 || dp_prev[end - 1]) {
                    dp_curr[end] = 1;
                    ++count;
                } else {
                    dp_curr[end] = 0;
                }
            }
            else { 
                dp_curr[end] = 0;
            }
        }
        dp_prev = dp_curr;
    }

    return count;
}
```

##### 滚动数组

```C++
    int countSubstrings(std::string s) {
        std::vector<uint8_t> dp(s.size(), 0);

        int count = 0;
        for(int i = s.size() - 1; i >= 0; --i) {
            int bottomLeft = false;
            #pragma GCC unroll 8
            for(int j = i; j < s.size(); ++j) {
                int bottom = dp[j];
                if(s[i] == s[j]) {
                    if(j - i <= 1 || bottomLeft) { // 长度1、2的情况，或者内部dp[i + 1][j - 1]是回文 
                        ++count;
                        dp[j] = true;
                    }
                    else dp[j] = false;
                } 
                else dp[j] = false;
                bottomLeft = bottom;
            }
        }
        return count;
    }
```



#### 5. 最长回文子串（manacher算法）

```C++
int countSubstrings(std::string s) {
    size_t str_len = s.length();
    if (str_len < 2) return str_len;

    // 构建Manacher字符串，添加特殊字符处理边界
    std::string mana_str(2 * s.length() + 3, '#');
    mana_str[0] = '^';
    mana_str.back() = '$';
    #pragma GCC unroll 8
    for (size_t i = 0; i < s.length(); ++i) {
        mana_str[(i + 1) << 1] = s[i];
    }

    std::size_t mana_len = mana_str.length();
    std::vector<size_t> P(mana_len, 0);

    size_t center = 0, right_boundary = 0;
    size_t total_palindromes = 0;

    // 使用Manacher算法计算每个位置的回文半径
    for (size_t i = 1; i < mana_len - 1; ++i) {
        // 利用对称性快速初始化
        if (i < right_boundary) {
            P[i] = std::min(right_boundary - i, P[2 * center - i]);
        }

        // 中心扩展
        #pragma GCC unroll 4
        while (mana_str[i + P[i] + 1] == mana_str[i - P[i] - 1]) {
            ++P[i];
        }

        // 更新中心和右边界
        if (i + P[i] > right_boundary) {
            center = i;
            right_boundary = i + P[i];
        }

        // 统计回文子串数量
        // P[i] 表示以当前位置为中心的最长回文半径
        // 回文子串数量就是半径值（因为每个半径对应一个回文串）
        total_palindromes += (P[i] + 1) / 2;
    }

    return total_palindromes;
}
```

## [132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

### 描述解析

#### 分析

```
为什么大小是 size + 1：我们需要表示从空字符串到整个字符串的所有情况
为什么初始化 dp[0] = -1： 空字符串不需要任何分割

dp[left] + 1 的含义：

    dp[left] 是子串 s[0..left-1] 的最小分割次数

    当我们发现 s[left..right] 是回文时，可以在 left 位置之前进行分割

    +1 表示这次分割操作

dp[right + 1] 的含义：

    表示子串 s[0..right] 的最小分割次数

    我们正在尝试用更小的值来更新它
```

#### `dp[i]` 含义

`dp[i]` 表示字符串前 `i` 个字符（即 `s[0..i-1]`）的最小分割次数

### 解题方法

#### 动态规划结合中心扩展法

```C++
int minCut(string s) {
    int size = s.size();
    vector<int> dp(size + 1, INT_MAX);
    dp[0] = -1;

    for (int center = 0; center < size; ++center) {
        #pragma GCC unroll 4
        for (int left = center, right = center; left >= 0 && right < size && s[left] == s[right]; --left, ++right) {
            if (int val = dp[left] + 1; val < dp[right + 1]) dp[right + 1] = val;
        }
        #pragma GCC unroll 4
        for (int left = center, right = center + 1; left >= 0 && right < size && s[left] == s[right]; --left, ++right) {
            if (int val = dp[left] + 1; val < dp[right + 1]) dp[right + 1] = val;
        }
    }

    return dp.back();
}
```



## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

### 描述解析

#### 分析

> 见 647 回文子串

遇见回文子串的时候，我们计算回文子串的长度，实时更新，最后通过最长回文子串的起始位置和长度得到结果

```

        b a b a d
     b  1 . 3 . .
     a  . 2 . 3 .
     b  1 . 2 . .   
     a  . 1 . 1 .
     d  . . . . 1


        c b b d
    c   1 . . .
    b   . 1 2 .
    b   . 1 1 .
    d   . . . 1
```

#### `dp[i][j]` 含义

[i, j] 区间子串是回文串

### 解题方法

#### 1. 动态规划

##### 滚动数组差

```C++
string longestPalindrome(string s) {
    struct StringView { 
        int begin, end; 
        int length() const { return end - begin; }
    };

    if (s.empty()) return "";

    std::vector<StringView> dp(s.size());

    // 初始化：每个单个字符都是回文
    for(int i = 0; i < s.size(); ++i) {
        dp[i] = {i, i + 1};
    }

    StringView longest = dp[0]; // 记录最长回文子串

    for(int i = s.size() - 2; i >= 0; --i) { // 从倒数第二个开始
        StringView bottomLeft = dp[i + 1]; // 保存dp[i+1][j-1]
        #pragma clang loop interleave(enable) unroll_count(4)
        for(int j = i + 1; j < s.size(); ++j) {
            StringView currentBottom = dp[j]; // 保存当前dp[j]，即dp[i+1][j]
            StringView currentLeft = (j > i + 1) ? dp[j - 1] : StringView{j, j}; // dp[i][j-1]

            if(s[i] == s[j]) {
                // 如果两端字符相等，检查内部子串是否是回文
                if(j - i <= 2 || (bottomLeft.begin == i + 1 && bottomLeft.end == j)) {
                    dp[j] = {i, j + 1};
                } else {
                    // 内部不是回文，取左右子串中较长的
                    if(currentLeft.length() > currentBottom.length()) {
                        dp[j] = currentLeft;
                    } else {
                        dp[j] = currentBottom;
                    }
                }
            } else {
                // 两端字符不相等，取左右子串中较长的
                if(currentLeft.length() > currentBottom.length()) {
                    dp[j] = currentLeft;
                } else {
                    dp[j] = currentBottom;
                }
            }

            // 更新最长回文子串
            if(dp[j].length() > longest.length()) {
                longest = dp[j];
            }

            bottomLeft = currentBottom; // 更新bottomLeft为当前行的dp[j-1]
        }
    }

    return s.substr(longest.begin, longest.length());
}
```



##### 滚动数组优

```C++
string longestPalindrome(string s) {
    std::vector<uint8_t> dp(s.size(), 0);
    int maxLen{ 1 }, begin{ 0 };
    for(int i = s.size() - 1; i >= 0; --i) {
        uint8_t bottomLeft = dp[0];
        #pragma clang loop unroll_count(8)
        for(int j = i; j < s.size(); ++j) {
            uint8_t bottom = dp[j];
            if (s[i] == s[j]) {
                if (j - i <= 1 || bottomLeft) {
                    dp[j] = 1;
                    if (int currLen = j - i + 1; currLen > maxLen) {
                        maxLen = currLen;
                        begin = i;
                    } 
                }
                else dp[j] = 0;
            } 
            else dp[j] = 0;
            bottomLeft = bottom;
        }
    }

    return s.substr(begin, maxLen);
}
```

#### 2. 中心扩展法

```C++
string longestPalindrome(string s) {
    int sLen = s.size();

    int longestStart{ 0 }, longestLen{ 1 };
    for(int center = 0; center < sLen; ++center) {
        int left = center, right = center;
        #pragma GCC unroll 8
        while(left >= 0 && right < sLen && s[left] == s[right++]) { //or right
            if (int currLen = right - left; currLen > longestLen) { //or right - left + 1
                longestStart = left, longestLen = currLen;
            }
            --left;
            //or ++right;
        }

        left = center, right = center + 1;
        #pragma GCC unroll 8
        while(left >= 0 && right < sLen && s[left] == s[right++]) {
            if (int currLen = right - left; currLen > longestLen) {
                longestStart = left, longestLen = currLen;
            }
            --left;
        }
    }
    return s.substr(longestStart, longestLen);
}
```

#### 3. manacher算法

## Manacher算法解析

**算法设计思路**

Manacher算法通过**预处理字符串**和**利用回文对称性**来高效查找最长回文子串，将时间复杂度从O(n²)优化到O(n)。

**为什么可行**

1. **预处理消除奇偶差异**：通过插入特殊字符`#`，将奇偶长度回文统一处理
2. **利用回文对称性**：利用已知回文的对称信息避免重复计算
3. **动态维护边界**：实时更新当前最右回文边界，提高效率

**核心变量含义**

`P[i]` - 回文半径数组

- **含义**：以位置`i`为中心的最长回文半径（包括中心）
- **示例**：对于字符串`"#a#b#a#"`，在`b`位置的`P[i] = 3`

`C` - 当前中心点

- **含义**：当前已知的最右回文边界的中心位置
- **作用**：作为对称中心，用于快速初始化`P[i]`

`R` - 当前右边界

- **含义**：当前已知的最右回文边界位置
- **作用**：确定可以直接利用对称性的范围

```C++
string longestPalindrome(string s) {
    if (s.length() < 2) return s;
    
    // 构建Manacher字符串，添加特殊字符处理边界
    string mana_str(2 * s.length() + 3, '#');
    mana_str[0] = '^';  // 开始标记
    mana_str.back() = '$'; // 结束标记
    for (size_t i = 0; i < s.length(); ++i) {
        mana_str[(i + 1) << 1] = s[i]; // 原字符串字符放在偶数位置
    }
    
    vector<size_t> P(mana_str.length(), 0); // 回文半径数组
    size_t C{ 0 }, R{ 0 }; // 当前中心点和右边界
    size_t maxLen{ 0 }, centerIndex{ 0 }; // 最大回文半径和对应中心
    
    for (size_t i = 1; i < mana_str.length() - 1; ++i) {
        // 利用对称性初始化回文半径
        if (i <= R) P[i] = std::min(R - i, P[(C << 1) - i]);
        
        // 中心扩展
        while (mana_str[i - P[i] - 1] == mana_str[i + P[i] + 1]) ++P[i];
        
        // 更新右边界和中心点
        if (P[i] + i > R) {
            R = P[i] + i;
            C = i;
        }
        
        // 更新最大回文信息
        if (P[i] > maxLen) {
            maxLen = P[i];
            centerIndex = i;
        }
    }
    
    return s.substr((centerIndex - maxLen) >> 1, maxLen);
}
```



## [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

### 描述解析

#### 分析

```
- ------ -
i        j
如果 s[i] == s[j]，相等看子串，然后长度+2
dp[i][j] = dp[i + 1][j - 1] + 2

不相等
dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) 取两个最大值

为什么可行，因为拆分为子问题是一个子序列，是一个回文串，不断的增大，我们只不过是缩减看而已

所以初始化的时候应该将**对角线**的部分初始化为1，代表最小的是一个子串是一个回文是一个子序列
区域初始化为0即可
dp[i][i] = 1;，这样内层for需要从 j = i + 1开始
否则不初始化，则是从 j = i开始，但循环内部需要判断 i == j情况

根据递推公式，得到遍历方向，从下往上从左往右

return dp.front().back();
```



#### `dp[i][j]` 含义

[i, j] 区间的回文子序列长度为

### 解题方法

#### 1. 动态规划

##### 标准

```C++
    int longestPalindromeSubseq(string s) {
        int sLen = s.size();
        std::vector<std::vector<int>> dp(sLen, std::vector<int>(sLen, 0));

        for(int i = 0; i < sLen; ++i) dp[i][i] = 1;

        for(int i = sLen - 1; i >= 0; --i) {
            for(int j = i + 1; j < sLen; ++j) {
                if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2;
                else dp[i][j] = std::max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        return dp.front().back();
    }
```

##### 扁平化

```C++
    int longestPalindromeSubseq(string s) {
        int sLen = s.size();
        std::vector<int> dp(sLen * sLen, 0);

        for(int i = 0; i < sLen; ++i) dp[i* sLen + i] = 1;

        for(int i = sLen - 1; i >= 0; --i) {
            for(int j = i + 1; j < sLen; ++j) {
                if (s[i] == s[j]) dp[i * sLen + j] = dp[(i + 1) * sLen + j - 1] + 2;
                else dp[i * sLen + j] = std::max(dp[(i + 1) * sLen + j], dp[i * sLen + j - 1]);
            }
        }
        return dp[sLen - 1];
    }
```

##### 双数组

```C++
    int longestPalindromeSubseq(string s) {
        std::vector<int> dp(s.size(), 0), prev(s.size(), 0);
        
        for (int i = s.size() - 1; i >= 0; --i) {
            dp[i] = 1;  // 单个字符的最长回文子序列长度为1
            for (int j = i + 1; j < s.size(); ++j) {
                if (s[i] == s[j]) {
                    dp[j] = prev[j - 1] + 2;
                } else {
                    dp[j] = max(prev[j], dp[j - 1]);
                }
            }
            prev = dp;  // 保存上一行的结果
        }
        
        return prev.back();
    }
```

##### 滚动数组

```C++
    int longestPalindromeSubseq(string s) {
        std::vector<int> dp(s.size(), 0);
        
        for (int i = s.size() - 1; i >= 0; --i) {
            int bottomLeft = 0;  // 保存 dp[i+1][j-1] 的值
            dp[i] = 1;  // 对角线
            #pragma clang loop unroll_count(4)
            for (int j = i + 1; j < s.size(); ++j) {
                int bottom = dp[j];
                if (s[i] == s[j]) {
                    dp[j] = bottomLeft + 2;
                } else {
                    if(dp[j] < dp[j - 1]) dp[j] = dp[j - 1];
                }
                bottomLeft = bottom;
            }
        }
        
        return dp.back();
    }
```

