```C++
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        std::vector<int> inDegree(numCourses, 0);
        std::vector<int> outDegree(numCourses + 1, 0);
        #pragma GCC unroll 8
        for (auto& pre : prerequisites) {
            ++inDegree[pre[0]];
            ++outDegree[pre[1] + 1];
        }
        #pragma GCC unroll 8
        for(int i = 1; i <= numCourses; ++i) {
            outDegree[i] += outDegree[i - 1];
        }

        std::vector<int> edges(prerequisites.size());
        std::vector<int> currentPos = outDegree;
        #pragma GCC unroll 8
        for (auto& pre : prerequisites) {
            edges[currentPos[pre[1]]++] = pre[0];
        }

        std::vector<int>& queue = currentPos;
        int left = 0, right = 0;
        #pragma GCC unroll 8
        for (int i = 0; i < inDegree.size(); ++i) {
            if (inDegree[i] == 0) queue[right++] = i;
        }
        queue.pop_back();
        std::vector<int> result; result.reserve(numCourses);

        while(left < right) {
            int u = queue[left++];
            result.emplace_back(u);

            for (int i = outDegree[u]; i < outDegree[u + 1]; ++i) {
                int v = edges[i];
                if (--inDegree[v] == 0) queue[right++] = v;
            }
        }
        return result.size() == numCourses ? result : std::vector<int>{};
    }
};
```



### 代码核心逻辑总览

这是一道**课程表 II** 问题（拓扑排序），要求返回合法的课程学习顺序（若存在环则返回空）。代码采用 **Kahn算法（基于入度的拓扑排序）**，并通过**邻接表的数组压缩存储（静态邻接表）** 优化性能，核心是用数组模拟邻接表，避免动态容器的开销。

### 关键概念铺垫
拓扑排序的核心思路：
1. 统计每个节点（课程）的**入度**（前置课程数）；
2. 用队列维护入度为0的节点（无前置课程，可直接学习）；
3. 取出入度为0的节点，遍历其所有邻接节点（后续课程），将邻接节点入度减1；若邻接节点入度变为0，加入队列；
4. 最终若结果包含所有课程，说明无环，返回结果；否则返回空。

### 逐段拆解代码逻辑

#### 1. 入度/出度数组初始化
```cpp
std::vector<int> inDegree(numCourses, 0); // 每个课程的入度（前置课程数）
std::vector<int> outDegree(numCourses + 1, 0); // 用于构建邻接表的"偏移量"数组
for (auto& pre : prerequisites) {
    ++inDegree[pre[0]]; // pre[1]是pre[0]的前置课 → pre[0]入度+1
    ++outDegree[pre[1] + 1]; // 先统计每个节点的出边数量（关键！）
}
```
- `inDegree[i]`：课程`i`需要的前置课程数（入度）。
- `outDegree` 初始用途：`outDegree[pre[1]+1]++` 统计**课程pre[1]的出边数量**（即以pre[1]为前置课的后续课程数）。  
  例如：若`prerequisites = [[1,0],[2,0],[3,1]]`，则：
  - `pre[1]=0` 出现2次 → `outDegree[0+1] +=2`；
  - `pre[1]=1` 出现1次 → `outDegree[1+1] +=1`；
  - 最终`outDegree`初始值为 `[0,2,1,0,...]`（长度numCourses+1）。

#### 2. outDegree的前缀和计算（核心！）
```cpp
for(int i = 1; i <= numCourses; ++i) {
    outDegree[i] += outDegree[i - 1];
}
```
- **目的**：将`outDegree`从「出边数量统计数组」转换为「邻接表的起始偏移量数组」。
- 前缀和后，`outDegree[u]` 表示：**课程u的所有出边在edges数组中的起始下标**；`outDegree[u+1]` 表示课程u的出边在edges数组中的**结束下标+1**。
- 举例（接上文）：
  初始`outDegree = [0,2,1,0]` → 前缀和后：
  - `outDegree[1] = outDegree[1] + outDegree[0] = 2+0=2`；
  - `outDegree[2] = outDegree[2] + outDegree[1] =1+2=3`；
  - `outDegree[3] =0+3=3`；
  最终`outDegree = [0,2,3,3,...]`。
  含义：
  - 课程0的出边起始下标是`outDegree[0]=0`，结束下标是`outDegree[1]-1=1`（共2条边）；
  - 课程1的出边起始下标是`outDegree[1]=2`，结束下标是`outDegree[2]-1=2`（共1条边）；
  - 课程2的出边起始下标是`outDegree[2]=3`，结束下标是`outDegree[3]-1=2`（无出边）。

#### 3. 构建edges数组（静态邻接表）
```cpp
std::vector<int> edges(prerequisites.size()); // 存储所有出边的目标节点
std::vector<int> currentPos = outDegree; // 临时数组，记录每个节点的出边在edges中的「当前填充下标」
for (auto& pre : prerequisites) {
    edges[currentPos[pre[1]]++] = pre[0]; // 填充pre[1]的出边目标节点pre[0]
}
```
- `edges`数组的含义：
  - 下标：由`outDegree`的前缀和决定（对应节点出边的位置）；
  - 值：当前节点的**邻接节点（后续课程）**。
- `currentPos` 初始等于前缀和后的`outDegree`，作用是「指针」：每填充一个出边，指针后移一位。
- 举例（接上文）：
  `prerequisites = [[1,0],[2,0],[3,1]]`：
  1. 处理`[1,0]`：`pre[1]=0` → `currentPos[0]=0` → `edges[0]=1` → `currentPos[0]++`（变为1）；
  2. 处理`[2,0]`：`pre[1]=0` → `currentPos[0]=1` → `edges[1]=2` → `currentPos[0]++`（变为2）；
  3. 处理`[3,1]`：`pre[1]=1` → `currentPos[1]=2` → `edges[2]=3` → `currentPos[1]++`（变为3）；
  最终`edges = [1,2,3]`。
  对应关系：
  - 课程0的出边存在`edges[0]`和`edges[1]` → 后续课程是1、2；
  - 课程1的出边存在`edges[2]` → 后续课程是3；

#### 4. 拓扑排序核心（Kahn算法）
```cpp
// 复用currentPos作为队列（节省空间）
std::vector<int>& queue = currentPos;
int left = 0, right = 0;
// 初始化队列：入度为0的课程入队
for (int i = 0; i < inDegree.size(); ++i) {
    if (inDegree[i] == 0) queue[right++] = i;
}
queue.pop_back(); // 清理冗余（currentPos初始长度numCourses+1，pop_back不影响）
std::vector<int> result; result.reserve(numCourses);

// 处理队列中的节点
while(left < right) {
    int u = queue[left++]; // 取出队首节点u（当前可学习的课程）
    result.emplace_back(u); // 加入结果

    // 遍历u的所有出边（后续课程v）
    for (int i = outDegree[u]; i < outDegree[u + 1]; ++i) {
        int v = edges[i]; // v是u的后续课程
        if (--inDegree[v] == 0) queue[right++] = v; // v的前置课完成，入队
    }
}
// 结果长度等于课程数 → 无环，返回；否则返回空
return result.size() == numCourses ? result : std::vector<int>{};
```

### 关键问题解答
#### 1. 为什么要对outDegree做前缀和？
- 本质是**构建静态邻接表的偏移量**：  
  普通邻接表用`vector<vector<int>> adj`，`adj[u]`存储u的所有邻接节点，但动态vector有扩容/内存开销。  
  代码用「一维数组edges + 偏移量数组outDegree」模拟邻接表：
  - 前缀和前：`outDegree[u+1]` 统计u的出边数量；
  - 前缀和后：`outDegree[u]` 是u的出边在edges中的起始位置，`outDegree[u+1]`是结束位置，通过区间`[outDegree[u], outDegree[u+1})`可精准遍历u的所有出边。
- 优势：数组访问比动态vector更快，且内存连续，缓存友好（代码中还加了`#pragma GCC unroll 8`循环展开进一步优化）。

#### 2. edges的下标和值分别是什么意思？
- **下标**：由`outDegree`的前缀和决定，对应「某个节点的出边位置」（是静态邻接表的位置索引）；
- **值**：该位置对应的「后续课程编号」（即当前节点的邻接节点）。  
  例如`edges[0]=1`：表示下标0的位置存储的是「课程0的第一个后续课程1」。

#### 3. 为什么循环写`for (int i = outDegree[u]; i < outDegree[u + 1]; ++i)`？
- `outDegree[u]`：课程u的出边在edges数组中的**起始下标**；
- `outDegree[u+1]`：课程u的出边在edges数组中的**结束下标+1**；
- 区间`[outDegree[u], outDegree[u+1})` 恰好覆盖u的所有出边在edges中的位置，遍历这个区间就能拿到u的所有后续课程v（`edges[i]`）。
- 举例（接上文）：
  课程0的`outDegree[0]=0`，`outDegree[1]=2` → 循环`i=0,1`，遍历`edges[0]=1`和`edges[1]=2`，即课程0的所有后续课程。

### 总结
代码的核心是**用静态数组模拟邻接表**优化Kahn算法：
1. `inDegree`：统计每个课程的前置课数量；
2. `outDegree`：先统计出边数，再做前缀和转为「邻接表偏移量」；
3. `edges`：存储所有出边的目标节点，通过`outDegree`的区间定位每个节点的出边；
4. 队列处理入度为0的节点，遍历其出边并更新后续节点的入度，最终判断是否无环。

这种写法牺牲了一点可读性，但大幅提升了性能（尤其在数据量大时），是算法竞赛/高性能场景中常见的优化手段。