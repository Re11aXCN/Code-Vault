# radix_sort(基数、桶/基数排序)流程描述

我们只关注非OMP并行的部分，因此忽略所有与OMP相关的代码。
基数排序的逻辑流程如下：

1. 模板参数说明：

   - _NumericType: 数值类型（必须是算术类型，且不能是bool）
   - _Bucket_size: 桶的大小，只能是256或65536
   - _MaxCapacityType: 用于计数的无符号整数类型（如uint32_t, size_t等）

2. 静态断言确保_MaxCapacityType是无符号整数类型。

3. 如果数组大小小于等于1，直接返回。

4. 计算需要的趟数（_Passes）：

   - 如果桶大小为256，则每趟处理8位，趟数为sizeof(_NumericType)
   - 如果桶大小为65536，则每趟处理16位，趟数为(sizeof(_NumericType)+1)/2

5. 定义掩码_Mask，用于取当前处理的位。

6. 声明并初始化桶计数数组_Bucket_count，大小为_Bucket_size。

7. 声明一个缓冲区_Buffer，用于存放中间排序结果。

8. 使用两个指针_Start和_End，分别指向当前趟的输入数组和输出数组。初始时，_Start指向原数组，_End指向缓冲区。

9. 进行_Passes趟排序：
   a. 计数阶段：
   \- 将_Bucket_count数组清零。
   \- 遍历当前输入数组_Start，对每个元素，根据当前趟_Pass，提取出对应的位（字节或16位），并计数到对应的桶中。
   注意：对于有符号整数，最高位（符号位）需要特殊处理，在最后一趟时，通过异或操作调整顺序，使得负数排在正数前面（因为负数的最高位是1，而正数的最高位是0，通过异或将符号位取反，从而使得负数在排序时被当作大的正数，从而排在正数之后？实际上，基数排序通常对无符号数进行排序，这里通过调整使得有符号数也能正确排序）。

   b. 计算前缀和（ exclusive scan）：
   \- 使用_Scanned数组，其中_Scanned[0] = 0，然后对于每个桶，_Scanned[i] = _Scanned[i-1] + _Bucket_count[i-1]。
   \- 这样，_Scanned[i]就表示第i个桶在输出数组中的起始位置。

   c. 重排阶段：
   \- 遍历当前输入数组_Start，根据当前趟提取的位，查找其在_Scanned中的位置，并将元素放入输出数组_End的对应位置，同时递增_Scanned中对应桶的索引。

   d. 交换_Start和_End，这样下一趟的输入就是上一趟的输出。

10. 如果最终排序结果在缓冲区中（即_Start指向缓冲区），则将其复制回原数组。

注意：对于有符号数的处理，在最后一趟时，对提取的位进行了异或操作（异或_Mask的一半，即对于8位桶，异或128；对于16位桶，异或32768），这样做的目的是将符号位取反，从而使得有符号数能够按照从负到正的正确顺序排列。

现在，我们来看有符号数的处理：
\- 首先，将数值转换为无符号类型（按位解释），然后提取当前趟的位。
\-  如果是最后一趟，则对提取的位进行异或操作（异或_Mask的一半）。这是因为有符号数的最高位是符号位，而基数排序通常按无符号数排序，所以负数会被当作大的正数。为了纠正这个顺序，我们在最后一趟将符号位取反，这样负数的最高位就变成了0，正数的最高位变成了1，从而使得负数排在正数之前（因为0比1小）。但是，注意这里异或的是_Mask的一半，即对于8位，异或0x80（128），对于16位，异或0x8000（32768）。这样，实际上是将符号位取反，从而改变了比较的顺序。

然而，值得注意的是，有符号数的基数排序通常有两种方法：
方法1：将负数转换为正数（通过减去最小值，或者通过位运算调整），然后排序，再转换回去。
方法2：在最后一趟排序时，对符号位进行特殊处理，使得负数排在正数之前（因为负数的符号位为1，正数为0，所以如果按无符号数排序，负数会排在正数之后，但实际负数应该比正数小）。所以，我们需要在最后一趟将负数的符号位取反，这样负数就会排在正数之前。

但是，这里代码中的做法是：在最后一趟，将提取的位异上_Mask的一半（即符号位），这样做的效果是：
对于有符号数，我们按照补码表示，最高位是符号位。在最后一趟，我们处理最高位（符号位）时，将符号位取反，这样：
\- 负数（原符号位为1）变成0，正数（原符号位为0）变成1。
然后，我们按照无符号数排序，0排在1的前面，所以负数排在正数前面。但是，注意负数和负数之间、正数和正数之间的相对顺序在最后一趟之前已经排好，所以这样调整后，整个数组就变成从小到大（负数->0->正数）了。

但是，注意：基数排序是稳定排序，所以之前趟的排序结果会被保留。因此，整个排序是正确的。

现在，我们来看无符号数的处理：直接提取位，不需要特殊处理。

最后，在最长连续序列的函数中，我们使用基数排序对数组进行排序，然后遍历排序后的数组，计算最长连续序列的长度。

注意：在遍历时，我们跳过了重复的元素（当nums[i] == nums[i-1]时，我们不做任何操作，因为重复元素不影响连续序列，但也不增加长度）。

这就是整个基数排序的逻辑流程。

# 示例数据执行流程

用一个较长且经典的示例详细描述基数排序的每趟结果。让我们使用有符号16位整数进行排序，这样可以看到多趟处理的效果。

## 示例数据
让我们排序以下有符号16位整数数组：
```
[32767, -32768, 100, -100, 0, 255, -255, 500, -500, 1000, -1000]
```

## 基数排序参数
- **数据类型**: `int16_t` (16位有符号整数)
- **桶大小**: 256 (每趟处理8位)
- **趟数**: 2趟 (16位 ÷ 8位/趟)

## 第一趟排序 (处理低8位)

### 步骤1: 转换为无符号表示
```
原始值       无符号表示(补码)   二进制表示
32767  ->   32767         0111111111111111
-32768 ->   32768         1000000000000000
100    ->   100           0000000001100100
-100   ->   65436         1111111110011100
0      ->   0             0000000000000000
255    ->   255           0000000011111111
-255   ->   65281         1111111100000001
500    ->   500           0000000111110100
-500   ->   65036         1111111000001100
1000   ->   1000          0000001111101000
-1000  ->   64536         1111110000011000
```

### 步骤2: 提取低8位 (第0-7位)
```
值       无符号值   低8位(索引)  调整后索引(第一趟不调整)
32767    32767     255          255
-32768   32768     0            0
100      100       100          100
-100     65436     156          156
0        0         0            0
255      255       255          255
-255     65281     1            1
500      500       244          244
-500     65036     12           12
1000     1000      232          232
-1000    64536     24           24
```

### 步骤3: 计数和重排
**桶计数结果:**
```
桶0: 2个 (-32768, 0)
桶1: 1个 (-255)
桶12: 1个 (-500)
桶24: 1个 (-1000)
桶100: 1个 (100)
桶156: 1个 (-100)
桶232: 1个 (1000)
桶244: 1个 (500)
桶255: 2个 (32767, 255)
```

**第一趟排序后结果:**
```
[-32768, 0, -255, -500, -1000, 100, -100, 1000, 500, 32767, 255]
```

## 第二趟排序 (处理高8位 + 符号位修正)

### 步骤1: 提取高8位 (第8-15位)
```
当前值     无符号值   高8位(索引)  调整后索引(异或128)
-32768    32768     128         128 ^ 128 = 0
0         0         0           0 ^ 128 = 128
-255      65281     255         255 ^ 128 = 127
-500      65036     254         254 ^ 128 = 126
-1000     64536     252         252 ^ 128 = 124
100       100       0           0 ^ 128 = 128
-100      65436     255         255 ^ 128 = 127
1000      1000      3           3 ^ 128 = 131
500       500       1           1 ^ 128 = 129
32767     32767     127         127 ^ 128 = 255
255       255       0           0 ^ 128 = 128
```

### 步骤2: 计数和重排
**桶计数结果:**
```
桶0: 1个 (-32768)      // 负数最小
桶124: 1个 (-1000)     // 负数
桶126: 1个 (-500)      // 负数
桶127: 2个 (-255, -100) // 负数
桶128: 3个 (0, 100, 255) // 正数
桶129: 1个 (500)       // 正数
桶131: 1个 (1000)      // 正数
桶255: 1个 (32767)     // 正数最大
```

**第二趟排序后最终结果:**
```
[-32768, -1000, -500, -255, -100, 0, 100, 255, 500, 1000, 32767]
```

## 排序过程可视化

### 初始数组:
```
索引:  0     1     2     3     4     5     6     7     8     9     10
值:  32767 -32768 100   -100  0     255   -255  500   -500  1000  -1000
```

### 第一趟后 (按低8位排序):
```
索引:  0     1     2     3     4     5     6     7     8     9     10
值:  -32768 0     -255  -500  -1000 100   -100  1000  500   32767 255
```

### 第二趟后 (按高8位+符号位排序):
```
索引:  0     1     2     3     4     5     6     7     8     9     10
值:  -32768 -1000 -500  -255  -100  0     100   255   500   1000  32767
```

## 关键点说明

1. **有符号数处理**: 
   - 最后一趟对符号位进行异或操作，确保负数排在正数之前
   - 异或操作实际上是将最高位取反

2. **稳定性**: 
   - 相同键值的元素保持原有相对顺序
   - 例如第一趟中32767和255都在桶255，32767在前

3. **分趟处理**: 
   - 从最低有效位到最高有效位
   - 每趟排序都是稳定的

4. **最终结果验证**: 
   - 数组已完全按升序排列
   - 负数在前，正数在后，各自有序

这个示例清晰地展示了基数排序如何通过多趟处理不同位段，结合计数排序和前缀和计算，最终实现对整个数组的高效排序。