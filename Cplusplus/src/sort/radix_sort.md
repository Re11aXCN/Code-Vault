# 基数排序逻辑流程

## 前言

基数排序源于对**桶排序**的优化改进。传统桶排序存在以下问题：

1. **内存分配过大**：当处理`int`等数据类型时，如果直接为每个可能值分配桶，需要2³² ≈ 43亿个桶，内存开销巨大
2. **分配时间过长**：大规模内存分配的时间复杂度可能超过O(log n)，甚至比基于比较的排序算法更慢

**基数排序的核心优化思想**：

- **复用桶结构**：仅使用固定数量的桶（如256个），通过多轮处理实现排序
- **按位处理**：从最低有效位到最高有效位逐位排序，每轮只关注当前位的值
- **缓存友好**：连续的位操作具有良好的局部性，充分利用CPU缓存



**基数排序的关键在于**：

- 按位排序：从最低有效位（LSB）到最高有效位（MSB）或反之，每次根据一个位（或字节）将数据分配到桶中，然后收集回数组。
- 稳定性：每一轮的排序必须是稳定的，即相同键值的元素在排序后相对顺序不变。
- 内存使用：通过复用桶和临时数组，减少内存分配和释放的开销。

基数排序通常比基于比较的排序（如快速排序、归并排序）更快，特别是对于整数和浮点数，因为它利用了数据的内部表示，并且具有更好的缓存局部性。

## 一、顺序执行

顺序执行的基数排序按照以下步骤进行：

1. **初始化**：
   - 确定排序的键类型，并转换为无符号整数以便处理。
   - 计算需要进行的轮数（passes），256桶时每轮处理1字节，65536桶时每轮处理2字节。
   - 准备一个临时缓冲区，用于在每轮排序中存放排序后的数据。
2. **逐轮排序**：
   - 对于每一轮（从最低有效字节到最高有效字节）：
     a. **计数**：遍历数组，统计每个桶中元素的个数。
     b. **计算前缀和**：通过 exclusive scan 将计数转换为每个桶在输出数组中的起始位置。
     c. **散射**：根据当前字节的值，**通过异或操作翻转最高位，将有符号数映射为无符号数范围，浮点型有符号整型都统一处理位无符号整型元素**放到临时数组的相应位置，并更新桶的起始位置。
   - 交换原始数组和临时数组的角色，准备下一轮排序。
3. **结束处理**：
   - 如果排序轮数为奇数，则需要将数据从临时数组复制回原数组（因为最后一轮排序后数据可能在临时数组中）。
   - 注意：我们的实现中，每轮排序后交换了原始数组和临时数组的指针，因此如果轮数为偶数，则数据最终在原数组中；如果为奇数，则在临时数组中，需要复制回原数组。但为了性能，我们通常避免复制，而是使用指针交换。然而，由于临时数组是局部变量，我们必须在最后确保数据在原数组中。我们的实现中，如果轮数为奇数，我们在循环结束后将数据从临时数组复制回原数组。但实际上，我们可以通过判断最后一轮后数据在哪个指针来避免不必要的复制。我们的代码中，循环结束后，如果_Start指向的是临时数组，则需要复制回原数组。

### 优化点：

- **键类型处理**：支持有符号整数、无符号整数和浮点数。对于有符号整数，我们通过转换无符号数并调整最高位的桶顺序来处理符号位。对于浮点数，我们通过位操作将其转换为无符号整数，并调整符号位，使得浮点数的比较与无符号整数一致。
- **桶大小**：支持256（每字节）和65536（每两字节）两种桶大小。桶大小越大，轮数越少，但每轮需要更多的计数和前缀和计算。
- **稳定性**：每一轮的排序是稳定的，这是通过散射时按顺序放入桶中并依次取出保证的。

## 二、并行执行

并行执行的基数排序在顺序执行的基础上，将工作分配给多个线程。主要挑战在于如何并行化计数和散射阶段，同时保持稳定性。

### 并行步骤：

1. **初始化**：
   - 确定线程数，根据数据大小和硬件并发数动态调整。
   - 将数据分成多个块，每个线程处理一个块。
2. **逐轮排序**：
   - 对于每一轮：
     a. **局部计数**：每个线程统计自己数据块中每个桶的元素个数。
     b. **全局归约**：将每个线程的局部计数合并，得到全局的每个桶的总数。
     c. **计算全局前缀和**：根据全局计数计算每个桶的全局起始位置。
     d. **计算局部偏移**：每个线程根据全局前缀和和自己之前线程的计数，计算自己数据块中每个桶的起始位置。
     e. **并行散射**：每个线程根据当前字节的值，将元素放到临时数组的相应位置，使用局部偏移数组来确保每个线程写入正确的位置。
3. **结束处理**：与顺序执行相同，确保数据在原始数组中。

### 优化点：

- **局部计数和偏移数组**：我们为每个线程分配了局部计数和偏移数组，避免在散射阶段使用原子操作，从而提高性能。
- **内存访问优化**：将每个线程的桶计数和偏移量连续存储，减少内存碎片，提高缓存命中率，在全局归约阶段，我们通过改变循环顺序（先遍历桶，再遍历线程）来提高缓存命中率。
- **动态线程数**：根据数据大小和最小块大小（1024）动态调整线程数，避免创建过多线程导致开销。

### 并行执行的关键：

- **散射阶段的稳定性**：每个线程内部保持稳定性，因为每个线程按顺序处理自己数据块中的元素，并且每个桶的偏移是全局确定的，所以不同线程的元素在散射到同一个桶时，先被处理的线程（数据块中靠前的元素）会放在更前面的位置。
- **负载均衡**：数据被均匀分成块，每个线程处理大致相同数量的元素。

### 三阶段并行流水线

#### 阶段3.1：并行局部计数

cpp

```
#pragma omp parallel num_threads(_Actual_threads)
{
    // 每个线程独立统计自己数据块的桶分布
    for (std::size_t _Idx = _Start_idx; _Idx < _End_idx; ++_Idx) {
        ++_Local_buckets[_Byte_idx];
    }
}
```



**并行策略**：

- 数据分块：每个线程处理连续的数据块
- 无锁操作：各线程独立计数，无需同步

#### 阶段3.2：优化的全局前缀和

##### 步骤2.1：全局归约

cpp

```
for (std::uint32_t _Bucket = 0; _Bucket < _Bucket_size; ++_Bucket) {
    std::size_t _Bucket_total = 0;
    for (std::int32_t _Thread = 0; _Thread < _Actual_threads; ++_Thread) {
        _Bucket_total += _Func_get_local_buckets(_Thread)[_Bucket];
    }
    _Global_prefix[_Bucket] = _Bucket_total;
}
```



**循环顺序优化**：外层循环遍历桶，内层循环遍历线程，提高缓存局部性

##### 步骤2.2：全局前缀扫描

cpp

```
std::size_t _Running_sum = 0;
for (std::uint32_t _Bucket = 0; _Bucket < _Bucket_size; ++_Bucket) {
    _Global_prefix[_Bucket] = _Running_sum;
    _Running_sum += _Current_count;
}
```



##### 步骤2.3：本地偏移计算

cpp

```
for (std::int32_t _Thread = 0; _Thread < _Actual_threads; ++_Thread) {
    for (std::uint32_t _Bucket = 0; _Bucket < _Bucket_size; ++_Bucket) {
        _Local_offsets[_Bucket] = _Global_prefix[_Bucket];
        _Global_prefix[_Bucket] += _Local_buckets[_Bucket];
    }
}
```



**单次遍历优化**：在单次循环中完成所有线程的偏移量计算

#### 阶段3.3：并行散射

cpp

```
#pragma omp parallel num_threads(_Actual_threads)
{
    for (std::size_t _Idx = _Start_idx; _Idx < _End_idx; ++_Idx) {
        _End[_Local_offsets[_Byte_idx]++] = _Value;
    }
}
```



**无冲突写入**：每个线程使用独立的偏移量数组，避免写入竞争

## 总结

基数排序通过按位排序，实现了线性时间复杂度的排序。顺序执行版本简单高效，适用于中小规模数据。并行执行版本通过分块和局部计数/偏移，充分利用多核处理器，适用于大规模数据。两种版本都支持多种数据类型和排序顺序，并提供了灵活的键提取方式，可以适应不同的排序需求。

注意：基数排序不是原地排序，需要额外的内存空间。在并行版本中，需要额外的内存来存储每个线程的计数和偏移。





# 示例 整型 数据执行流程

用一个较长且经典的示例详细描述基数排序的每趟结果。让我们使用有符号16位整数进行排序，这样可以看到多趟处理的效果。

## 示例数据
让我们排序以下有符号16位整数数组：
```
[32767, -32768, 100, -100, 0, 255, -255, 500, -500, 1000, -1000]
```

## 基数排序参数
- **数据类型**: `int16_t` (16位有符号整数)
- **桶大小**: 256 (每趟处理8位)
- **趟数**: 2趟 (16位 ÷ 8位/趟)

## 第一趟排序 (处理低8位)

### 步骤1: 转换为无符号表示
```
原始值       无符号表示(补码)   二进制表示
32767  ->   32767         0111111111111111
-32768 ->   32768         1000000000000000
100    ->   100           0000000001100100
-100   ->   65436         1111111110011100
0      ->   0             0000000000000000
255    ->   255           0000000011111111
-255   ->   65281         1111111100000001
500    ->   500           0000000111110100
-500   ->   65036         1111111000001100
1000   ->   1000          0000001111101000
-1000  ->   64536         1111110000011000
```

### 步骤2: 提取低8位 (第0-7位)
```
值       无符号值   低8位(索引)  调整后索引(第一趟不调整)
32767    32767     255          255
-32768   32768     0            0
100      100       100          100
-100     65436     156          156
0        0         0            0
255      255       255          255
-255     65281     1            1
500      500       244          244
-500     65036     12           12
1000     1000      232          232
-1000    64536     24           24
```

### 步骤3: 计数和重排
**桶计数结果:**
```
桶0: 2个 (-32768, 0)
桶1: 1个 (-255)
桶12: 1个 (-500)
桶24: 1个 (-1000)
桶100: 1个 (100)
桶156: 1个 (-100)
桶232: 1个 (1000)
桶244: 1个 (500)
桶255: 2个 (32767, 255)
```

**第一趟排序后结果:**
```
[-32768, 0, -255, -500, -1000, 100, -100, 1000, 500, 32767, 255]
```

## 第二趟排序 (处理高8位 + 符号位修正)

### 步骤1: 提取高8位 (第8-15位)
```
当前值     无符号值   高8位(索引)  调整后索引(异或128)
-32768    32768     128         128 ^ 128 = 0
0         0         0           0 ^ 128 = 128
-255      65281     255         255 ^ 128 = 127
-500      65036     254         254 ^ 128 = 126
-1000     64536     252         252 ^ 128 = 124
100       100       0           0 ^ 128 = 128
-100      65436     255         255 ^ 128 = 127
1000      1000      3           3 ^ 128 = 131
500       500       1           1 ^ 128 = 129
32767     32767     127         127 ^ 128 = 255
255       255       0           0 ^ 128 = 128
```

### 步骤2: 计数和重排
**桶计数结果:**
```
桶0: 1个 (-32768)      // 负数最小
桶124: 1个 (-1000)     // 负数
桶126: 1个 (-500)      // 负数
桶127: 2个 (-255, -100) // 负数
桶128: 3个 (0, 100, 255) // 正数
桶129: 1个 (500)       // 正数
桶131: 1个 (1000)      // 正数
桶255: 1个 (32767)     // 正数最大
```

**第二趟排序后最终结果:**
```
[-32768, -1000, -500, -255, -100, 0, 100, 255, 500, 1000, 32767]
```

## 排序过程可视化

### 初始数组:
```
索引:  0     1     2     3     4     5     6     7     8     9     10
值:  32767 -32768 100   -100  0     255   -255  500   -500  1000  -1000
```

### 第一趟后 (按低8位排序):
```
索引:  0     1     2     3     4     5     6     7     8     9     10
值:  -32768 0     -255  -500  -1000 100   -100  1000  500   32767 255
```

### 第二趟后 (按高8位+符号位排序):
```
索引:  0     1     2     3     4     5     6     7     8     9     10
值:  -32768 -1000 -500  -255  -100  0     100   255   500   1000  32767
```

## 关键点说明

1. **有符号数处理**: 
   - 最后一趟对符号位进行异或操作，确保负数排在正数之前
   - 异或操作实际上是将最高位取反

2. **稳定性**: 
   - 相同键值的元素保持原有相对顺序
   - 例如第一趟中32767和255都在桶255，32767在前

3. **分趟处理**: 
   - 从最低有效位到最高有效位
   - 每趟排序都是稳定的

4. **最终结果验证**: 
   - 数组已完全按升序排列
   - 负数在前，正数在后，各自有序

这个示例清晰地展示了基数排序如何通过多趟处理不同位段，结合计数排序和前缀和计算，最终实现对整个数组的高效排序。



# 示例 浮点数 数据执行流程

## 示例数据（32位单精度浮点数）

让我们排序以下11个有代表性的浮点数：

```
[-2.5f, 0.0f, 1.5f, -1.25f, 3.75f, -0.5f, 100.0f, -100.0f, -0.0f, 250.0f, -250.0f]
```

## IEEE 754 32位浮点数格式说明
- **1位符号位** + **8位指数位** + **23位尾数位**
- 实际值 = (-1)^sign × (1 + mantissa) × 2^(exponent-127)

## 数据预处理表格

| 原始浮点数 | IEEE 754十六进制 | 二进制表示                       | 类型 | 翻转符号位/所有位后值 | 对应无符号整数 |
| ---------- | ---------------- | -------------------------------- | ---- | --------------------- | -------------- |
| -2.5       | 0xC0200000       | 11000000001000000000000000000000 | 负数 | 0x3FDFFFFF            | 1071644671     |
| 0.0        | 0x00000000       | 00000000000000000000000000000000 | 正零 | 0x80000000            | 2147483648     |
| 1.5        | 0x3FC00000       | 00111111110000000000000000000000 | 正数 | 0xBFC00000            | 3221225472     |
| -1.25      | 0xBFA00000       | 10111111101000000000000000000000 | 负数 | 0x405FFFFF            | 1077936127     |
| 3.75       | 0x40700000       | 01000000011100000000000000000000 | 正数 | 0xC0700000            | 3228499968     |
| -0.5       | 0xBF000000       | 10111111000000000000000000000000 | 负数 | 0x40FFFFFF            | 1088421887     |
| 100.0      | 0x42C80000       | 01000010110010000000000000000000 | 正数 | 0xC2C80000            | 3267887104     |
| -100.0     | 0xC2C80000       | 11000010110010000000000000000000 | 负数 | 0x3D37FFFF            | 1026559999     |
| -0.0       | 0x80000000       | 10000000000000000000000000000000 | 负零 | 0x7FFFFFFF            | 2147483647     |
| 250.0      | 0x437A0000       | 01000011011110100000000000000000 | 正数 | 0xC37A0000            | 3275005952     |
| -250.0     | 0xC37A0000       | 11000011011110100000000000000000 | 负数 | 0x3C85FFFF            | 1015117823     |

## 基数排序参数（降序排序）
- **桶大小**: 256（每趟处理8位）
- **趟数**: 4趟（32位 ÷ 8位/趟）
- **排序方向**: 降序（使用`std::greater<>`）

## 第一趟排序（处理最低8位：位0-7）

### 处理规则（降序）：
- 提取低8位：`(value >> 0) & 0xFF`
- 降序调整：`255 - byte_index`

### 第一趟处理详情：

| 原始值 | 调整后无符号值 | 低8位 | 降序索引 | 桶号 |
| ------ | -------------- | ----- | -------- | ---- |
| -2.5   | 1071644671     | 255   | 0        | 0    |
| 0.0    | 2147483648     | 0     | 255      | 255  |
| 1.5    | 3221225472     | 0     | 255      | 255  |
| -1.25  | 1077936127     | 255   | 0        | 0    |
| 3.75   | 3228499968     | 0     | 255      | 255  |
| -0.5   | 1088421887     | 255   | 0        | 0    |
| 100.0  | 3267887104     | 0     | 255      | 255  |
| -100.0 | 1026559999     | 255   | 0        | 0    |
| -0.0   | 2147483647     | 255   | 0        | 0    |
| 250.0  | 3275005952     | 0     | 255      | 255  |
| -250.0 | 1015117823     | 255   | 0        | 0    |

### 第一趟桶分布：

| 桶号 | 元素                                    | 桶内顺序 |
| ---- | --------------------------------------- | -------- |
| 0    | -2.5, -1.25, -0.5, -100.0, -0.0, -250.0 | 保持原序 |
| 255  | 0.0, 1.5, 3.75, 100.0, 250.0            | 保持原序 |

### 第一趟排序后结果：
```
[-2.5, -1.25, -0.5, -100.0, -0.0, -250.0, 0.0, 1.5, 3.75, 100.0, 250.0]
```

## 第二趟排序（处理位8-15）

### 处理规则：
- 提取位8-15：`(value >> 8) & 0xFF`
- 降序调整：`255 - byte_index`

### 第二趟处理详情：

| 当前值 | 调整后无符号值 | 位8-15 | 降序索引 | 桶号 |
| ------ | -------------- | ------ | -------- | ---- |
| -2.5   | 1071644671     | 223    | 32       | 32   |
| -1.25  | 1077936127     | 223    | 32       | 32   |
| -0.5   | 1088421887     | 223    | 32       | 32   |
| -100.0 | 1026559999     | 61     | 194      | 194  |
| -0.0   | 2147483647     | 255    | 0        | 0    |
| -250.0 | 1015117823     | 60     | 195      | 195  |
| 0.0    | 2147483648     | 0      | 255      | 255  |
| 1.5    | 3221225472     | 0      | 255      | 255  |
| 3.75   | 3228499968     | 0      | 255      | 255  |
| 100.0  | 3267887104     | 200    | 55       | 55   |
| 250.0  | 3275005952     | 250    | 5        | 5    |

### 第二趟桶分布：

| 桶号 | 元素              | 说明       |
| ---- | ----------------- | ---------- |
| 0    | -0.0              | 负零       |
| 5    | 250.0             | 最大正数   |
| 32   | -2.5, -1.25, -0.5 | 中等负数   |
| 55   | 100.0             | 中等正数   |
| 194  | -100.0            | 较大负数   |
| 195  | -250.0            | 最大负数   |
| 255  | 0.0, 1.5, 3.75    | 零和小正数 |

### 第二趟排序后结果：
```
[-0.0, 250.0, -2.5, -1.25, -0.5, 100.0, -100.0, -250.0, 0.0, 1.5, 3.75]
```

## 第三趟排序（处理位16-23）

### 处理规则：
- 提取位16-23：`(value >> 16) & 0xFF`
- 降序调整：`255 - byte_index`

### 第三趟处理详情（关键元素）：

| 当前值 | 调整后无符号值 | 位16-23 | 降序索引 | 桶号 |
| ------ | -------------- | ------- | -------- | ---- |
| -0.0   | 2147483647     | 255     | 0        | 0    |
| 250.0  | 3275005952     | 127     | 128      | 128  |
| -2.5   | 1071644671     | 63      | 192      | 192  |
| -1.25  | 1077936127     | 63      | 192      | 192  |
| -0.5   | 1088421887     | 63      | 192      | 192  |
| 100.0  | 3267887104     | 194     | 61       | 61   |
| -100.0 | 1026559999     | 61      | 194      | 194  |
| -250.0 | 1015117823     | 60      | 195      | 195  |
| 0.0    | 2147483648     | 0       | 255      | 255  |
| 1.5    | 3221225472     | 192     | 63       | 63   |
| 3.75   | 3228499968     | 192     | 63       | 63   |

### 第三趟排序后结果：
```
[-0.0, 250.0, 100.0, 1.5, 3.75, -2.5, -1.25, -0.5, -100.0, -250.0, 0.0]
```

## 第四趟排序（处理最高8位：位24-31 + 符号位修正）

### 处理规则：
- 提取最高8位：`(value >> 24) & 0xFF`
- **符号位修正**：由于是最后一趟，需要对有符号类型进行特殊处理
- 降序调整：`255 - byte_index`

### 第四趟处理详情：

| 当前值 | 调整后无符号值 | 位24-31 | 修正后索引 | 降序索引 | 桶号 |
| ------ | -------------- | ------- | ---------- | -------- | ---- |
| -0.0   | 2147483647     | 127     | 127        | 128      | 128  |
| 250.0  | 3275005952     | 195     | 195        | 60       | 60   |
| 100.0  | 3267887104     | 194     | 194        | 61       | 61   |
| 1.5    | 3221225472     | 192     | 192        | 63       | 63   |
| 3.75   | 3228499968     | 192     | 192        | 63       | 63   |
| -2.5   | 1071644671     | 63      | 191        | 64       | 64   |
| -1.25  | 1077936127     | 63      | 191        | 64       | 64   |
| -0.5   | 1088421887     | 63      | 191        | 64       | 64   |
| -100.0 | 1026559999     | 61      | 189        | 66       | 66   |
| -250.0 | 1015117823     | 60      | 188        | 67       | 67   |
| 0.0    | 2147483648     | 128     | 128        | 127      | 127  |

### 第四趟桶分布：

| 桶号范围 | 元素类型 | 具体元素                          |
| -------- | -------- | --------------------------------- |
| 60-63    | 大正数   | 250.0, 100.0, 3.75, 1.5           |
| 64-67    | 小负数   | -2.5, -1.25, -0.5, -100.0, -250.0 |
| 127-128  | 零值     | 0.0, -0.0                         |

### 最终排序结果（降序）：
```
[250.0, 100.0, 3.75, 1.5, 0.0, -0.0, -0.5, -1.25, -2.5, -100.0, -250.0]
```

## 关键处理要点总结

### 1. 浮点数特殊处理
- **符号位翻转**：正数翻转符号位，负数翻转所有位
- **目的**：将浮点数映射到无符号整数空间，保持大小关系
- **效果**：正数变为大无符号数，负数变为小无符号数

### 2. 降序排序实现
- **索引反转**：每趟使用`255 - byte_index`实现降序
- **稳定性保持**：相同键值元素保持相对顺序

### 3. 多趟处理逻辑
- **从低到高**：先处理低位，后处理高位
- **逐步求精**：每趟都在前一趟的基础上进一步排序
- **最终修正**：最后一趟处理符号位，确保正确顺序

### 4. 性能特点
- **时间复杂度**：O(kn)，其中k为趟数（4趟），n为元素数量
- **空间复杂度**：O(n + b)，b为桶数量（256）
- **稳定性**：是稳定排序算法

这个示例完整展示了基数排序处理浮点数的全过程，包括类型转换、位操作、多趟排序等关键步骤。