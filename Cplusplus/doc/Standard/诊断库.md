# 头文件

https://www.bilibili.com/video/BV1QpWSekEJY/

```
#include <cerrno>
#include <cassert>
#include <exception>
#include <stdexcept>
#include <system_error>
#include <stacktrace>
#include <debugging>
```



# 诊断库

###  异常处理（常用于自定义异常）

头文件 [``](https://cppreference.cn/w/cpp/header/exception) 提供了几个与 C++ 程序中异常处理相关的类和函数。



| 定义于头文件 `<exception>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ exception](https://cppreference.cn/w/cpp/error/exception)  | 标准库组件抛出的异常的基类  (类)                             |
| 异常对象的捕获和存储                                         |                                                              |
| [ uncaught_exceptionuncaught_exceptions](https://cppreference.cn/w/cpp/error/uncaught_exception)(C++20* 中移除)(C++17) | 检查异常处理当前是否正在进行  (函数)                         |
| [ exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr)(C++11) | 用于处理异常对象的共享指针类型  (类型别名)                   |
| [ make_exception_ptr](https://cppreference.cn/w/cpp/error/make_exception_ptr)(C++11) | 从异常对象创建 [std::exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr)  (函数模板) |
| [ current_exception](https://cppreference.cn/w/cpp/error/current_exception)(C++11) | 在 [std::exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr) 中捕获当前异常  (函数) |
| [ rethrow_exception](https://cppreference.cn/w/cpp/error/rethrow_exception)(C++11) | 从 [std::exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr) 抛出异常  (函数) |
| [ nested_exception](https://cppreference.cn/w/cpp/error/nested_exception)(C++11) | 用于捕获和存储当前异常的混入类型  (类)                       |
| [ throw_with_nested](https://cppreference.cn/w/cpp/error/throw_with_nested)(C++11) | 抛出其参数，并混入 [std::nested_exception](https://cppreference.cn/w/cpp/error/nested_exception)  (函数模板) |
| [ rethrow_if_nested](https://cppreference.cn/w/cpp/error/rethrow_if_nested)(C++11) | 从 [std::nested_exception](https://cppreference.cn/w/cpp/error/nested_exception) 抛出异常  (函数模板) |
| 异常处理中的失败处理                                         |                                                              |
| 定义于头文件 `<exception>`                                   |                                                              |
| [ terminate](https://cppreference.cn/w/cpp/error/terminate)  | 当异常处理失败时调用的函数  (函数)                           |
| [ terminate_handler](https://cppreference.cn/w/cpp/error/terminate_handler) | 由 [std::terminate](https://cppreference.cn/w/cpp/error/terminate) 调用的函数的类型  (类型别名) |
| [ get_terminate](https://cppreference.cn/w/cpp/error/get_terminate)(C++11) | 获取当前的 terminate_handler  (函数)                         |
| [ set_terminate](https://cppreference.cn/w/cpp/error/set_terminate) | 更改要由 [std::terminate](https://cppreference.cn/w/cpp/error/terminate) 调用的函数  (函数) |
| [ bad_exception](https://cppreference.cn/w/cpp/error/bad_exception) | 当 [std::current_exception](https://cppreference.cn/w/cpp/error/current_exception) 无法复制异常对象时抛出的异常  (类) |
| 异常规范违规的处理 (直到 C++17)                              |                                                              |
| [ unexpected](https://cppreference.cn/w/cpp/error/unexpected)(在 C++11 中弃用)(在 C++17 中移除) | 当动态异常规范被违反时调用的函数  (函数)                     |
| [ unexpected_handler](https://cppreference.cn/w/cpp/error/unexpected_handler)(在 C++11 中弃用)(在 C++17 中移除) | 由 [std::unexpected](https://cppreference.cn/w/cpp/error/unexpected) 调用的函数的类型  (类型别名) |
| [ get_unexpected](https://cppreference.cn/w/cpp/error/get_unexpected)(在 C++11 中弃用)(在 C++17 中移除) | 获取当前的 `unexpected_handler`  (函数)                      |
| [ set_unexpected](https://cppreference.cn/w/cpp/error/set_unexpected)(在 C++11 中弃用)(在 C++17 中移除) | 更改要由 [std::unexpected](https://cppreference.cn/w/cpp/error/unexpected) 调用的函数  (函数) |

###  异常类别（常用于 throw异常）

头文件 `<stdexcept>` 中预定义了几个便利类，用于报告特定的错误情况。这些类可以分为两类：*逻辑*错误和*运行时*错误。逻辑错误是程序内部错误逻辑的结果，可能是可以预防的。运行时错误是由于程序范围之外的事件造成的，不易预测。

| 定义于头文件 `<stdexcept>`                                   |                                                    |
| ------------------------------------------------------------ | -------------------------------------------------- |
| [ logic_error](https://cppreference.cn/w/cpp/error/logic_error) | 异常类，指示违反逻辑前提条件或类不变量的情况  (类) |
| [ invalid_argument](https://cppreference.cn/w/cpp/error/invalid_argument) | 异常类，用于报告无效参数  (类)                     |
| [ domain_error](https://cppreference.cn/w/cpp/error/domain_error) | 异常类，用于报告域错误  (类)                       |
| [ length_error](https://cppreference.cn/w/cpp/error/length_error) | 异常类，用于报告尝试超出最大允许大小的情况  (类)   |
| [ out_of_range](https://cppreference.cn/w/cpp/error/out_of_range) | 异常类，用于报告超出预期范围的参数  (类)           |
| [ runtime_error](https://cppreference.cn/w/cpp/error/runtime_error) | 异常类，指示仅在运行时可检测到的条件  (类)         |
| [ range_error](https://cppreference.cn/w/cpp/error/range_error) | 异常类，用于报告内部计算中的范围错误  (类)         |
| [ overflow_error](https://cppreference.cn/w/cpp/error/overflow_error) | 异常类，用于报告算术溢出  (类)                     |
| [ underflow_error](https://cppreference.cn/w/cpp/error/underflow_error) | 异常类，用于报告算术下溢  (类)                     |
| [ tx_exception](https://cppreference.cn/w/cpp/error/tx_exception)(TM TS) | 异常类，用于取消原子事务  (类模板)                 |



###  错误号（见 [cdefine](./cdefine.md)的cerrno）

| 定义于头文件 `<cerrno>`                                      |                                                    |
| ------------------------------------------------------------ | -------------------------------------------------- |
| [ errno](https://cppreference.cn/w/cpp/error/errno)          | 宏，展开为 POSIX 兼容的线程局部错误号变量 (宏变量) |
| [ E2BIG, EACCES, ..., EXDEV](https://cppreference.cn/w/cpp/error/errno_macros) | 标准 POSIX 兼容错误条件的宏  (宏常量)              |



###  系统错误 (自 C++11 起)（常用于设置错误码/类别枚举使用）

头文件 `<system_error>` 定义了用于报告源自操作系统、流 I/O、[std::future](https://cppreference.cn/w/cpp/thread/future) 或其他底层 API 的错误条件的类型和函数。

| 定义于头文件 `<system_error>`                                |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ error_category](https://cppreference.cn/w/cpp/error/error_category)(C++11) | 错误类别的基类  (类)                                         |
| [ generic_category](https://cppreference.cn/w/cpp/error/generic_category)(C++11) | 标识通用错误类别  (函数)                                     |
| [ system_category](https://cppreference.cn/w/cpp/error/system_category)(C++11) | 标识操作系统错误类别  (函数)                                 |
| [ error_condition](https://cppreference.cn/w/cpp/error/error_condition)(C++11) | 持有可移植的错误码  (类)                                     |
| [ errc](https://cppreference.cn/w/cpp/error/errc)(C++11)     | [std::error_condition](https://cppreference.cn/w/cpp/error/error_condition) 枚举，列出所有标准的 [``](https://cppreference.cn/w/cpp/header/cerrno) 宏常量  (类) |
| [ error_code](https://cppreference.cn/w/cpp/error/error_code)(C++11) | 持有平台相关的错误码  (类)                                   |
| [ system_error](https://cppreference.cn/w/cpp/error/system_error)(C++11) | 用于报告具有 error_code 的条件的异常类  (类)                 |



###  断言

断言有助于在程序中实现前提条件的检查。

| 定义于头文件 `<cassert>`                              |                                                              |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| [ assert](https://cppreference.cn/w/cpp/error/assert) | 如果用户指定的条件不为 true，则中止程序。可能在发布版本中禁用。  (函数宏) |



###  [堆栈回溯](https://cppreference.cn/w/cpp/utility/basic_stacktrace) (自 C++23 起)

| 定义于头文件 `<stacktrace>`                                  |                                                  |
| ------------------------------------------------------------ | ------------------------------------------------ |
| [ stacktrace_entry](https://cppreference.cn/w/cpp/utility/stacktrace_entry)(C++23) | 堆栈回溯中求值的表示  (类)                       |
| [ basic_stacktrace](https://cppreference.cn/w/cpp/utility/basic_stacktrace)(C++23) | 调用序列的近似表示，由堆栈回溯条目组成  (类模板) |



###  调试支持 (自 C++26 起)

| 定义于头文件 `<debugging>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ breakpoint](https://cppreference.cn/w/cpp/utility/breakpoint)(C++26) | 调用时暂停正在运行的程序  (函数)                             |
| [ breakpoint_if_debugging](https://cppreference.cn/w/cpp/utility/breakpoint_if_debugging)(C++26) | 如果 std::is_debugger_present 返回 true，则调用 std::breakpoint  (函数) |
| [ is_debugger_present](https://cppreference.cn/w/cpp/utility/is_debugger_present)(C++26) | 检查程序是否在调试器的控制下运行  (函数)                     |

###  参见

| [`static_assert` 声明](https://cppreference.cn/w/cpp/language/static_assert) (C++11) | 执行编译时断言检查 |
| ------------------------------------------------------------ | ------------------ |
| [C 文档](https://cppreference.cn/w/c/error) 关于 错误处理    |                    |

# C语言错误处理：errno、perror与strerror详解
## 一、需求概述
你想了解C语言中`errno`在多线程环境下的使用、不借助`perror`如何打印错误码对应的详细信息、`strerror`的定义及它与`perror`的区别，同时需要明确二者的线程安全性，最终希望通过Markdown形式系统学习C语言的错误处理相关知识。

## 二、核心知识点详解
### 2.1 errno：C语言的错误码基石
#### 2.1.1 基本定义
`errno`是C标准库提供的**全局错误码变量**，本质是一个宏（并非单纯的全局变量），定义在`<errno.h>`头文件中。当系统调用或库函数执行失败时，会设置`errno`为对应的错误码（成功时不会主动清空`errno`），程序可通过读取`errno`判断错误类型。

#### 2.1.2 多线程安全性
早期`errno`是全局变量，多线程下会出现“错误码覆盖”问题（线程A设置的`errno`可能被线程B修改）。  
现代C标准（POSIX.1-2001）已将`errno`实现为**线程局部存储（TLS）**，即每个线程拥有独立的`errno`副本，因此**现代系统中errno是线程安全的**。

### 2.2 perror：一键打印错误信息
#### 2.2.1 功能与用法
`perror`是C标准库函数（定义在`<stdio.h>`），功能是：
1. 先打印自定义提示字符串；
2. 自动读取当前线程的`errno`，并打印对应的人类可读错误描述；
3. 末尾自动加换行。

**示例代码**：
```c
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    // 尝试打开不存在的文件，触发错误
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        // 打印格式：自定义字符串: 错误描述
        perror("open file failed");
    }
    close(fd);
    return 0;
}
```
**输出示例**：
```
open file failed: No such file or directory
```

#### 2.2.2 线程安全性
`perror`本身是线程安全的：它读取的是当前线程的`errno`（TLS），且打印过程不会与其他线程的`perror`输出混乱（标准IO的打印是原子操作）。

### 2.3 strerror：手动获取错误描述字符串
#### 2.3.1 功能与用法
`strerror`是C标准库函数（定义在`<string.h>`），接收一个错误码（如`errno`）作为参数，返回该错误码对应的**字符串描述**（无换行）。  
开发者可通过`printf`等函数自定义打印格式，替代`perror`。

**示例代码**：
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        // 手动拼接错误信息，替代perror
        printf("open file failed: %s (errno: %d)\n", strerror(errno), errno);
    }
    close(fd);
    return 0;
}
```
**输出示例**：
```
open file failed: No such file or directory (errno: 2)
```

#### 2.3.2 线程安全性
- 传统`strerror`：返回的是静态字符串缓冲区，多线程同时调用时可能被覆盖（非线程安全）；
- 现代改进版`strerror_r`：POSIX标准提供的线程安全版本（分为XSI和POSIX两种实现），需传入自定义缓冲区存储错误描述，避免竞争。

**strerror_r示例（POSIX版）**：
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        char err_buf[1024]; // 自定义缓冲区
        // 线程安全的错误描述获取
        strerror_r(errno, err_buf, sizeof(err_buf));
        printf("open file failed: %s (errno: %d)\n", err_buf, errno);
    }
    close(fd);
    return 0;
}
```

### 2.4 perror与strerror的核心区别
| 特性                | perror                          | strerror                          |
|---------------------|---------------------------------|-----------------------------------|
| 线程安全 | 安全 | 不安全（`strerror_r`是线程安全的） |
| 输出方式            | 直接打印到标准错误（stderr）    | 返回字符串，需手动打印（可自定义输出目标） |
| 格式                | 固定：自定义字符串 + 错误描述 + 换行 | 完全自定义（可拼接errno、其他信息） |
| 缓冲区              | 内部处理，无暴露                | 传统版用静态缓冲区（非线程安全），strerror_r用自定义缓冲区 |
| 依赖                | 依赖当前线程的errno             | 可传入任意错误码（不一定是errno） |
| 示例输出            | `open failed: No such file`     | 需配合printf：`open failed(errno=2): No such file` |

### 2.5 不使用perror打印错误信息的其他方式
除了`strerror`/`strerror_r`，还可直接通过`errno`值手动映射错误描述（不推荐，仅作了解）：
```c
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

const char* get_error_desc(int err) {
    switch(err) {
        case 2: return "No such file or directory";
        case 13: return "Permission denied";
        default: return "Unknown error";
    }
}

int main() {
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        printf("open failed: %s (errno: %d)\n", get_error_desc(errno), errno);
    }
    close(fd);
    return 0;
}
```
**缺点**：需要手动维护错误码与描述的映射表，跨平台兼容性差（不同系统errno值可能不同），远不如`strerror`灵活。

## 三、C语言错误处理最佳实践
### 3.1 基础原则
1. 函数执行失败时，优先通过返回值（如-1、NULL）标识，再通过`errno`细化错误类型；
2. 多线程中优先使用`strerror_r`替代`strerror`，保证线程安全；
3. 打印错误信息时，建议同时输出`errno`数值和描述，便于定位问题。

### 3.2 完整示例（多线程+错误处理）
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include <fcntl.h>
#include <unistd.h>

#define THREAD_NUM 2

// 线程函数：尝试打开不同文件，打印错误信息
void* thread_func(void* arg) {
    char* filename = (char*)arg;
    int fd = open(filename, O_RDONLY);
    
    if (fd == -1) {
        char err_buf[1024];
        // 线程安全的错误描述获取
        strerror_r(errno, err_buf, sizeof(err_buf));
        // 打印线程ID、错误信息、errno
        printf("Thread %ld: open %s failed: %s (errno: %d)\n", 
               pthread_self(), filename, err_buf, errno);
        pthread_exit(NULL);
    }
    
    printf("Thread %ld: open %s success\n", pthread_self(), filename);
    close(fd);
    pthread_exit(NULL);
}

int main() {
    pthread_t tid[THREAD_NUM];
    char* filenames[] = {"nonexist.txt", "test.txt"}; // 一个不存在，一个可能存在
    
    // 创建2个线程
    for (int i = 0; i < THREAD_NUM; i++) {
        if (pthread_create(&tid[i], NULL, thread_func, filenames[i]) != 0) {
            perror("pthread_create failed");
            return 1;
        }
    }
    
    // 等待线程结束
    for (int i = 0; i < THREAD_NUM; i++) {
        pthread_join(tid[i], NULL);
    }
    
    return 0;
}
```
**编译运行**：
```bash
# 编译时链接pthread库
gcc -o error_demo error_demo.c -pthread
./error_demo
```
**输出示例**：
```
Thread 140709267246848: open nonexist.txt failed: No such file or directory (errno: 2)
Thread 140709258854144: open test.txt success
```

## 四、总结
1. **errno**：现代系统中是线程局部存储（TLS），每个线程独立，线程安全；函数失败时设置，成功时不清空，需结合返回值判断是否出错。
2. **perror**：直接打印错误信息（自定义字符串+errno描述），线程安全，输出到stderr，格式固定；
3. **strerror**：返回错误码对应的字符串描述，需手动打印，传统版非线程安全，推荐使用线程安全的`strerror_r`；
4. 多线程错误处理核心：优先用`strerror_r`获取错误描述，同时输出`errno`数值和上下文信息，便于问题定位。

# C++ 现代化错误处理：system_error 增强与 std::expected 详解
## 一、需求概述
系统学习 C++ 中基于 `system_error` 的增强型错误处理方案，包括：使用 `std::errc` 标准枚举、自定义错误枚举、通过继承 `std::error_category` 实现自定义错误信息派发、基于结构体传递错误信息；同时了解 C++23 引入的 `std::expected`，掌握其替代引用传参的错误返回方式，以及链式调用等高级特性。

## 二、核心概念与基础铺垫
### 2.1 C++ 原生错误处理的痛点
C 语言的 `errno`/`perror` 存在类型不安全、错误信息耦合度高的问题；早期 C++ 依赖异常（`throw`/`catch`）但存在性能开销，且无法直观区分“预期错误”和“程序异常”。  
C++11 引入 `std::system_error` 体系，通过**错误码（error_code）**、**错误类别（error_category）**、**错误条件（error_condition）** 三层架构，实现类型安全的错误处理，C++23 进一步推出 `std::expected`，解决“返回值+错误码”分离的问题。

### 2.2 核心组件速览
| 组件                | 作用                                                                 |
|---------------------|----------------------------------------------------------------------|
| `std::errc`         | 标准错误枚举（对应 POSIX 错误码），类型安全的 `errno` 替代           |
| `std::error_category` | 错误类别基类，定义错误码的命名空间、消息格式，可继承实现自定义类别    |
| `std::error_code`   | 错误码对象（包含数值 + 错误类别），可隐式转换为 `error_condition`    |
| `std::error_condition` | 错误条件（逻辑错误类型），用于跨类别匹配错误                         |
| `std::system_error` | 封装 `error_code` 的异常类型，可抛出或存储错误信息                   |
| `std::expected<T,E>` | C++23 核心，存储“预期返回值 T”或“错误 E”，替代“输出参数传错误”       |

## 三、基于 system_error 的增强型错误处理
### 3.1 基础用法：使用 std::errc 标准枚举
`std::errc` 是 C++11 提供的枚举类型，覆盖常见系统错误（如文件不存在、权限拒绝等），结合 `std::error_code` 可实现类型安全的错误表示。

#### 示例代码：标准错误码使用
```cpp
#include <iostream>
#include <system_error>
#include <fstream>

// 检查文件打开错误
bool open_file(const std::string& path) {
    std::ifstream file(path);
    if (!file.is_open()) {
        // 构造标准错误码：使用 std::errc::no_such_file_or_directory
        std::error_code ec = std::make_error_code(std::errc::no_such_file_or_directory);
        std::cout << "错误码：" << ec.value() << "\n"
                  << "错误类别：" << ec.category().name() << "\n"
                  << "错误信息：" << ec.message() << std::endl;
        return false;
    }
    return true;
}

int main() {
    open_file("nonexist.txt");
    return 0;
}
```

#### 输出结果：
```
错误码：2
错误类别：generic
错误信息：No such file or directory
```

### 3.2 进阶：自定义错误枚举与 error_category
#### 3.2.1 核心思路
1. 定义**强类型枚举**表示自定义错误（避免与系统错误码冲突）；
2. 继承 `std::error_category`，重载 `name()`、`message()`、`default_error_condition()` 等方法，实现错误信息的自定义派发；
3. 重载 `std::make_error_code`，让自定义枚举可隐式转换为 `std::error_code`。

#### 3.2.2 完整实现代码
```cpp
#include <iostream>
#include <system_error>
#include <string>
#include <unordered_map>

// 步骤1：定义自定义错误枚举（强类型，避免命名冲突）
enum class CustomErrc {
    FILE_CORRUPT = 1001,    // 文件损坏
    PARSE_FAILED = 1002,    // 解析失败
    NETWORK_TIMEOUT = 1003  // 网络超时
};

// 步骤2：继承 error_category 实现自定义错误类别
class CustomErrorCategory : public std::error_category {
public:
    // 返回错误类别名称（唯一标识）
    const char* name() const noexcept override {
        return "CustomErrorCategory";
    }

    // 核心：根据错误码派发不同的错误消息（支持函数签名级别的定制）
    std::string message(int ev) const override {
        // 将 int 转换为自定义枚举
        CustomErrc err = static_cast<CustomErrc>(ev);
        // 按错误类型派发不同的消息生成逻辑
        switch (err) {
            case CustomErrc::FILE_CORRUPT:
                return "文件格式损坏，无法解析";
            case CustomErrc::PARSE_FAILED:
                return "数据解析失败，字段格式不合法";
            case CustomErrc::NETWORK_TIMEOUT:
                return "网络请求超时，超过30秒未响应";
            default:
                return "未知自定义错误: " + std::to_string(ev);
        }
    }

    // 可选：映射到标准错误条件（便于跨类别匹配）
    std::error_condition default_error_condition(int ev) const noexcept override {
        CustomErrc err = static_cast<CustomErrc>(ev);
        switch (err) {
            case CustomErrc::NETWORK_TIMEOUT:
                // 映射到标准的超时错误
                return std::error_condition(std::errc::timed_out);
            default:
                return std::error_condition(ev, *this);
        }
    }

    // 单例模式：避免重复创建类别对象
    static const CustomErrorCategory& instance() {
        static CustomErrorCategory instance;
        return instance;
    }
};

// 步骤3：重载 make_error_code，让自定义枚举可转换为 error_code
std::error_code make_error_code(CustomErrc e) noexcept {
    return {static_cast<int>(e), CustomErrorCategory::instance()};
}

// 步骤4：特化 is_error_code_enum，让编译器识别自定义枚举为错误码类型
namespace std {
    template <>
    struct is_error_code_enum<CustomErrc> : true_type {};
}

// 测试自定义错误码
void test_custom_error(CustomErrc err) {
    std::error_code ec = err; // 隐式转换（依赖上述重载）
    std::cout << "自定义错误码：" << ec.value() << "\n"
              << "错误类别：" << ec.category().name() << "\n"
              << "错误信息：" << ec.message() << "\n"
              << "是否超时：" << (ec == std::errc::timed_out ? "是" : "否") << std::endl;
}

int main() {
    test_custom_error(CustomErrc::NETWORK_TIMEOUT);
    test_custom_error(CustomErrc::FILE_CORRUPT);
    return 0;
}
```

#### 输出结果：
```
自定义错误码：1003
错误类别：CustomErrorCategory
错误信息：网络请求超时，超过30秒未响应
是否超时：是
自定义错误码：1001
错误类别：CustomErrorCategory
错误信息：文件格式损坏，无法解析
是否超时：否
```

### 3.3 错误信息结构体：统一传递错误上下文
为了携带更丰富的错误信息（如错误码、详细描述、发生位置），可定义结构体封装错误，通过**引用传递**给函数，实现错误信息的“输出型参数”。

#### 示例代码：自定义错误结构体
```cpp
#include <iostream>
#include <system_error>
#include <string>
#include <source_location> // C++20 源位置

// 定义错误信息结构体：包含错误码、详细消息、发生位置
struct ErrorInfo {
    std::error_code ec;          // 错误码（兼容标准/自定义）
    std::string detail_msg;      // 扩展详细消息
    std::source_location loc;    // 错误发生的文件/行号（C++20）

    // 重置错误（标记为无错误）
    void clear() {
        ec.clear();
        detail_msg.clear();
    }

    // 判断是否有错误
    explicit operator bool() const {
        return !ec.value() == 0; // ec.value()=0 表示无错误
    }
};

// 模拟解析文件函数：通过引用传递 ErrorInfo 输出错误
bool parse_file(const std::string& path, ErrorInfo& err) {
    // 重置之前的错误
    err.clear();

    // 模拟文件损坏错误
    if (path == "corrupt.txt") {
        err.ec = CustomErrc::FILE_CORRUPT;
        err.detail_msg = "文件 " + path + " 的头部魔数错误（应为 0x1234，实际为 0x5678）";
        err.loc = std::source_location::current(); // 记录当前位置
        return false;
    }

    return true;
}

// 外部调用：判断错误并处理
int main() {
    ErrorInfo err;
    std::string file_path = "corrupt.txt";

    if (!parse_file(file_path, err)) {
        // 错误处理：打印日志 + 中断/忽略
        std::cerr << "[错误] 位置：" << err.loc.file_name() << ":" << err.loc.line() << "\n"
                  << "错误码：" << err.ec.value() << " (" << err.ec.message() << ")\n"
                  << "详细信息：" << err.detail_msg << std::endl;

        // 可选：中断程序（return 1）或忽略继续执行
        // return 1;
    }

    std::cout << "程序继续执行..." << std::endl;
    return 0;
}
```

#### 输出结果：
```
[错误] 位置：main.cpp:45:
错误码：1001 (文件格式损坏，无法解析)
详细信息：文件 corrupt.txt 的头部魔数错误（应为 0x1234，实际为 0x5678）
程序继续执行...
```

## 四、C++23 std::expected：替代引用传参的现代化方案
### 4.1 std::expected 核心优势
`std::expected<T, E>` 是 C++23 引入的“预期值”类型，本质是类型安全的 `std::variant<T, E>`，但专为错误处理设计：
- 替代“返回值 + 引用传错误”的模式，函数直接返回 `std::expected`；
- 支持**链式调用**（`and_then`/`or_else`），简化错误处理流程；
- 无需手动管理错误结构体的生命周期，语义更清晰。

### 4.2 基础用法：返回预期值或错误
```cpp
#include <iostream>
#include <expected>   // C++23 头文件
#include <string>
#include "custom_error.h" // 包含前文的 CustomErrc 和 ErrorInfo

// 模拟读取文件内容：返回 std::expected（成功返回 string，失败返回 ErrorInfo）
std::expected<std::string, ErrorInfo> read_file(const std::string& path) {
    if (path == "corrupt.txt") {
        // 失败：返回错误信息
        ErrorInfo err;
        err.ec = CustomErrc::FILE_CORRUPT;
        err.detail_msg = "文件 " + path + " 损坏";
        err.loc = std::source_location::current();
        return std::unexpected(err); // 标记为“非预期值”（错误）
    }

    // 成功：返回文件内容
    return "文件内容：Hello World";
}

int main() {
    auto result = read_file("corrupt.txt");

    // 方式1：直接判断是否有值
    if (result) {
        std::cout << "读取成功：" << *result << std::endl;
    } else {
        // 获取错误信息
        const ErrorInfo& err = result.error();
        std::cerr << "读取失败：" << err.ec.message() << " - " << err.detail_msg << std::endl;
    }

    return 0;
}
```

### 4.3 高级用法：链式调用处理
`std::expected` 提供 `and_then`（成功时执行）、`or_else`（失败时执行）、`transform`（转换成功值）等方法，实现流式错误处理。

#### 示例代码：链式调用
```cpp
#include <iostream>
#include <expected>
#include <string>
#include <functional>

// 步骤1：读取文件（返回 expected<string, ErrorInfo>）
std::expected<std::string, ErrorInfo> read_file(const std::string& path) {
    if (path.empty()) {
        ErrorInfo err{std::make_error_code(std::errc::invalid_argument), "路径为空", std::source_location::current()};
        return std::unexpected(err);
    }
    if (path == "corrupt.txt") {
        ErrorInfo err{CustomErrc::FILE_CORRUPT, "文件损坏", std::source_location::current()};
        return std::unexpected(err);
    }
    return "Hello, C++23";
}

// 步骤2：解析文件内容（接收 string，返回 expected<int, ErrorInfo>）
std::expected<int, ErrorInfo> parse_content(const std::string& content) {
    if (content.empty()) {
        ErrorInfo err{std::make_error_code(std::errc::invalid_argument), "内容为空", std::source_location::current()};
        return std::unexpected(err);
    }
    return 42; // 模拟解析结果
}

// 步骤3：处理解析结果（接收 int，返回 expected<bool, ErrorInfo>）
std::expected<bool, ErrorInfo> process_result(int val) {
    if (val != 42) {
        ErrorInfo err{std::make_error_code(std::errc::result_out_of_range), "值非法", std::source_location::current()};
        return std::unexpected(err);
    }
    return true;
}

int main() {
    // 链式调用：read -> parse -> process
    auto final_result = read_file("corrupt.txt")
        .and_then(parse_content)    // 仅当 read 成功时执行 parse
        .and_then(process_result);  // 仅当 parse 成功时执行 process

    // 统一处理错误
    if (!final_result) {
        const ErrorInfo& err = final_result.error();
        std::cerr << "链式调用失败：" << err.ec.message() << " - " << err.detail_msg << std::endl;
    } else {
        std::cout << "链式调用成功：" << std::boolalpha << *final_result << std::endl;
    }

    return 0;
}
```

#### 输出结果：
```
链式调用失败：文件格式损坏，无法解析 - 文件损坏
```

### 4.4 std::expected vs 引用传参：核心区别
| 特性                | 引用传参（ErrorInfo&）| std::expected<T,E>                |
|---------------------|---------------------------------|-----------------------------------|
| 语义                | 输出型参数，需手动管理生命周期  | 返回值语义，自动管理内存，更直观  |
| 链式处理            | 需嵌套 if-else，代码冗余        | 支持 and_then/or_else，流式处理   |
| 类型安全            | 需手动判断错误状态              | 编译期检查，避免空指针/未初始化   |
| C++ 版本            | C++11+ 支持                     | C++23 及以上（需编译器支持）      |
| 适用场景            | 老项目兼容、需携带丰富上下文     | 新项目、追求简洁流式的错误处理    |

## 五、完整工程实践示例
### 5.1 工程结构
```
├── custom_error.h  // 自定义错误枚举、error_category、ErrorInfo
├── file_utils.cpp  // 文件操作函数（返回 std::expected）
└── main.cpp        // 主函数（调用 + 错误处理）
```

### 5.2 关键代码整合
```cpp
// custom_error.h
#pragma once
#include <system_error>
#include <string>
#include <source_location>

// 自定义错误枚举
enum class CustomErrc {
    FILE_CORRUPT = 1001,
    PARSE_FAILED = 1002,
    NETWORK_TIMEOUT = 1003
};

// 自定义错误类别
class CustomErrorCategory : public std::error_category {
public:
    const char* name() const noexcept override { return "CustomErrorCategory"; }
    std::string message(int ev) const override {
        switch (static_cast<CustomErrc>(ev)) {
            case CustomErrc::FILE_CORRUPT: return "文件格式损坏";
            case CustomErrc::PARSE_FAILED: return "数据解析失败";
            case CustomErrc::NETWORK_TIMEOUT: return "网络超时";
            default: return "未知错误: " + std::to_string(ev);
        }
    }
    static const CustomErrorCategory& instance() {
        static CustomErrorCategory inst;
        return inst;
    }
};

// 重载 make_error_code
inline std::error_code make_error_code(CustomErrc e) noexcept {
    return {static_cast<int>(e), CustomErrorCategory::instance()};
}

// 特化 is_error_code_enum
namespace std {
    template <> struct is_error_code_enum<CustomErrc> : true_type {};
}

// 错误信息结构体
struct ErrorInfo {
    std::error_code ec;
    std::string detail_msg;
    std::source_location loc;

    void clear() { ec.clear(); detail_msg.clear(); }
    explicit operator bool() const { return !ec.value() == 0; }
};

// file_utils.cpp
#include "custom_error.h"
#include <expected>
#include <string>

std::expected<std::string, ErrorInfo> read_and_parse_file(const std::string& path) {
    // 模拟文件不存在
    if (path == "nonexist.txt") {
        return std::unexpected(ErrorInfo{
            std::make_error_code(std::errc::no_such_file_or_directory),
            "文件不存在: " + path,
            std::source_location::current()
        });
    }
    // 模拟文件损坏
    if (path == "corrupt.txt") {
        return std::unexpected(ErrorInfo{
            CustomErrc::FILE_CORRUPT,
            "文件魔数错误: " + path,
            std::source_location::current()
        });
    }
    // 成功解析
    return "解析结果：{id: 1, name: \"test\"}";
}

// main.cpp
#include "custom_error.h"
#include <iostream>
#include <expected>

int main() {
    // 调用函数并处理错误
    auto result = read_and_parse_file("corrupt.txt");

    // 方式1：基础判断
    if (result) {
        std::cout << "操作成功：" << *result << std::endl;
    } else {
        const auto& err = result.error();
        std::cerr << "[错误] "
                  << err.loc.file_name() << ":" << err.loc.line() << " - "
                  << err.ec.message() << " (" << err.detail_msg << ")" << std::endl;
    }

    // 方式2：链式调用 + 错误恢复
    auto recover_result = read_and_parse_file("nonexist.txt")
        .or_else([](const ErrorInfo& err) -> std::expected<std::string, ErrorInfo> {
            // 错误恢复：返回默认值
            std::cout << "触发错误恢复：" << err.detail_msg << std::endl;
            return "默认解析结果：{}";
        });

    std::cout << "恢复后结果：" << *recover_result << std::endl;

    return 0;
}
```

### 5.3 编译与运行
```bash
# 需支持 C++23 的编译器（如 GCC 12+、Clang 15+）
g++ -std=c++23 main.cpp file_utils.cpp -o error_demo
./error_demo
```

#### 输出结果：
```
[错误] file_utils.cpp:18 - 文件格式损坏 (文件魔数错误: corrupt.txt)
触发错误恢复：文件不存在: nonexist.txt
恢复后结果：默认解析结果：{}
```

## 六、总结
1. **system_error 增强**：通过继承 `std::error_category` 可实现自定义错误枚举的消息派发，结合 `ErrorInfo` 结构体可携带丰富的错误上下文，适合多线程/复杂工程的错误传递；
2. **std::expected 核心价值**：C++23 引入的 `std::expected<T,E>` 替代“引用传错误”模式，支持链式调用（`and_then`/`or_else`），语义更清晰、类型更安全；
3. **工程实践建议**：老项目可使用 `system_error + 错误结构体` 兼容升级，新项目优先采用 `std::expected` 实现流式错误处理，同时保留错误码的类型安全和上下文信息。