# 头文件

https://www.bilibili.com/video/BV1QpWSekEJY/

```
#include <cerrno>
#include <cassert>
#include <exception>
#include <stdexcept>
#include <system_error>
#include <stacktrace>
#include <debugging>
```



# 诊断库

###  异常处理（常用于自定义异常）

头文件 [``](https://cppreference.cn/w/cpp/header/exception) 提供了几个与 C++ 程序中异常处理相关的类和函数。



| 定义于头文件 `<exception>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ exception](https://cppreference.cn/w/cpp/error/exception)  | 标准库组件抛出的异常的基类  (类)                             |
| 异常对象的捕获和存储                                         |                                                              |
| [ uncaught_exceptionuncaught_exceptions](https://cppreference.cn/w/cpp/error/uncaught_exception)(C++20* 中移除)(C++17) | 检查异常处理当前是否正在进行  (函数)                         |
| [ exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr)(C++11) | 用于处理异常对象的共享指针类型  (类型别名)                   |
| [ make_exception_ptr](https://cppreference.cn/w/cpp/error/make_exception_ptr)(C++11) | 从异常对象创建 [std::exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr)  (函数模板) |
| [ current_exception](https://cppreference.cn/w/cpp/error/current_exception)(C++11) | 在 [std::exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr) 中捕获当前异常  (函数) |
| [ rethrow_exception](https://cppreference.cn/w/cpp/error/rethrow_exception)(C++11) | 从 [std::exception_ptr](https://cppreference.cn/w/cpp/error/exception_ptr) 抛出异常  (函数) |
| [ nested_exception](https://cppreference.cn/w/cpp/error/nested_exception)(C++11) | 用于捕获和存储当前异常的混入类型  (类)                       |
| [ throw_with_nested](https://cppreference.cn/w/cpp/error/throw_with_nested)(C++11) | 抛出其参数，并混入 [std::nested_exception](https://cppreference.cn/w/cpp/error/nested_exception)  (函数模板) |
| [ rethrow_if_nested](https://cppreference.cn/w/cpp/error/rethrow_if_nested)(C++11) | 从 [std::nested_exception](https://cppreference.cn/w/cpp/error/nested_exception) 抛出异常  (函数模板) |
| 异常处理中的失败处理                                         |                                                              |
| 定义于头文件 `<exception>`                                   |                                                              |
| [ terminate](https://cppreference.cn/w/cpp/error/terminate)  | 当异常处理失败时调用的函数  (函数)                           |
| [ terminate_handler](https://cppreference.cn/w/cpp/error/terminate_handler) | 由 [std::terminate](https://cppreference.cn/w/cpp/error/terminate) 调用的函数的类型  (类型别名) |
| [ get_terminate](https://cppreference.cn/w/cpp/error/get_terminate)(C++11) | 获取当前的 terminate_handler  (函数)                         |
| [ set_terminate](https://cppreference.cn/w/cpp/error/set_terminate) | 更改要由 [std::terminate](https://cppreference.cn/w/cpp/error/terminate) 调用的函数  (函数) |
| [ bad_exception](https://cppreference.cn/w/cpp/error/bad_exception) | 当 [std::current_exception](https://cppreference.cn/w/cpp/error/current_exception) 无法复制异常对象时抛出的异常  (类) |
| 异常规范违规的处理 (直到 C++17)                              |                                                              |
| [ unexpected](https://cppreference.cn/w/cpp/error/unexpected)(在 C++11 中弃用)(在 C++17 中移除) | 当动态异常规范被违反时调用的函数  (函数)                     |
| [ unexpected_handler](https://cppreference.cn/w/cpp/error/unexpected_handler)(在 C++11 中弃用)(在 C++17 中移除) | 由 [std::unexpected](https://cppreference.cn/w/cpp/error/unexpected) 调用的函数的类型  (类型别名) |
| [ get_unexpected](https://cppreference.cn/w/cpp/error/get_unexpected)(在 C++11 中弃用)(在 C++17 中移除) | 获取当前的 `unexpected_handler`  (函数)                      |
| [ set_unexpected](https://cppreference.cn/w/cpp/error/set_unexpected)(在 C++11 中弃用)(在 C++17 中移除) | 更改要由 [std::unexpected](https://cppreference.cn/w/cpp/error/unexpected) 调用的函数  (函数) |

###  异常类别（常用于 throw异常）

头文件 `<stdexcept>` 中预定义了几个便利类，用于报告特定的错误情况。这些类可以分为两类：*逻辑*错误和*运行时*错误。逻辑错误是程序内部错误逻辑的结果，可能是可以预防的。运行时错误是由于程序范围之外的事件造成的，不易预测。

| 定义于头文件 `<stdexcept>`                                   |                                                    |
| ------------------------------------------------------------ | -------------------------------------------------- |
| [ logic_error](https://cppreference.cn/w/cpp/error/logic_error) | 异常类，指示违反逻辑前提条件或类不变量的情况  (类) |
| [ invalid_argument](https://cppreference.cn/w/cpp/error/invalid_argument) | 异常类，用于报告无效参数  (类)                     |
| [ domain_error](https://cppreference.cn/w/cpp/error/domain_error) | 异常类，用于报告域错误  (类)                       |
| [ length_error](https://cppreference.cn/w/cpp/error/length_error) | 异常类，用于报告尝试超出最大允许大小的情况  (类)   |
| [ out_of_range](https://cppreference.cn/w/cpp/error/out_of_range) | 异常类，用于报告超出预期范围的参数  (类)           |
| [ runtime_error](https://cppreference.cn/w/cpp/error/runtime_error) | 异常类，指示仅在运行时可检测到的条件  (类)         |
| [ range_error](https://cppreference.cn/w/cpp/error/range_error) | 异常类，用于报告内部计算中的范围错误  (类)         |
| [ overflow_error](https://cppreference.cn/w/cpp/error/overflow_error) | 异常类，用于报告算术溢出  (类)                     |
| [ underflow_error](https://cppreference.cn/w/cpp/error/underflow_error) | 异常类，用于报告算术下溢  (类)                     |
| [ tx_exception](https://cppreference.cn/w/cpp/error/tx_exception)(TM TS) | 异常类，用于取消原子事务  (类模板)                 |



###  错误号（见 [cdefine](./cdefine.md)的cerrno）

| 定义于头文件 `<cerrno>`                                      |                                                    |
| ------------------------------------------------------------ | -------------------------------------------------- |
| [ errno](https://cppreference.cn/w/cpp/error/errno)          | 宏，展开为 POSIX 兼容的线程局部错误号变量 (宏变量) |
| [ E2BIG, EACCES, ..., EXDEV](https://cppreference.cn/w/cpp/error/errno_macros) | 标准 POSIX 兼容错误条件的宏  (宏常量)              |



###  系统错误 (自 C++11 起)（常用于设置错误码/类别枚举使用）

头文件 `<system_error>` 定义了用于报告源自操作系统、流 I/O、[std::future](https://cppreference.cn/w/cpp/thread/future) 或其他底层 API 的错误条件的类型和函数。

| 定义于头文件 `<system_error>`                                |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ error_category](https://cppreference.cn/w/cpp/error/error_category)(C++11) | 错误类别的基类  (类)                                         |
| [ generic_category](https://cppreference.cn/w/cpp/error/generic_category)(C++11) | 标识通用错误类别  (函数)                                     |
| [ system_category](https://cppreference.cn/w/cpp/error/system_category)(C++11) | 标识操作系统错误类别  (函数)                                 |
| [ error_condition](https://cppreference.cn/w/cpp/error/error_condition)(C++11) | 持有可移植的错误码  (类)                                     |
| [ errc](https://cppreference.cn/w/cpp/error/errc)(C++11)     | [std::error_condition](https://cppreference.cn/w/cpp/error/error_condition) 枚举，列出所有标准的 [``](https://cppreference.cn/w/cpp/header/cerrno) 宏常量  (类) |
| [ error_code](https://cppreference.cn/w/cpp/error/error_code)(C++11) | 持有平台相关的错误码  (类)                                   |
| [ system_error](https://cppreference.cn/w/cpp/error/system_error)(C++11) | 用于报告具有 error_code 的条件的异常类  (类)                 |



###  断言

断言有助于在程序中实现前提条件的检查。

| 定义于头文件 `<cassert>`                              |                                                              |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| [ assert](https://cppreference.cn/w/cpp/error/assert) | 如果用户指定的条件不为 true，则中止程序。可能在发布版本中禁用。  (函数宏) |



###  [堆栈回溯](https://cppreference.cn/w/cpp/utility/basic_stacktrace) (自 C++23 起)

| 定义于头文件 `<stacktrace>`                                  |                                                  |
| ------------------------------------------------------------ | ------------------------------------------------ |
| [ stacktrace_entry](https://cppreference.cn/w/cpp/utility/stacktrace_entry)(C++23) | 堆栈回溯中求值的表示  (类)                       |
| [ basic_stacktrace](https://cppreference.cn/w/cpp/utility/basic_stacktrace)(C++23) | 调用序列的近似表示，由堆栈回溯条目组成  (类模板) |



###  调试支持 (自 C++26 起)

| 定义于头文件 `<debugging>`                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ breakpoint](https://cppreference.cn/w/cpp/utility/breakpoint)(C++26) | 调用时暂停正在运行的程序  (函数)                             |
| [ breakpoint_if_debugging](https://cppreference.cn/w/cpp/utility/breakpoint_if_debugging)(C++26) | 如果 std::is_debugger_present 返回 true，则调用 std::breakpoint  (函数) |
| [ is_debugger_present](https://cppreference.cn/w/cpp/utility/is_debugger_present)(C++26) | 检查程序是否在调试器的控制下运行  (函数)                     |

###  参见

| [`static_assert` 声明](https://cppreference.cn/w/cpp/language/static_assert) (C++11) | 执行编译时断言检查 |
| ------------------------------------------------------------ | ------------------ |
| [C 文档](https://cppreference.cn/w/c/error) 关于 错误处理    |                    |

# C语言错误处理：errno、perror与strerror详解
## 一、需求概述
你想了解C语言中`errno`在多线程环境下的使用、不借助`perror`如何打印错误码对应的详细信息、`strerror`的定义及它与`perror`的区别，同时需要明确二者的线程安全性，最终希望通过Markdown形式系统学习C语言的错误处理相关知识。

## 二、核心知识点详解
### 2.1 errno：C语言的错误码基石
#### 2.1.1 基本定义
`errno`是C标准库提供的**全局错误码变量**，本质是一个宏（并非单纯的全局变量），定义在`<errno.h>`头文件中。当系统调用或库函数执行失败时，会设置`errno`为对应的错误码（成功时不会主动清空`errno`），程序可通过读取`errno`判断错误类型。

#### 2.1.2 多线程安全性
早期`errno`是全局变量，多线程下会出现“错误码覆盖”问题（线程A设置的`errno`可能被线程B修改）。  
现代C标准（POSIX.1-2001）已将`errno`实现为**线程局部存储（TLS）**，即每个线程拥有独立的`errno`副本，因此**现代系统中errno是线程安全的**。

### 2.2 perror：一键打印错误信息
#### 2.2.1 功能与用法
`perror`是C标准库函数（定义在`<stdio.h>`），功能是：
1. 先打印自定义提示字符串；
2. 自动读取当前线程的`errno`，并打印对应的人类可读错误描述；
3. 末尾自动加换行。

**示例代码**：
```c
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    // 尝试打开不存在的文件，触发错误
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        // 打印格式：自定义字符串: 错误描述
        perror("open file failed");
    }
    close(fd);
    return 0;
}
```
**输出示例**：
```
open file failed: No such file or directory
```

#### 2.2.2 线程安全性
`perror`本身是线程安全的：它读取的是当前线程的`errno`（TLS），且打印过程不会与其他线程的`perror`输出混乱（标准IO的打印是原子操作）。

### 2.3 strerror：手动获取错误描述字符串
#### 2.3.1 功能与用法
`strerror`是C标准库函数（定义在`<string.h>`），接收一个错误码（如`errno`）作为参数，返回该错误码对应的**字符串描述**（无换行）。  
开发者可通过`printf`等函数自定义打印格式，替代`perror`。

**示例代码**：
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        // 手动拼接错误信息，替代perror
        printf("open file failed: %s (errno: %d)\n", strerror(errno), errno);
    }
    close(fd);
    return 0;
}
```
**输出示例**：
```
open file failed: No such file or directory (errno: 2)
```

#### 2.3.2 线程安全性
- 传统`strerror`：返回的是静态字符串缓冲区，多线程同时调用时可能被覆盖（非线程安全）；
- 现代改进版`strerror_r`：POSIX标准提供的线程安全版本（分为XSI和POSIX两种实现），需传入自定义缓冲区存储错误描述，避免竞争。

**strerror_r示例（POSIX版）**：
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        char err_buf[1024]; // 自定义缓冲区
        // 线程安全的错误描述获取
        strerror_r(errno, err_buf, sizeof(err_buf));
        printf("open file failed: %s (errno: %d)\n", err_buf, errno);
    }
    close(fd);
    return 0;
}
```

### 2.4 perror与strerror的核心区别
| 特性                | perror                          | strerror                          |
|---------------------|---------------------------------|-----------------------------------|
| 线程安全 | 安全 | 不安全（`strerror_r`是线程安全的） |
| 输出方式            | 直接打印到标准错误（stderr）    | 返回字符串，需手动打印（可自定义输出目标） |
| 格式                | 固定：自定义字符串 + 错误描述 + 换行 | 完全自定义（可拼接errno、其他信息） |
| 缓冲区              | 内部处理，无暴露                | 传统版用静态缓冲区（非线程安全），strerror_r用自定义缓冲区 |
| 依赖                | 依赖当前线程的errno             | 可传入任意错误码（不一定是errno） |
| 示例输出            | `open failed: No such file`     | 需配合printf：`open failed(errno=2): No such file` |

### 2.5 不使用perror打印错误信息的其他方式
除了`strerror`/`strerror_r`，还可直接通过`errno`值手动映射错误描述（不推荐，仅作了解）：
```c
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

const char* get_error_desc(int err) {
    switch(err) {
        case 2: return "No such file or directory";
        case 13: return "Permission denied";
        default: return "Unknown error";
    }
}

int main() {
    int fd = open("nonexist.txt", O_RDONLY);
    if (fd == -1) {
        printf("open failed: %s (errno: %d)\n", get_error_desc(errno), errno);
    }
    close(fd);
    return 0;
}
```
**缺点**：需要手动维护错误码与描述的映射表，跨平台兼容性差（不同系统errno值可能不同），远不如`strerror`灵活。

## 三、C语言错误处理最佳实践
### 3.1 基础原则
1. 函数执行失败时，优先通过返回值（如-1、NULL）标识，再通过`errno`细化错误类型；
2. 多线程中优先使用`strerror_r`替代`strerror`，保证线程安全；
3. 打印错误信息时，建议同时输出`errno`数值和描述，便于定位问题。

### 3.2 完整示例（多线程+错误处理）
```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include <fcntl.h>
#include <unistd.h>

#define THREAD_NUM 2

// 线程函数：尝试打开不同文件，打印错误信息
void* thread_func(void* arg) {
    char* filename = (char*)arg;
    int fd = open(filename, O_RDONLY);
    
    if (fd == -1) {
        char err_buf[1024];
        // 线程安全的错误描述获取
        strerror_r(errno, err_buf, sizeof(err_buf));
        // 打印线程ID、错误信息、errno
        printf("Thread %ld: open %s failed: %s (errno: %d)\n", 
               pthread_self(), filename, err_buf, errno);
        pthread_exit(NULL);
    }
    
    printf("Thread %ld: open %s success\n", pthread_self(), filename);
    close(fd);
    pthread_exit(NULL);
}

int main() {
    pthread_t tid[THREAD_NUM];
    char* filenames[] = {"nonexist.txt", "test.txt"}; // 一个不存在，一个可能存在
    
    // 创建2个线程
    for (int i = 0; i < THREAD_NUM; i++) {
        if (pthread_create(&tid[i], NULL, thread_func, filenames[i]) != 0) {
            perror("pthread_create failed");
            return 1;
        }
    }
    
    // 等待线程结束
    for (int i = 0; i < THREAD_NUM; i++) {
        pthread_join(tid[i], NULL);
    }
    
    return 0;
}
```
**编译运行**：
```bash
# 编译时链接pthread库
gcc -o error_demo error_demo.c -pthread
./error_demo
```
**输出示例**：
```
Thread 140709267246848: open nonexist.txt failed: No such file or directory (errno: 2)
Thread 140709258854144: open test.txt success
```

## 四、总结
1. **errno**：现代系统中是线程局部存储（TLS），每个线程独立，线程安全；函数失败时设置，成功时不清空，需结合返回值判断是否出错。
2. **perror**：直接打印错误信息（自定义字符串+errno描述），线程安全，输出到stderr，格式固定；
3. **strerror**：返回错误码对应的字符串描述，需手动打印，传统版非线程安全，推荐使用线程安全的`strerror_r`；
4. 多线程错误处理核心：优先用`strerror_r`获取错误描述，同时输出`errno`数值和上下文信息，便于问题定位。

# C++ 现代化错误处理：system_error 增强与 std::expected 详解
## 一、需求概述
系统学习 C++ 中基于 `system_error` 的增强型错误处理方案，包括：使用 `std::errc` 标准枚举、自定义错误枚举、通过继承 `std::error_category` 实现自定义错误信息派发、基于结构体传递错误信息；同时了解 C++23 引入的 `std::expected`，掌握其替代引用传参的错误返回方式，以及链式调用等高级特性。

## 二、核心概念与基础铺垫
### 2.1 C++ 原生错误处理的痛点
C 语言的 `errno`/`perror` 存在类型不安全、错误信息耦合度高的问题；早期 C++ 依赖异常（`throw`/`catch`）但存在性能开销，且无法直观区分“预期错误”和“程序异常”。  
C++11 引入 `std::system_error` 体系，通过**错误码（error_code）**、**错误类别（error_category）**、**错误条件（error_condition）** 三层架构，实现类型安全的错误处理，C++23 进一步推出 `std::expected`，解决“返回值+错误码”分离的问题。

### 2.2 核心组件速览
| 组件                | 作用                                                                 |
|---------------------|----------------------------------------------------------------------|
| `std::errc`         | 标准错误枚举（对应 POSIX 错误码），类型安全的 `errno` 替代           |
| `std::error_category` | 错误类别基类，定义错误码的命名空间、消息格式，可继承实现自定义类别    |
| `std::error_code`   | 错误码对象（包含数值 + 错误类别），可隐式转换为 `error_condition`    |
| `std::error_condition` | 错误条件（逻辑错误类型），用于跨类别匹配错误                         |
| `std::system_error` | 封装 `error_code` 的异常类型，可抛出或存储错误信息                   |
| `std::expected<T,E>` | C++23 核心，存储“预期返回值 T”或“错误 E”，替代“输出参数传错误”       |

## 三、基于 system_error 的增强型错误处理
### 3.1 基础用法：使用 std::errc 标准枚举
`std::errc` 是 C++11 提供的枚举类型，覆盖常见系统错误（如文件不存在、权限拒绝等），结合 `std::error_code` 可实现类型安全的错误表示。

#### 示例代码：标准错误码使用
```cpp
#include <iostream>
#include <system_error>
#include <fstream>

// 检查文件打开错误
bool open_file(const std::string& path) {
    std::ifstream file(path);
    if (!file.is_open()) {
        // 构造标准错误码：使用 std::errc::no_such_file_or_directory
        std::error_code ec = std::make_error_code(std::errc::no_such_file_or_directory);
        std::cout << "错误码：" << ec.value() << "\n"
                  << "错误类别：" << ec.category().name() << "\n"
                  << "错误信息：" << ec.message() << std::endl;
        return false;
    }
    return true;
}

int main() {
    open_file("nonexist.txt");
    return 0;
}
```

#### 输出结果：
```
错误码：2
错误类别：generic
错误信息：No such file or directory
```

### 3.2 进阶：自定义错误枚举与 error_category
#### 3.2.1 核心思路
1. 定义**强类型枚举**表示自定义错误（避免与系统错误码冲突）；
2. 继承 `std::error_category`，重载 `name()`、`message()`、`default_error_condition()` 等方法，实现错误信息的自定义派发；
3. 重载 `std::make_error_code`，让自定义枚举可隐式转换为 `std::error_code`。

#### 3.2.2 完整实现代码
```cpp
#include <iostream>
#include <system_error>
#include <string>
#include <unordered_map>

// 步骤1：定义自定义错误枚举（强类型，避免命名冲突）
enum class CustomErrc {
    FILE_CORRUPT = 1001,    // 文件损坏
    PARSE_FAILED = 1002,    // 解析失败
    NETWORK_TIMEOUT = 1003  // 网络超时
};

// 步骤2：继承 error_category 实现自定义错误类别
class CustomErrorCategory : public std::error_category {
public:
    // 返回错误类别名称（唯一标识）
    const char* name() const noexcept override {
        return "CustomErrorCategory";
    }

    // 核心：根据错误码派发不同的错误消息（支持函数签名级别的定制）
    std::string message(int ev) const override {
        // 将 int 转换为自定义枚举
        CustomErrc err = static_cast<CustomErrc>(ev);
        // 按错误类型派发不同的消息生成逻辑
        switch (err) {
            case CustomErrc::FILE_CORRUPT:
                return "文件格式损坏，无法解析";
            case CustomErrc::PARSE_FAILED:
                return "数据解析失败，字段格式不合法";
            case CustomErrc::NETWORK_TIMEOUT:
                return "网络请求超时，超过30秒未响应";
            default:
                return "未知自定义错误: " + std::to_string(ev);
        }
    }

    // 可选：映射到标准错误条件（便于跨类别匹配）
    std::error_condition default_error_condition(int ev) const noexcept override {
        CustomErrc err = static_cast<CustomErrc>(ev);
        switch (err) {
            case CustomErrc::NETWORK_TIMEOUT:
                // 映射到标准的超时错误
                return std::error_condition(std::errc::timed_out);
            default:
                return std::error_condition(ev, *this);
        }
    }

    // 单例模式：避免重复创建类别对象
    static const CustomErrorCategory& instance() {
        static CustomErrorCategory instance;
        return instance;
    }
};

// 步骤3：重载 make_error_code，让自定义枚举可转换为 error_code
std::error_code make_error_code(CustomErrc e) noexcept {
    return {static_cast<int>(e), CustomErrorCategory::instance()};
}

// 步骤4：特化 is_error_code_enum，让编译器识别自定义枚举为错误码类型
namespace std {
    template <>
    struct is_error_code_enum<CustomErrc> : true_type {};
}

// 测试自定义错误码
void test_custom_error(CustomErrc err) {
    std::error_code ec = err; // 隐式转换（依赖上述重载）
    std::cout << "自定义错误码：" << ec.value() << "\n"
              << "错误类别：" << ec.category().name() << "\n"
              << "错误信息：" << ec.message() << "\n"
              << "是否超时：" << (ec == std::errc::timed_out ? "是" : "否") << std::endl;
}

int main() {
    test_custom_error(CustomErrc::NETWORK_TIMEOUT);
    test_custom_error(CustomErrc::FILE_CORRUPT);
    return 0;
}
```

#### 输出结果：
```
自定义错误码：1003
错误类别：CustomErrorCategory
错误信息：网络请求超时，超过30秒未响应
是否超时：是
自定义错误码：1001
错误类别：CustomErrorCategory
错误信息：文件格式损坏，无法解析
是否超时：否
```

### 3.3 错误信息结构体：统一传递错误上下文
为了携带更丰富的错误信息（如错误码、详细描述、发生位置），可定义结构体封装错误，通过**引用传递**给函数，实现错误信息的“输出型参数”。

#### 示例代码：自定义错误结构体
```cpp
#include <iostream>
#include <system_error>
#include <string>
#include <source_location> // C++20 源位置

// 定义错误信息结构体：包含错误码、详细消息、发生位置
struct ErrorInfo {
    std::error_code ec;          // 错误码（兼容标准/自定义）
    std::string detail_msg;      // 扩展详细消息
    std::source_location loc;    // 错误发生的文件/行号（C++20）

    // 重置错误（标记为无错误）
    void clear() {
        ec.clear();
        detail_msg.clear();
    }

    // 判断是否有错误
    explicit operator bool() const {
        return !ec.value() == 0; // ec.value()=0 表示无错误
    }
};

// 模拟解析文件函数：通过引用传递 ErrorInfo 输出错误
bool parse_file(const std::string& path, ErrorInfo& err) {
    // 重置之前的错误
    err.clear();

    // 模拟文件损坏错误
    if (path == "corrupt.txt") {
        err.ec = CustomErrc::FILE_CORRUPT;
        err.detail_msg = "文件 " + path + " 的头部魔数错误（应为 0x1234，实际为 0x5678）";
        err.loc = std::source_location::current(); // 记录当前位置
        return false;
    }

    return true;
}

// 外部调用：判断错误并处理
int main() {
    ErrorInfo err;
    std::string file_path = "corrupt.txt";

    if (!parse_file(file_path, err)) {
        // 错误处理：打印日志 + 中断/忽略
        std::cerr << "[错误] 位置：" << err.loc.file_name() << ":" << err.loc.line() << "\n"
                  << "错误码：" << err.ec.value() << " (" << err.ec.message() << ")\n"
                  << "详细信息：" << err.detail_msg << std::endl;

        // 可选：中断程序（return 1）或忽略继续执行
        // return 1;
    }

    std::cout << "程序继续执行..." << std::endl;
    return 0;
}
```

#### 输出结果：
```
[错误] 位置：main.cpp:45:
错误码：1001 (文件格式损坏，无法解析)
详细信息：文件 corrupt.txt 的头部魔数错误（应为 0x1234，实际为 0x5678）
程序继续执行...
```

## 四、C++23 std::expected：替代引用传参的现代化方案
### 4.1 std::expected 核心优势
`std::expected<T, E>` 是 C++23 引入的“预期值”类型，本质是类型安全的 `std::variant<T, E>`，但专为错误处理设计：
- 替代“返回值 + 引用传错误”的模式，函数直接返回 `std::expected`；
- 支持**链式调用**（`and_then`/`or_else`），简化错误处理流程；
- 无需手动管理错误结构体的生命周期，语义更清晰。

### 4.2 基础用法：返回预期值或错误
```cpp
#include <iostream>
#include <expected>   // C++23 头文件
#include <string>
#include "custom_error.h" // 包含前文的 CustomErrc 和 ErrorInfo

// 模拟读取文件内容：返回 std::expected（成功返回 string，失败返回 ErrorInfo）
std::expected<std::string, ErrorInfo> read_file(const std::string& path) {
    if (path == "corrupt.txt") {
        // 失败：返回错误信息
        ErrorInfo err;
        err.ec = CustomErrc::FILE_CORRUPT;
        err.detail_msg = "文件 " + path + " 损坏";
        err.loc = std::source_location::current();
        return std::unexpected(err); // 标记为“非预期值”（错误）
    }

    // 成功：返回文件内容
    return "文件内容：Hello World";
}

int main() {
    auto result = read_file("corrupt.txt");

    // 方式1：直接判断是否有值
    if (result) {
        std::cout << "读取成功：" << *result << std::endl;
    } else {
        // 获取错误信息
        const ErrorInfo& err = result.error();
        std::cerr << "读取失败：" << err.ec.message() << " - " << err.detail_msg << std::endl;
    }

    return 0;
}
```

### 4.3 高级用法：链式调用处理
`std::expected` 提供 `and_then`（成功时执行）、`or_else`（失败时执行）、`transform`（转换成功值）等方法，实现流式错误处理。

#### 示例代码：链式调用
```cpp
#include <iostream>
#include <expected>
#include <string>
#include <functional>

// 步骤1：读取文件（返回 expected<string, ErrorInfo>）
std::expected<std::string, ErrorInfo> read_file(const std::string& path) {
    if (path.empty()) {
        ErrorInfo err{std::make_error_code(std::errc::invalid_argument), "路径为空", std::source_location::current()};
        return std::unexpected(err);
    }
    if (path == "corrupt.txt") {
        ErrorInfo err{CustomErrc::FILE_CORRUPT, "文件损坏", std::source_location::current()};
        return std::unexpected(err);
    }
    return "Hello, C++23";
}

// 步骤2：解析文件内容（接收 string，返回 expected<int, ErrorInfo>）
std::expected<int, ErrorInfo> parse_content(const std::string& content) {
    if (content.empty()) {
        ErrorInfo err{std::make_error_code(std::errc::invalid_argument), "内容为空", std::source_location::current()};
        return std::unexpected(err);
    }
    return 42; // 模拟解析结果
}

// 步骤3：处理解析结果（接收 int，返回 expected<bool, ErrorInfo>）
std::expected<bool, ErrorInfo> process_result(int val) {
    if (val != 42) {
        ErrorInfo err{std::make_error_code(std::errc::result_out_of_range), "值非法", std::source_location::current()};
        return std::unexpected(err);
    }
    return true;
}

int main() {
    // 链式调用：read -> parse -> process
    auto final_result = read_file("corrupt.txt")
        .and_then(parse_content)    // 仅当 read 成功时执行 parse
        .and_then(process_result);  // 仅当 parse 成功时执行 process

    // 统一处理错误
    if (!final_result) {
        const ErrorInfo& err = final_result.error();
        std::cerr << "链式调用失败：" << err.ec.message() << " - " << err.detail_msg << std::endl;
    } else {
        std::cout << "链式调用成功：" << std::boolalpha << *final_result << std::endl;
    }

    return 0;
}
```

#### 输出结果：
```
链式调用失败：文件格式损坏，无法解析 - 文件损坏
```

### 4.4 std::expected vs 引用传参：核心区别
| 特性                | 引用传参（ErrorInfo&）| std::expected<T,E>                |
|---------------------|---------------------------------|-----------------------------------|
| 语义                | 输出型参数，需手动管理生命周期  | 返回值语义，自动管理内存，更直观  |
| 链式处理            | 需嵌套 if-else，代码冗余        | 支持 and_then/or_else，流式处理   |
| 类型安全            | 需手动判断错误状态              | 编译期检查，避免空指针/未初始化   |
| C++ 版本            | C++11+ 支持                     | C++23 及以上（需编译器支持）      |
| 适用场景            | 老项目兼容、需携带丰富上下文     | 新项目、追求简洁流式的错误处理    |

## 五、完整工程实践示例
### 5.1 工程结构
```
├── custom_error.h  // 自定义错误枚举、error_category、ErrorInfo
├── file_utils.cpp  // 文件操作函数（返回 std::expected）
└── main.cpp        // 主函数（调用 + 错误处理）
```

### 5.2 关键代码整合
```cpp
// custom_error.h
#pragma once
#include <system_error>
#include <string>
#include <source_location>

// 自定义错误枚举
enum class CustomErrc {
    FILE_CORRUPT = 1001,
    PARSE_FAILED = 1002,
    NETWORK_TIMEOUT = 1003
};

// 自定义错误类别
class CustomErrorCategory : public std::error_category {
public:
    const char* name() const noexcept override { return "CustomErrorCategory"; }
    std::string message(int ev) const override {
        switch (static_cast<CustomErrc>(ev)) {
            case CustomErrc::FILE_CORRUPT: return "文件格式损坏";
            case CustomErrc::PARSE_FAILED: return "数据解析失败";
            case CustomErrc::NETWORK_TIMEOUT: return "网络超时";
            default: return "未知错误: " + std::to_string(ev);
        }
    }
    static const CustomErrorCategory& instance() {
        static CustomErrorCategory inst;
        return inst;
    }
};

// 重载 make_error_code
inline std::error_code make_error_code(CustomErrc e) noexcept {
    return {static_cast<int>(e), CustomErrorCategory::instance()};
}

// 特化 is_error_code_enum
namespace std {
    template <> struct is_error_code_enum<CustomErrc> : true_type {};
}

// 错误信息结构体
struct ErrorInfo {
    std::error_code ec;
    std::string detail_msg;
    std::source_location loc;

    void clear() { ec.clear(); detail_msg.clear(); }
    explicit operator bool() const { return !ec.value() == 0; }
};

// file_utils.cpp
#include "custom_error.h"
#include <expected>
#include <string>

std::expected<std::string, ErrorInfo> read_and_parse_file(const std::string& path) {
    // 模拟文件不存在
    if (path == "nonexist.txt") {
        return std::unexpected(ErrorInfo{
            std::make_error_code(std::errc::no_such_file_or_directory),
            "文件不存在: " + path,
            std::source_location::current()
        });
    }
    // 模拟文件损坏
    if (path == "corrupt.txt") {
        return std::unexpected(ErrorInfo{
            CustomErrc::FILE_CORRUPT,
            "文件魔数错误: " + path,
            std::source_location::current()
        });
    }
    // 成功解析
    return "解析结果：{id: 1, name: \"test\"}";
}

// main.cpp
#include "custom_error.h"
#include <iostream>
#include <expected>

int main() {
    // 调用函数并处理错误
    auto result = read_and_parse_file("corrupt.txt");

    // 方式1：基础判断
    if (result) {
        std::cout << "操作成功：" << *result << std::endl;
    } else {
        const auto& err = result.error();
        std::cerr << "[错误] "
                  << err.loc.file_name() << ":" << err.loc.line() << " - "
                  << err.ec.message() << " (" << err.detail_msg << ")" << std::endl;
    }

    // 方式2：链式调用 + 错误恢复
    auto recover_result = read_and_parse_file("nonexist.txt")
        .or_else([](const ErrorInfo& err) -> std::expected<std::string, ErrorInfo> {
            // 错误恢复：返回默认值
            std::cout << "触发错误恢复：" << err.detail_msg << std::endl;
            return "默认解析结果：{}";
        });

    std::cout << "恢复后结果：" << *recover_result << std::endl;

    return 0;
}
```

### 5.3 编译与运行
```bash
# 需支持 C++23 的编译器（如 GCC 12+、Clang 15+）
g++ -std=c++23 main.cpp file_utils.cpp -o error_demo
./error_demo
```

#### 输出结果：
```
[错误] file_utils.cpp:18 - 文件格式损坏 (文件魔数错误: corrupt.txt)
触发错误恢复：文件不存在: nonexist.txt
恢复后结果：默认解析结果：{}
```

## 六、总结
1. **system_error 增强**：通过继承 `std::error_category` 可实现自定义错误枚举的消息派发，结合 `ErrorInfo` 结构体可携带丰富的错误上下文，适合多线程/复杂工程的错误传递；
2. **std::expected 核心价值**：C++23 引入的 `std::expected<T,E>` 替代“引用传错误”模式，支持链式调用（`and_then`/`or_else`），语义更清晰、类型更安全；
3. **工程实践建议**：老项目可使用 `system_error + 错误结构体` 兼容升级，新项目优先采用 `std::expected` 实现流式错误处理，同时保留错误码的类型安全和上下文信息。

# C++ 异常处理完全指南：从基础语法到高性能实践
## 一、需求概述
系统学习 C++ 异常处理的核心知识点，包括：`throw` 抛出任意类型异常、`try-catch` 多类型捕获与异常重抛、`catch(...)` 万能捕获、`std::current_exception`/`std::rethrow_exception` 的使用；重点理解**值捕获导致的对象切片（object slicing）** 问题及 `const&` 捕获的必要性、`std::exception::what()` 返回 `const char*` 的设计原因；同时掌握 `noexcept` 关键字的作用、性能影响及使用场景，所有知识点需配套代码示例和详细文字说明。

## 二、C++ 异常处理基础语法
### 2.1 throw：抛出任意类型的异常
C++ 中 `throw` 是异常触发关键字，**可抛出任意类型**（内置类型、自定义类型、标准异常类型等），抛出后程序立即终止当前函数执行，跳转到最近的匹配 `catch` 块。

#### 示例：抛出不同类型的异常
```cpp
#include <iostream>
#include <string>

void throw_different_types(int type) {
    switch (type) {
        case 1:
            throw 404; // 抛出内置类型（int）
            break;
        case 2:
            throw std::string("字符串类型异常"); // 抛出标准库类型
            break;
        case 3:
            throw "字面量异常"; // 抛出 const char* 类型
            break;
        default:
            throw std::runtime_error("标准异常类型"); // 抛出 std::exception 子类
    }
}

int main() {
    try {
        throw_different_types(1);
    } catch (int e) {
        std::cout << "捕获 int 异常：" << e << std::endl;
    } catch (const std::string& e) {
        std::cout << "捕获 string 异常：" << e << std::endl;
    } catch (const char* e) {
        std::cout << "捕获 const char* 异常：" << e << std::endl;
    } catch (const std::exception& e) {
        std::cout << "捕获 std::exception 异常：" << e.what() << std::endl;
    }
    return 0;
}
```

#### 关键说明：
- `throw` 抛出的异常类型需与 `catch` 的参数类型匹配（精确匹配或向上转型）；
- 抛出的异常对象会被**拷贝**到异常存储区（编译器管理的内存区域），即使原对象超出作用域，异常对象仍有效。

### 2.2 try-catch：多类型捕获与异常处理
`try` 块包裹可能抛出异常的代码，`catch` 块按**从上到下**的顺序匹配异常类型，匹配成功后执行对应处理逻辑，未匹配则继续向上层调用栈传播。

#### 示例：多类型捕获与异常重抛
```cpp
#include <iostream>
#include <stdexcept>

// 子函数：抛出异常并演示重抛
void sub_func() {
    try {
        throw std::out_of_range("数组下标越界"); // 抛出具体异常
    } catch (const std::out_of_range& e) {
        std::cout << "子函数捕获异常：" << e.what() << "，准备重抛" << std::endl;
        throw; // 重抛当前异常（无参数，保留原始异常类型）
        // 错误写法：throw e; // 会拷贝为 std::out_of_range 类型，丢失原始上下文（若有）
    }
}

int main() {
    try {
        sub_func();
    } catch (const std::out_of_range& e) { // 精准捕获子类异常
        std::cout << "主函数捕获 out_of_range 异常：" << e.what() << std::endl;
    } catch (const std::exception& e) { // 兜底捕获父类异常
        std::cout << "主函数捕获 exception 异常：" << e.what() << std::endl;
    } catch (...) { // 万能捕获：捕获所有未匹配的异常
        std::cout << "主函数捕获未知类型异常" << std::endl;
    }
    return 0;
}
```

#### 输出结果：
```
子函数捕获异常：数组下标越界，准备重抛
主函数捕获 out_of_range 异常：数组下标越界
```

#### 关键说明：
1. **异常重抛**：`throw;` 会原样抛出当前捕获的异常（保留类型和上下文），而 `throw e;` 会创建新的异常对象（可能丢失子类信息）；
2. **catch(...)**：万能捕获块，可捕获所有类型的异常（包括未继承 `std::exception` 的自定义类型），通常用于兜底处理（如日志记录）；
3. **捕获顺序**：需先捕获**子类异常**，再捕获父类异常（否则子类异常会被父类捕获块拦截）。

### 2.3 std::current_exception 与 std::rethrow_exception
当需要**暂存异常**（如异步处理、延迟抛出）时，可使用 `std::current_exception()` 获取当前异常的智能指针（`std::exception_ptr`），后续通过 `std::rethrow_exception()` 重新抛出。

#### 示例：暂存并延迟抛出异常
```cpp
#include <iostream>
#include <exception>
#include <stdexcept>

// 全局变量：暂存异常指针
std::exception_ptr g_exception_ptr = nullptr;

void store_exception() {
    try {
        throw std::logic_error("逻辑错误：参数不合法");
    } catch (...) {
        // 捕获所有异常并暂存
        g_exception_ptr = std::current_exception();
        std::cout << "异常已暂存" << std::endl;
    }
}

void rethrow_stored_exception() {
    if (g_exception_ptr) {
        std::cout << "重新抛出暂存的异常" << std::endl;
        std::rethrow_exception(g_exception_ptr); // 重新抛出
    }
}

int main() {
    store_exception();

    try {
        rethrow_stored_exception();
    } catch (const std::logic_error& e) {
        std::cout << "捕获暂存的异常：" << e.what() << std::endl;
    }

    return 0;
}
```

#### 输出结果：
```
异常已暂存
重新抛出暂存的异常
捕获暂存的异常：逻辑错误：参数不合法
```

#### 关键说明：
- `std::exception_ptr` 是轻量级智能指针，可安全拷贝和存储，空指针表示无异常；
- 即使暂存的异常类型未继承 `std::exception`，`rethrow_exception` 仍能正确抛出。

## 三、核心陷阱：值捕获导致的对象切片（Object Slicing）
### 3.1 什么是对象切片？
当使用**值捕获**（而非引用）捕获子类异常时，子类对象会被“切片”为父类对象——子类特有的成员变量和虚函数实现会丢失，仅保留父类部分，导致异常信息错误。

### 3.2 示例：值捕获的切片问题
```cpp
#include <iostream>
#include <exception>
#include <string>

// 自定义异常子类：继承 std::exception
class MyException : public std::exception {
private:
    std::string m_msg; // 子类特有成员
    int m_error_code;  // 子类特有成员
public:
    MyException(const std::string& msg, int code) 
        : m_msg(msg), m_error_code(code) {}

    // 重写虚函数 what()
    const char* what() const noexcept override {
        // 拼接自定义消息（注意：此处仅为演示，实际需避免动态内存分配）
        static std::string full_msg = "MyException: " + m_msg + " (code: " + std::to_string(m_error_code) + ")";
        return full_msg.c_str();
    }

    // 子类特有方法
    int get_error_code() const { return m_error_code; }
};

int main() {
    // 场景1：值捕获（对象切片）
    try {
        throw MyException("文件读取失败", 500);
    } catch (std::exception e) { // 值捕获：e 是 std::exception 类型
        std::cout << "值捕获 what()：" << e.what() << std::endl;
        // 无法调用子类方法：e.get_error_code() 编译报错
        // std::cout << "错误码：" << e.get_error_code() << std::endl;
    }

    // 场景2：const& 捕获（无切片）
    try {
        throw MyException("网络连接失败", 600);
    } catch (const std::exception& e) { // 常量引用捕获：指向子类对象
        std::cout << "const& 捕获 what()：" << e.what() << std::endl;
        // 向下转型获取子类方法（需确保类型匹配）
        if (const MyException* me = dynamic_cast<const MyException*>(&e)) {
            std::cout << "错误码：" << me->get_error_code() << std::endl;
        }
    }

    return 0;
}
```

#### 输出结果：
```
值捕获 what()：std::exception  // 切片后仅保留父类的 what() 实现
const& 捕获 what()：MyException: 网络连接失败 (code: 600)
错误码：600
```

### 3.3 切片问题的底层原因
1. **内存布局**：值捕获时，编译器会创建一个 `std::exception` 类型的对象，将子类对象的父类部分拷贝进去，子类特有的 `m_msg`、`m_error_code` 被截断；
2. **虚函数表**：值捕获的对象是父类类型，其虚函数表指向 `std::exception` 的 `what()`，而非子类重写的版本；
3. **const& 捕获的优势**：引用本质是指针，直接指向异常存储区中的子类对象，虚函数表仍指向子类的 `what()`，且避免了对象拷贝，效率更高。

### 3.4 最佳实践：捕获异常的正确方式
```cpp
// 错误写法（值捕获）
catch (std::exception e) {}

// 正确写法（const& 捕获）
catch (const std::exception& e) {}

// 若需修改异常对象（极少场景），可使用非 const 引用
catch (std::exception& e) {}
```

## 四、std::exception::what() 设计细节：为何返回 const char*？
### 4.1 核心原因：异常安全
`what()` 方法返回 `const char*` 而非 `std::string`，核心是避免**二次异常**：
- 若 `what()` 返回 `std::string`，则需要构造 `std::string` 对象；
- `std::string` 的构造/析构可能涉及动态内存分配（`new/delete`），而异常发生时，内存分配可能失败（如内存耗尽），导致抛出新的 `std::bad_alloc` 异常；
- `const char*` 通常指向静态字面量或预分配的字符数组，不涉及动态内存操作，保证异常信息能稳定输出。

### 4.2 注意事项：避免返回局部变量的指针
```cpp
// 错误示例：局部变量销毁后，指针悬空
const char* what() const noexcept override {
    std::string msg = "错误：" + m_msg;
    return msg.c_str(); // msg 是局部变量，函数结束后销毁，返回野指针
}

// 正确示例1：使用静态缓冲区
const char* what() const noexcept override {
    static char buf[1024]; // 静态缓冲区，生命周期贯穿程序
    snprintf(buf, sizeof(buf), "错误：%s (码：%d)", m_msg.c_str(), m_error_code);
    return buf;
}

// 正确示例2：使用类成员的 const char*
class MyException : public std::exception {
private:
    const char* m_msg; // 指向常量字符串
public:
    MyException(const char* msg) : m_msg(msg) {}
    const char* what() const noexcept override { return m_msg; }
};
```

### 4.3 补充说明：what() 的 noexcept 特性
`what()` 方法被声明为 `noexcept`，这是因为：若 `what()` 本身抛出异常，会导致程序直接终止（异常处理过程中不能嵌套异常）。

## 五、noexcept 关键字：性能与异常安全的平衡
### 5.1 noexcept 的基本用法
`noexcept` 是 C++11 引入的关键字，用于声明函数**是否可能抛出异常**：
- `noexcept` / `noexcept(true)`：函数绝对不会抛出异常；
- `noexcept(false)`：函数可能抛出异常（默认值，可省略）。

#### 示例：noexcept 的基本使用
```cpp
#include <iostream>

// 声明为 noexcept(true)：不会抛出异常
void safe_func() noexcept {
    std::cout << "安全函数：不会抛出异常" << std::endl;
    // 若此处抛出异常，程序会直接终止（std::terminate）
    // throw std::runtime_error("意外异常");
}

// 未声明 noexcept：默认 noexcept(false)
void unsafe_func() {
    throw std::runtime_error("不安全函数：抛出异常");
}

int main() {
    try {
        safe_func();
        unsafe_func();
    } catch (const std::exception& e) {
        std::cout << "捕获异常：" << e.what() << std::endl;
    }
    return 0;
}
```

### 5.2 noexcept 的性能优势
编译器对 `noexcept(true)` 的函数会进行深度优化，核心原因是：
1. **代码生成策略**：
   - `noexcept(false)` 函数：编译器会生成两份代码——
     - **Hot 路径**：正常执行逻辑（无异常）；
     - **Cold 路径**：异常处理逻辑（极少执行，但占用二进制空间，且分支预测成本高）；
   - `noexcept(true)` 函数：编译器仅生成 Hot 路径代码，无需处理异常，二进制体积更小，执行效率更高。
2. **优化假设**：编译器可假设 `noexcept(true)` 函数不会抛出异常，因此可省略异常清理逻辑（如栈展开），进一步提升性能。

### 5.3 noexcept 的异常处理行为
- 若 `noexcept(true)` 函数内抛出异常，程序会直接调用 `std::terminate()` 终止，**外部 catch 无法捕获**；
- 若需兼容旧代码，可在 `noexcept(true)` 函数内捕获所有异常并处理，避免程序终止：

```cpp
void safe_func() noexcept {
    try {
        // 可能抛出异常的操作
        int a = 1 / 0;
    } catch (...) {
        std::cerr << "内部捕获异常，避免程序终止" << std::endl;
    }
}
```

### 5.4 noexcept 的适用场景
| 场景                          | 是否使用 noexcept(true) | 原因                                                                 |
|-------------------------------|-------------------------|----------------------------------------------------------------------|
| 数学运算（如加减乘除、排序）| 是                      | 逻辑上不会抛出异常，优化性能                                         |
| 析构函数                      | 是（C++11 后默认）| 析构函数抛出异常会导致程序终止，且需保证资源释放的可靠性             |
| 移动构造/移动赋值函数         | 是                      | 容器（如 std::vector）会优先使用 noexcept 的移动函数，提升效率       |
| IO 操作（文件/网络）| 否                      | 可能抛出 IO 异常，需外部处理                                         |
| 动态内存分配（new/delete）| 否                      | 可能抛出 std::bad_alloc，需外部捕获                                   |

## 六、完整示例：异常处理最佳实践整合
```cpp
#include <iostream>
#include <exception>
#include <stdexcept>
#include <string>
#include <cstring>

// 自定义异常类：遵循最佳实践
class FileException : public std::exception {
private:
    const char* m_filename;
    int m_error_code;
    mutable char m_what_buf[256]; // 可变缓冲区（what() 是 const 方法）
public:
    FileException(const char* filename, int code) 
        : m_filename(filename), m_error_code(code) {}

    // 重写 what()：返回 const char*，noexcept，无动态内存分配
    const char* what() const noexcept override {
        snprintf(m_what_buf, sizeof(m_what_buf), 
                 "文件异常：%s (错误码：%d)", m_filename, m_error_code);
        return m_what_buf;
    }

    // 子类特有方法
    int get_error_code() const noexcept { return m_error_code; }
};

// noexcept(true) 函数：文件检查（内部捕获异常）
bool check_file(const char* filename) noexcept {
    try {
        if (strcmp(filename, "invalid.txt") == 0) {
            throw FileException(filename, 1001); // 模拟文件异常
        }
        return true;
    } catch (...) {
        std::cerr << "check_file 内部捕获异常：" << filename << std::endl;
        return false;
    }
}

// noexcept(false) 函数：文件读取
void read_file(const char* filename) {
    if (!check_file(filename)) {
        throw FileException(filename, 1002); // 重抛异常给上层
    }
    std::cout << "成功读取文件：" << filename << std::endl;
}

int main() {
    std::exception_ptr exp_ptr = nullptr;

    try {
        read_file("invalid.txt");
    } catch (const FileException& e) { // const& 捕获，无切片
        std::cout << "捕获文件异常：" << e.what() << std::endl;
        std::cout << "错误码：" << e.get_error_code() << std::endl;
        exp_ptr = std::current_exception(); // 暂存异常
    } catch (const std::exception& e) { // 兜底捕获
        std::cout << "捕获通用异常：" << e.what() << std::endl;
    } catch (...) { // 万能捕获
        std::cout << "捕获未知异常" << std::endl;
    }

    // 重新抛出暂存的异常
    if (exp_ptr) {
        try {
            std::rethrow_exception(exp_ptr);
        } catch (const FileException& e) {
            std::cout << "重新抛出异常：" << e.what() << std::endl;
        }
    }

    return 0;
}
```

#### 输出结果：
```
check_file 内部捕获异常：invalid.txt
捕获文件异常：文件异常：invalid.txt (错误码：1002)
错误码：1002
重新抛出异常：文件异常：invalid.txt (错误码：1002)
```

## 七、总结
1. **异常捕获原则**：始终使用 `const&` 捕获异常，避免值捕获导致的对象切片，同时提升效率；
2. **what() 设计**：返回 `const char*` 是为了异常安全（避免二次异常），实现时需避免返回局部变量指针；
3. **noexcept 优化**：`noexcept(true)` 函数无异常分支，编译器生成更精简的代码，性能更高，适用于析构、移动函数、纯计算逻辑等场景；
4. **异常管理**：`std::current_exception`/`std::rethrow_exception` 可暂存和延迟抛出异常，适合异步/复杂流程的异常处理；
5. **最佳实践**：自定义异常需继承 `std::exception`，重写 `noexcept` 的 `what()` 方法，捕获时按“子类→父类→catch(...)”的顺序匹配。