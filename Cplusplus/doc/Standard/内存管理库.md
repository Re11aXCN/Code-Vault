# 头文件

```c
#include <new>
#include <memory>
#include <memory_resource>
#include <scoped_allocator>
```



# 一、`<new>`

## 1. `<new>` 头文件功能详细说明

### 1. 异常类

| 类名                   | 描述                                 |
| ---------------------- | ------------------------------------ |
| `bad_alloc`            | 当内存分配失败时抛出的异常           |
| `bad_array_new_length` | 当尝试分配无效长度的数组时抛出的异常 |

### 2. 类型定义

| 类型          | 描述                       |
| ------------- | -------------------------- |
| `new_handler` | new 处理函数的函数指针类型 |
| `align_val_t` | 用于传递对齐要求的枚举类型 |

### 3. 标签类

| 标签                  | 描述                                                  |
| --------------------- | ----------------------------------------------------- |
| `nothrow_t`           | 用于选择非抛出分配函数的标签                          |
| `destroying_delete_t` | 用于在 operator delete 的销毁删除重载中进行选择的标签 |

### 4. 常量

| 常量                                      | 描述                   |
| ----------------------------------------- | ---------------------- |
| `hardware_destructive_interference_size`  | 避免伪共享的最小偏移量 |
| `hardware_constructive_interference_size` | 促进真共享的最大偏移量 |

### 5. 函数

| 函数                | 描述                                         |
| ------------------- | -------------------------------------------- |
| `operator new`      | 分配单个对象的内存                           |
| `operator new[]`    | 分配数组的内存                               |
| `operator delete`   | 释放单个对象的内存                           |
| `operator delete[]` | 释放数组的内存                               |
| `set_new_handler`   | 注册新的 new 处理函数                        |
| `get_new_handler`   | 获取当前的 new 处理函数                      |
| `launder`           | 指针优化屏障，用于处理对象生命周期和内存重用 |

## 2. 功能详细说明

### 1. 内存分配和释放
- **基本分配**: 使用 `new` 和 `delete` 进行内存分配和释放
- **数组分配**: 使用 `new[]` 和 `delete[]` 进行数组内存分配和释放
- **非抛出分配**: 使用 `nothrow` 版本的 `new`，在分配失败时返回 `nullptr` 而不是抛出异常

### 2. 异常处理
- **bad_alloc**: 当内存分配失败时抛出
- **bad_array_new_length**: 当尝试分配无效长度的数组时抛出

### 3. 对齐分配 (C++17)
- 使用 `align_val_t` 和对应的 `operator new`/`operator delete` 重载进行对齐内存分配

### 4. [原地构造 new](https://cppreference.cn/w/cpp/memory/new/operator_new)
- 在已分配的内存上构造对象，不进行实际的内存分配

### 5. new_handler
- 当 `operator new` 无法满足内存请求时调用的函数
- 可以使用 `set_new_handler` 设置自定义处理函数

### 6. std::launder (C++17)

blog：https://cppreference.cn/w/cpp/utility/launder

cpprefence：https://cppreference.cn/w/cpp/utility/launder

- 用于处理对象生命周期和内存重用的指针优化屏障
- 当在相同内存位置创建新对象时，用于获取指向新对象的有效指针



#### 什么是 std::launder？

```C++
struct A
{
  virtual int foo() { return 1; }
};

struct B : public A
{
  int foo() override { return 2; }
};

int call(A* a) 
{
  return a->foo();
}

int main()
{
  A a;
  int x = call(&a);
  B*  b = new (&a) B;
  int y = call(b);
  std::println("x = {}, y = {}", x, y); // 打印 1 1，编译器优化的问题，它认为虚函数表的指针是const，仍旧引用A虚函数表的指针，即使A不在那个地址，使用std::launder进行解决
    
  // 解决
  // 使用std::launder告诉编译器对象已经改变
  int y = call(std::launder(&a));  // 正确：将打印 2
  // 或者使用
  // int y = call(std::launder<A>(b));
  return 0;
}
```

`std::launder` 是 C++17 引入的一个模板函数，定义在 `<new>` 头文件中，它的核心作用是**绕过编译器的严格别名规则和对象生存期优化**，告诉编译器：“我知道这块内存里的对象已经变了，请不要用你缓存的旧对象信息，重新读取这块内存的真实状态”。

简单来说，编译器为了优化性能，会假设一个内存地址上的对象类型/状态是固定的（严格别名规则），但在某些手动管理内存的场景下（比如 placement new、内存池），我们会在同一个内存地址上构造新对象替换旧对象，这时编译器的优化就会导致错误——它还在使用旧对象的信息。而 `std::launder` 就是用来“清洗”这个指针，让编译器重新识别内存中的新对象。

#### 核心使用场景（附代码示例）
##### 场景1：同一内存地址构造新对象（替换旧对象）

当你在已有的对象内存地址上，用 placement new 构造一个新对象（类型相同但状态/值不同，或类型不同但满足严格别名例外），编译器可能仍会指向旧对象的信息，此时需要 `std::launder`。

```cpp
#include <new>
#include <iostream>

struct X {
    int a;
    int b;
};

int main() {
    // 1. 分配内存并构造第一个 X 对象
    alignas(X) char buffer[sizeof(X)];
    X* p = new (buffer) X{1, 2};
    std::cout << "原始对象: " << p->a << ", " << p->b << std::endl; // 输出 1, 2

    // 2. 在同一内存地址构造新的 X 对象（替换旧对象）
    new (buffer) X{3, 4}; // 旧对象析构（这里是POD类型，析构无副作用），新对象构造

    // 3. 直接用 p 访问会触发未定义行为（编译器可能缓存旧值）
    // std::cout << "未launder: " << p->a << ", " << p->b << std::endl; // 可能输出 1,2（错误）

    // 4. 用 std::launder 清洗指针，访问新对象
    X* q = std::launder(p);
    std::cout << "launder后: " << q->a << ", " << q->b << std::endl; // 输出 3, 4

    // 析构新对象
    q->~X();
    return 0;
}
```

##### 场景2：处理 const 对象/不可变对象的内存复用
如果内存中原本是 `const` 对象，替换后直接访问会违反严格别名规则，`std::launder` 可以合法访问新对象：

```cpp
#include <new>
#include <iostream>

int main() {
    alignas(const int) char buf[sizeof(int)];
    // 构造 const int 对象
    const int* cp = new (buf) const int{10};
    std::cout << *cp << std::endl; // 输出 10

    // 替换为新的 int 对象（非 const）
    new (buf) int{20};

    // 直接访问 *cp 是未定义行为，必须 launder
    int* np = std::launder(const_cast<int*>(cp));
    std::cout << *np << std::endl; // 输出 20

    np->~int();
    return 0;
}
```

#### 关键注意事项
1. **不是万能的**：`std::launder` 只能用于“内存中已有合法对象，但编译器不知道”的场景，不能用于空悬指针、未对齐内存、未构造对象的内存。
2. **严格的使用前提**：
   - 传入的指针必须指向一块已分配的内存；
   - 这块内存中必须已经构造了一个合法的对象；
   - 新对象的类型必须与原指针的类型兼容（或满足严格别名例外）。
3. **性能影响**：`std::launder` 会阻止编译器的一些优化（因为要重新读取内存），所以不要滥用，只在必要时使用。

#### 总结
1. `std::launder` 的核心作用是**告知编译器内存中的对象已更新**，绕过严格别名规则和生存期优化，合法访问同一内存地址上的新对象。
2. 主要用于手动管理内存的场景（如 placement new、内存池），解决“编译器缓存旧对象信息导致访问错误”的问题。
3. 使用时必须满足严格的前提条件，否则会导致未定义行为，且不要滥用（避免不必要的性能损耗）。

### 7. 硬件干扰大小 (C++17)
- 提供关于 CPU 缓存行大小的信息
- 用于优化多线程程序中的数据布局，避免伪共享

### 8. 销毁删除操作符 (C++20)
- 允许在 `operator delete` 中手动调用析构函数
- 提供更灵活的对象销毁和内存释放控制

### 9. 不抛异常的new

new 分配内存失败时默认抛异常bad_alloc

使用std::nothrow，分配失败不抛异常，而是将指针设置为空nullptr

```C++
A* a = new (std::nothrow) A();
```



## 3. 使用示例

下面是展示 C++ `<new>` 头文件中所有主要功能的完整示例：

```cpp
#include <iostream>
#include <new>
#include <cstdlib>
#include <cstring>

// 自定义 new_handler 函数
void my_new_handler() {
    std::cout << "自定义 new_handler: 内存分配失败，尝试释放一些内存...\n";
    // 这里可以尝试释放一些内存，然后重试分配
    // 如果无法释放足够内存，应该抛出 bad_alloc 或终止程序
    throw std::bad_alloc();
}

// 用于展示 destroying_delete 的类
class MyClass {
public:
    MyClass(int val) : value(val) {
        std::cout << "MyClass 构造函数，值: " << value << "\n";
    }
    
    ~MyClass() {
        std::cout << "MyClass 析构函数，值: " << value << "\n";
    }
    
    // C++20 销毁删除操作符
#if __cplusplus >= 202002L
    void operator delete(MyClass* ptr, std::destroying_delete_t) {
        std::cout << "使用销毁删除操作符\n";
        ptr->~MyClass(); // 手动调用析构函数
        ::operator delete(ptr); // 释放内存
    }
#endif
    
    void show() const {
        std::cout << "值: " << value << "\n";
    }
    
private:
    int value;
};

int main() {
    std::cout << "=== C++ <new> 头文件功能演示 ===\n\n";
    
    // 1. 设置和获取 new_handler
    std::cout << "1. new_handler 演示:\n";
    std::new_handler old_handler = std::set_new_handler(my_new_handler);
    std::cout << "之前的 new_handler: " << (old_handler ? "有" : "无") << "\n";
    std::cout << "当前的 new_handler: " << (std::get_new_handler() ? "有" : "无") << "\n\n";
    
    // 恢复原来的 new_handler
    std::set_new_handler(old_handler);
    
    // 2. 基本的 new 和 delete 操作符
    std::cout << "2. 基本的 new 和 delete 操作符:\n";
    int* ptr = new int(42);
    std::cout << "分配的内存值: " << *ptr << "\n";
    delete ptr;
    std::cout << "\n";
    
    // 3. 数组的 new 和 delete
    std::cout << "3. 数组的 new 和 delete:\n";
    int* arr = new int[5]{1, 2, 3, 4, 5};
    std::cout << "数组元素: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    delete[] arr;
    std::cout << "\n";
    
    // 4. nothrow 版本的 new
    std::cout << "4. nothrow 版本的 new:\n";
    int* nothrow_ptr = new(std::nothrow) int(100);
    if (nothrow_ptr) {
        std::cout << "nothrow 分配成功: " << *nothrow_ptr << "\n";
        delete nothrow_ptr;
    } else {
        std::cout << "nothrow 分配失败\n";
    }
    std::cout << "\n";
    
    // 5. 对齐分配 (C++17)
    std::cout << "5. 对齐分配 (C++17):\n";
    alignas(64) int* aligned_ptr = new(std::align_val_t{64}) int(200);
    std::cout << "对齐分配的值: " << *aligned_ptr << "\n";
    std::cout << "地址: " << aligned_ptr << "\n";
    std::cout << "地址对齐: " << (reinterpret_cast<uintptr_t>(aligned_ptr) % 64) << "\n";
    operator delete(aligned_ptr, std::align_val_t{64});
    std::cout << "\n";
    
    // 6. 异常处理 - bad_alloc
    std::cout << "6. bad_alloc 异常处理:\n";
    try {
        // 尝试分配一个非常大的内存块，可能会失败
        size_t huge_size = static_cast<size_t>(-1);
        char* huge_memory = new char[huge_size];
        delete[] huge_memory;
    } catch (const std::bad_alloc& e) {
        std::cout << "捕获到 bad_alloc 异常: " << e.what() << "\n";
    }
    std::cout << "\n";
    
    // 7. 异常处理 - bad_array_new_length (C++11)
    std::cout << "7. bad_array_new_length 异常处理:\n";
    try {
        // 尝试分配一个无效长度的数组
        size_t invalid_size = -1;
        int* invalid_array = new int[invalid_size];
        delete[] invalid_array;
    } catch (const std::bad_array_new_length& e) {
        std::cout << "捕获到 bad_array_new_length 异常: " << e.what() << "\n";
    }
    std::cout << "\n";
    
    // 8. 放置 new (placement new)
    std::cout << "8. 放置 new (placement new):\n";
    // 先分配原始内存
    void* raw_memory = ::operator new(sizeof(MyClass));
    std::cout << "原始内存地址: " << raw_memory << "\n";
    
    // 在已分配的内存上构造对象
    MyClass* obj = new(raw_memory) MyClass(999);
    obj->show();
    
    // 手动调用析构函数
    obj->~MyClass();
    
    // 释放原始内存
    ::operator delete(raw_memory);
    std::cout << "\n";
    
    // 9. 硬件干扰大小常量 (C++17)
    std::cout << "9. 硬件干扰大小常量 (C++17):\n";
    std::cout << "hardware_destructive_interference_size: " 
              << std::hardware_destructive_interference_size << "\n";
    std::cout << "hardware_constructive_interference_size: " 
              << std::hardware_constructive_interference_size << "\n";
    std::cout << "\n";
    
    // 10. std::launder (C++17) - 指针优化屏障
    std::cout << "10. std::launder 演示 (C++17):\n";
    struct X { 
        const int n; 
        X(int n) : n(n) {} 
    };
    
    X* x = new X(10);
    std::cout << "原始值: " << x->n << "\n";
    
    // 在同一内存位置创建新对象
    X* new_x = new(x) X(20);
    std::cout << "新值: " << new_x->n << "\n";
    
    // 使用 std::launder 获取指向新对象的指针
    X* laundered_x = std::launder(x);
    std::cout << "清洗后的值: " << laundered_x->n << "\n";
    
    laundered_x->~X();
    ::operator delete(x);
    std::cout << "\n";
    
    // 11. 自定义分配和释放函数
    std::cout << "11. 自定义分配和释放函数:\n";
    void* custom_mem = ::operator new(100);
    std::cout << "自定义分配的内存地址: " << custom_mem << "\n";
    ::operator delete(custom_mem);
    std::cout << "自定义释放完成\n";
    std::cout << "\n";
    
#if __cplusplus >= 202002L
    // 12. C++20 销毁删除操作符
    std::cout << "12. C++20 销毁删除操作符:\n";
    MyClass* dc_obj = new MyClass(1234);
    delete dc_obj; // 这会调用我们定义的销毁删除操作符
    std::cout << "\n";
#endif
    
    std::cout << "=== 演示结束 ===\n";
    
    return 0;
}
```

## 4. new/delete 和 ::operator new/delete区别

好的，这是一个非常深入的C++问题。简单来说，**有区别，而且是非常重要的区别**。

直接使用 `delete` 是标准且正确的做法，而直接调用 `::operator delete` 是一种特殊情况，通常应该避免。

下面我们来详细分解它们的区别。

### 1. `delete` 表达式 (The `delete` Expression)

当你写 `delete ptr;` 时，你并不是直接调用内存释放函数。你是在使用一个叫做 `delete` **表达式** 的东西。这个表达式会执行两个关键步骤：

1.  **调用析构函数**：首先，它会根据指针 `ptr` 的类型，调用指向对象的析构函数。这确保了对象所使用的任何资源（如内存、文件句柄、锁等）都能被正确清理。
2.  **释放内存**：然后，它**间接地**调用合适的 `operator delete` 函数来释放该对象所占用的内存。

**重要特性**：
*   `delete` 是**与 `new` 配对使用**的。你用 `new` 创建，就用 `delete` 销毁。
*   它会自动处理析构函数的调用，这是确保资源不泄漏的关键。
*   它知道该调用哪个 `operator delete`（全局的还是类特定的），你不需要关心。

**示例**：
```cpp
class MyClass {
public:
    MyClass() { std::cout << "Constructor\n"; }
    ~MyClass() { std::cout << "Destructor\n"; } // 析构函数
    void* operator new(size_t size) {
        std::cout << "Custom new\n";
        return ::operator new(size);
    }
    void operator delete(void* ptr) {
        std::cout << "Custom delete\n";
        ::operator delete(ptr);
    }
};

int main() {
    MyClass* obj = new MyClass; // 输出: Custom new, Constructor
    delete obj; // 输出: Destructor, Custom delete
    // 步骤：1. 调用 ~MyClass()  2. 调用 MyClass::operator delete
    return 0;
}
```

### 2. `::operator delete` 函数 (The `::operator delete` Function)

`::operator delete` 是一个**单纯的内存释放函数**。它的功能非常单一：释放之前由 `::operator new` 分配的一块原始内存。

*   `::` 作用域解析运算符意味着它明确指定调用**全局版本**的 `operator delete`，而不是某个类可能重载的版本。
*   它**只负责释放内存，不会调用任何析构函数**。

**直接调用 `::operator delete` 的危险性**：
如果你对一个拥有非平凡析构函数（non-trivial destructor）的对象直接使用 `::operator delete`，会导致**资源泄漏**。因为对象的析构函数永远不会被调用。

```cpp
int main() {
    MyClass* obj = new MyClass; // 输出: Custom new, Constructor

    // 错误做法！
    ::operator delete(obj); // 仅仅释放了内存！
    // 输出：什么都没有（没有调用析构函数和自定义的delete）
    // 后果：如果 MyClass 在构造函数中分配了其他内存或资源，这些资源将会泄漏。

    return 0;
}
```

### 3. 对比表格

| 特性                | `delete ptr;` (表达式)                           | `::operator delete(ptr);` (函数)                             |
| :------------------ | :----------------------------------------------- | :----------------------------------------------------------- |
| **主要功能**        | 销毁对象并释放内存                               | **仅释放内存**                                               |
| **析构函数**        | **会调用**                                       | **不会调用**                                                 |
| **选择机制**        | 自动选择正确的 `operator delete`（全局或类特定） | 强制使用**全局**版本的 `operator delete`                     |
| **使用场景**        | **99% 的情况**，用于销毁由 `new` 创建的动态对象  | 极少数特殊情况，需要与直接调用 `::operator new` 分配的**原始内存**配对 |
| **安全性**          | 安全，是标准做法                                 | **危险**，容易导致资源泄漏                                   |
| **与 `new` 的配对** | `new`                                            | `::operator new`                                             |

---

### 4. 什么时候应该直接使用 `::operator new` 和 `::operator delete`？

几乎从不。它们只在非常底层的编程中出现，例如：

1.  **编写自定义的内存分配器/池**：你可能会重载类的 `operator new`/`operator delete`，在你自定义的实现中，你最终仍然需要分配原始的、未初始化的内存块，这时你可能会调用 `::operator new` 和 `::operator delete`。
    ```cpp
    void* MyClass::operator new(size_t size) {
        // 你的自定义分配逻辑...
        // 最终需要一块原始内存，向全局内存池申请
        return ::operator new(size);
    }
    ```
2.  **处理原始内存**：如果你只是分配了一块没有任何构造对象的原始内存（比如，分配一个 `char` 数组用于缓冲区），并且使用的是 `::operator new`，那么释放时应该用 `::operator delete`。但请注意，这种情况通常使用 `new char[...]` 和 `delete[]` 会更简单、更安全。

### 5. 总结与最佳实践

*   **永远使用 `delete` 来销毁由 `new` 创建的对象**。这是黄金法则。
*   **永远不要直接调用 `::operator delete` 来替代 `delete`**。这样做会跳过析构函数，是严重的错误。
*   直接调用 `::operator delete` 是一个**底层操作**，它只应与直接调用 `::operator new` 的**上层操作**配对使用，并且你要非常清楚自己只是在操作原始内存，而不是具有生命周期的对象。

可以把 `new`/`delete` 理解为高级的、安全的“对象管理器”，而把 `::operator new`/`::operator delete` 理解为低级的、原始的“内存管理器”。在绝大多数情况下，你应该使用高级的接口。

### 6. 同样new 和 ::operator new 区别

new 需要进行new一个对象，它是调用一个结构体或者类的构造函数，然后分配内存，而::operator new则是申请一块区域大小的内存进行使用

```c
    // 1. 标准分配器使用
    std::cout << "1. 标准分配器:\n";
    std::allocator<int> alloc;
    int* arr = alloc.allocate(5); // 只分配内存
    
    // 构造对象
    for (int i = 0; i < 5; ++i) {
        std::construct_at(arr + i, i * 10);
    }
    
    /*
    // 使用 new
    int* arr_new = new int[5]; // 内存已分配，所有元素已默认构造
    // 可以直接使用
    for (int i = 0; i < 5; i++) {
        arr_new[i] = i * 10; // 只是赋值，不是构造
    }*/
    
    std::cout << "分配的内容: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    for (int i = 0; i < 5; ++i) {
        std::destroy_at(arr + i);
    }
    alloc.deallocate(arr, 5);
```



# 二、`<memory>`

## 1. 概述

| 包含                                                         |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ ](https://cppreference.cn/w/cpp/header/compare)(C++20)     | [三路比较运算符](https://cppreference.cn/w/cpp/language/operator_comparison#Three-way_comparison)支持 |
| 类                                                           |                                                              |
| 指针特性                                                     |                                                              |
| [ pointer_traits](https://cppreference.cn/w/cpp/memory/pointer_traits)(C++11) | 提供有关类指针类型的信息  (类模板)                           |
| 垃圾回收器支持                                               |                                                              |
| [ pointer_safety](https://cppreference.cn/w/cpp/memory/gc/pointer_safety)(C++11)(在 C++23 中已移除) | 列出指针安全模型  (枚举)                                     |
| 分配器                                                       |                                                              |
| [ allocator](https://cppreference.cn/w/cpp/memory/allocator) | 默认分配器  (类模板)                                         |
| [ allocator_traits](https://cppreference.cn/w/cpp/memory/allocator_traits)(C++11) | 提供关于分配器类型的信息  (类模板)                           |
| [ allocation_result](https://cppreference.cn/w/cpp/memory/allocation_result)(C++23) | 记录 `allocate_at_least` 分配的存储地址和实际大小  (类模板)  |
| [ uses_allocator](https://cppreference.cn/w/cpp/memory/uses_allocator)(C++11) | 检查指定类型是否支持 uses-allocator 构造  (类模板)           |
| 未初始化存储                                                 |                                                              |
| [ raw_storage_iterator](https://cppreference.cn/w/cpp/memory/raw_storage_iterator)(在 C++17 中已弃用)(在 C++20 中已移除) | 一个迭代器，允许标准算法将结果存储在未初始化内存中  (类模板) |
| 智能指针                                                     |                                                              |
| [ unique_ptr](https://cppreference.cn/w/cpp/memory/unique_ptr)(C++11) | 具有唯一对象所有权语义的智能指针  (类模板)                   |
| [ shared_ptr](https://cppreference.cn/w/cpp/memory/shared_ptr)(C++11) | 具有共享对象所有权语义的智能指针  (类模板)                   |
| [ weak_ptr](https://cppreference.cn/w/cpp/memory/weak_ptr)(C++11) | 对由 [std::shared_ptr](https://cppreference.cn/w/cpp/memory/shared_ptr) 管理的对象的弱引用  (类模板) |
| [ auto_ptr](https://cppreference.cn/w/cpp/memory/auto_ptr)(C++11 中已废弃)(C++17 中已移除) | 具有严格对象所有权语义的智能指针  (类模板)                   |
| 辅助类                                                       |                                                              |
| [ std::atomic](https://cppreference.cn/w/cpp/memory/shared_ptr/atomic2)(C++20) | 原子共享指针  (类模板特化)                                   |
| [ std::atomic](https://cppreference.cn/w/cpp/memory/weak_ptr/atomic2)(C++20) | 原子弱指针  (类模板特化)                                     |
| [ owner_less](https://cppreference.cn/w/cpp/memory/owner_less)(C++11) | 提供基于所有者的共享指针和弱指针的混合类型排序  (类模板)     |
| [ owner_hash](https://cppreference.cn/w/cpp/memory/owner_hash)(C++26) | 为共享指针和弱指针提供基于所有者的哈希  (类)                 |
| [ owner_equal](https://cppreference.cn/w/cpp/memory/owner_equal)(C++26) | 提供基于所有者的共享指针和弱指针的混合类型相等比较  (类)     |
| [ enable_shared_from_this](https://cppreference.cn/w/cpp/memory/enable_shared_from_this)(C++11) | 允许对象创建指向自身的 `shared_ptr`  (类模板)                |
| [ bad_weak_ptr](https://cppreference.cn/w/cpp/memory/bad_weak_ptr)(C++11) | 访问已销毁对象的 `weak_ptr` 时抛出的异常  (类)               |
| [ default_delete](https://cppreference.cn/w/cpp/memory/default_delete)(C++11) | [unique_ptr](https://cppreference.cn/w/cpp/memory/unique_ptr) 的默认删除器  (类模板) |
| [ std::hash](https://cppreference.cn/w/cpp/memory/unique_ptr/hash)(C++11) | [`std::unique_ptr`](https://cppreference.cn/w/cpp/memory/unique_ptr) 的哈希支持  (类模板特化) |
| [ std::hash](https://cppreference.cn/w/cpp/memory/shared_ptr/hash)(C++11) | [`std::shared_ptr`](https://cppreference.cn/w/cpp/memory/shared_ptr) 的哈希支持  (类模板特化) |
| 智能指针适配器                                               |                                                              |
| [ out_ptr_t](https://cppreference.cn/w/cpp/memory/out_ptr_t)(C++23) | 与外部指针设置器交互，并在销毁时重置智能指针  (类模板)       |
| [ inout_ptr_t](https://cppreference.cn/w/cpp/memory/inout_ptr_t)(C++23) | 与外部指针设置器交互，从智能指针获取初始指针值，并在销毁时重置它  (类模板) |
| 前向声明                                                     |                                                              |
| 定义于头文件 `<functional>`                                  |                                                              |
| [ hash](https://cppreference.cn/w/cpp/utility/hash)(C++11)   | 哈希函数对象  (类模板)                                       |
| 定义于头文件 `<atomic>`                                      |                                                              |
| [ atomic](https://cppreference.cn/w/cpp/atomic/atomic)(C++11) | atomic 类模板和针对 bool、整型、浮点型(C++20 起) 和指针类型的特化  (类模板) |
| 标签                                                         |                                                              |
| [ allocator_argallocator_arg_t](https://cppreference.cn/w/cpp/memory/allocator_arg)(C++11) | 用于选择分配器感知构造函数的标记 (标签)                      |
| 函数                                                         |                                                              |
| 使用分配器构造                                               |                                                              |
| [ uses_allocator_construction_args](https://cppreference.cn/w/cpp/memory/uses_allocator_construction_args)(C++20) | 准备与给定类型所需的使用分配器构造方式匹配的参数列表  (函数模板) |
| [ make_obj_using_allocator](https://cppreference.cn/w/cpp/memory/make_obj_using_allocator)(C++20) | 通过 uses-allocator 构造创建给定类型的对象  (函数模板)       |
| [ uninitialized_construct_using_allocator](https://cppreference.cn/w/cpp/memory/uninitialized_construct_using_allocator)(C++20) | 通过使用分配器构造在指定内存位置创建给定类型的对象  (函数模板) |
| 杂项                                                         |                                                              |
| [ to_address](https://cppreference.cn/w/cpp/memory/to_address)(C++20) | 从类指针类型获取原始指针  (函数模板)                         |
| [ addressof](https://cppreference.cn/w/cpp/memory/addressof)(C++11) | 获取对象的实际地址，即使 `**&**` 运算符被重载  (函数模板)    |
| [ align](https://cppreference.cn/w/cpp/memory/align)(C++11)  | 在缓冲区中对齐指针  (函数)                                   |
| [ assume_aligned](https://cppreference.cn/w/cpp/memory/assume_aligned)(C++20) | 通知编译器指针已对齐  (函数模板)                             |
| [ is_sufficiently_aligned](https://cppreference.cn/w/cpp/memory/is_sufficiently_aligned)(C++26) | 检查指针是否指向对齐值至少为给定值的对象  (函数模板)         |
| 显式生命周期管理                                             |                                                              |
| [ start_lifetime_asstart_lifetime_as_array](https://cppreference.cn/w/cpp/memory/start_lifetime_as)(C++23) | 在给定存储中隐式创建对象，并重用对象表示  (函数模板)         |
| 垃圾回收器支持                                               |                                                              |
| [ declare_reachable](https://cppreference.cn/w/cpp/memory/gc/declare_reachable)(C++11)(在 C++23 中已移除) | 声明一个对象不能被回收  (函数)                               |
| [ undeclare_reachable](https://cppreference.cn/w/cpp/memory/gc/undeclare_reachable)(C++11)(在 C++23 中已移除) | 声明一个对象可以被回收  (函数模板)                           |
| [ declare_no_pointers](https://cppreference.cn/w/cpp/memory/gc/declare_no_pointers)(C++11)(在 C++23 中已移除) | 声明一个内存区域不包含可追溯指针  (函数)                     |
| [ undeclare_no_pointers](https://cppreference.cn/w/cpp/memory/gc/undeclare_no_pointers)(C++11)(在 C++23 中已移除) | 取消 [std::declare_no_pointers](https://cppreference.cn/w/cpp/memory/gc/declare_no_pointers) 的效果  (函数) |
| [ get_pointer_safety](https://cppreference.cn/w/cpp/memory/gc/get_pointer_safety)(C++11)(在 C++23 中已移除) | 返回当前指针安全模型  (函数)                                 |
| 未初始化存储                                                 |                                                              |
| [ uninitialized_copy](https://cppreference.cn/w/cpp/memory/uninitialized_copy) | 将对象范围复制到未初始化内存区域  (函数模板)                 |
| [ uninitialized_copy_n](https://cppreference.cn/w/cpp/memory/uninitialized_copy_n)(C++11) | 将一定数量的对象复制到未初始化内存区域  (函数模板)           |
| [ uninitialized_fill](https://cppreference.cn/w/cpp/memory/uninitialized_fill) | 将对象复制到由范围定义的未初始化内存区域  (函数模板)         |
| [ uninitialized_fill_n](https://cppreference.cn/w/cpp/memory/uninitialized_fill_n) | 将对象复制到由起始和计数定义的未初始化内存区域  (函数模板)   |
| [ uninitialized_move](https://cppreference.cn/w/cpp/memory/uninitialized_move)(C++17) | 将一系列对象移动到未初始化内存区域  (函数模板)               |
| [ uninitialized_move_n](https://cppreference.cn/w/cpp/memory/uninitialized_move_n)(C++17) | 将多个对象移动到未初始化内存区域  (函数模板)                 |
| [ uninitialized_default_construct](https://cppreference.cn/w/cpp/memory/uninitialized_default_construct)(C++17) | 通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)在由范围定义的未初始化内存区域中构造对象  (函数模板) |
| [ uninitialized_default_construct_n](https://cppreference.cn/w/cpp/memory/uninitialized_default_construct_n)(C++17) | 在由起始和计数定义的未初始化内存区域中，通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)构造对象  (函数模板) |
| [ uninitialized_value_construct](https://cppreference.cn/w/cpp/memory/uninitialized_value_construct)(C++17) | 在由范围定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象  (函数模板) |
| [ uninitialized_value_construct_n](https://cppreference.cn/w/cpp/memory/uninitialized_value_construct_n)(C++17) | 在由起始和计数定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象  (函数模板) |
| [ construct_at](https://cppreference.cn/w/cpp/memory/construct_at)(C++20) | 在给定地址创建对象  (函数模板)                               |
| [ destroy_at](https://cppreference.cn/w/cpp/memory/destroy_at)(C++17) | 销毁给定地址处的对象  (函数模板)                             |
| [ destroy](https://cppreference.cn/w/cpp/memory/destroy)(C++17) | 销毁对象范围  (函数模板)                                     |
| [ destroy_n](https://cppreference.cn/w/cpp/memory/destroy_n)(C++17) | 销毁范围内的多个对象  (函数模板)                             |
| [ get_temporary_buffer](https://cppreference.cn/w/cpp/memory/get_temporary_buffer)(在 C++17 中已弃用)(在 C++20 中已移除) | 获取未初始化存储  (函数模板)                                 |
| [ return_temporary_buffer](https://cppreference.cn/w/cpp/memory/return_temporary_buffer)(在 C++17 中已弃用)(在 C++20 中已移除) | 释放未初始化存储  (函数模板)                                 |
| 智能指针非成员操作                                           |                                                              |
| [ make_uniquemake_unique_for_overwrite](https://cppreference.cn/w/cpp/memory/unique_ptr/make_unique)(C++14)(C++20) | 创建一个管理新对象的唯一指针  (函数模板)                     |
| [ operator==operator!=operatoroperator>=operator<=>](https://cppreference.cn/w/cpp/memory/unique_ptr/operator_cmp)(C++20 中移除)(C++20) | 与另一个 `unique_ptr` 或 nullptr 比较  (函数模板)            |
| [ make_sharedmake_shared_for_overwrite](https://cppreference.cn/w/cpp/memory/shared_ptr/make_shared)(C++20 起) | 创建一个管理新对象的共享指针  (函数模板)                     |
| [ allocate_sharedallocate_shared_for_overwrite](https://cppreference.cn/w/cpp/memory/shared_ptr/allocate_shared)(C++20 起) | 创建一个共享指针，该指针管理使用分配器分配的新对象  (函数模板) |
| [ static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_pointer_cast](https://cppreference.cn/w/cpp/memory/shared_ptr/pointer_cast)(C++17) | 对存储的指针应用 [`static_cast`](https://cppreference.cn/w/cpp/language/static_cast)、[`dynamic_cast`](https://cppreference.cn/w/cpp/language/dynamic_cast)、[`const_cast`](https://cppreference.cn/w/cpp/language/const_cast) 或 [`reinterpret_cast`](https://cppreference.cn/w/cpp/language/reinterpret_cast)  (函数模板) |
| [ get_deleter](https://cppreference.cn/w/cpp/memory/shared_ptr/get_deleter) | 如果拥有，则返回指定类型的删除器  (函数模板)                 |
| [ operator==operator!=operatoroperator>=operator<=>](https://cppreference.cn/w/cpp/memory/shared_ptr/operator_cmp)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20 中移除)(C++20) | 与另一个 `shared_ptr` 或 nullptr 比较  (函数模板)            |
| [ operator<<(std::shared_ptr)](https://cppreference.cn/w/cpp/memory/shared_ptr/operator_ltlt) | 将存储的指针值输出到输出流  (函数模板)                       |
| [ operator<<(std::unique_ptr)](https://cppreference.cn/w/cpp/memory/unique_ptr/operator_ltlt)(C++20) | 将管理的指针值输出到输出流  (函数模板)                       |
| [ std::swap(std::unique_ptr)](https://cppreference.cn/w/cpp/memory/unique_ptr/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| [ std::swap(std::shared_ptr)](https://cppreference.cn/w/cpp/memory/shared_ptr/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| [ std::swap(std::weak_ptr)](https://cppreference.cn/w/cpp/memory/weak_ptr/swap2)(C++11) | 特化 [std::swap](https://cppreference.cn/w/cpp/algorithm/swap) 算法  (函数模板) |
| 智能指针适配器创建                                           |                                                              |
| [ out_ptr](https://cppreference.cn/w/cpp/memory/out_ptr_t/out_ptr)(C++23) | 创建带有相关智能指针和重置参数的 `out_ptr_t`  (函数模板)     |
| [ inout_ptr](https://cppreference.cn/w/cpp/memory/inout_ptr_t/inout_ptr)(C++23) | 创建一个带有关联智能指针和重置参数的 `inout_ptr_t`  (函数模板) |

| [ std::atomic_is_lock_free(std::shared_ptr)std::atomic_load(std::shared_ptr)std::atomic_load_explicit(std::shared_ptr)std::atomic_store(std::shared_ptr)std::atomic_store_explicit(std::shared_ptr)std::atomic_exchange(std::shared_ptr)std::atomic_exchange_explicit(std::shared_ptr)std::atomic_compare_exchange_weak(std::shared_ptr)std::atomic_compare_exchange_strong(std::shared_ptr)std::atomic_compare_exchange_weak_explicit(std::shared_ptr)std::atomic_compare_exchange_strong_explicit(std::shared_ptr)](https://cppreference.cn/w/cpp/memory/shared_ptr/atomic)(C++20 中已弃用)(C++26 中移除) | 特化 `std::shared_ptr` 的原子操作  (函数模板) |
| ------------------------------------------------------------ | --------------------------------------------- |
|                                                              |                                               |



| 类函数实体                                                   |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义于命名空间`std::ranges`                                  |                                                              |
| 未初始化存储                                                 |                                                              |
| [ ranges::uninitialized_copy](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_copy)(C++20) | 将对象范围复制到未初始化内存区域 (算法函数对象)              |
| [ ranges::uninitialized_copy_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_copy_n)(C++20) | 将一定数量的对象复制到未初始化内存区域 (算法函数对象)        |
| [ ranges::uninitialized_fill](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_fill)(C++20) | 将对象复制到由范围定义的未初始化内存区域 (算法函数对象)      |
| [ ranges::uninitialized_fill_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_fill_n)(C++20) | 将对象复制到由起始和计数定义的未初始化内存区域 (算法函数对象) |
| [ ranges::uninitialized_move](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_move)(C++20) | 将一系列对象移动到未初始化内存区域 (算法函数对象)            |
| [ ranges::uninitialized_move_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_move_n)(C++20) | 将多个对象移动到未初始化内存区域 (算法函数对象)              |
| [ ranges::uninitialized_default_construct](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_default_construct)(C++20) | 通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)在由范围定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ ranges::uninitialized_default_construct_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_default_construct_n)(C++20) | 通过[默认初始化](https://cppreference.cn/w/cpp/language/default_initialization)在由起始和计数定义的未初始化内存区域中构造对象 (算法函数对象) |
| [ ranges::uninitialized_value_construct](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_value_construct)(C++20) | 在由范围定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象 (算法函数对象) |
| [ ranges::uninitialized_value_construct_n](https://cppreference.cn/w/cpp/memory/ranges/uninitialized_value_construct_n)(C++20) | 在由起始和计数定义的未初始化内存区域中，通过[值初始化](https://cppreference.cn/w/cpp/language/value_initialization)构造对象 (算法函数对象) |
| [ ranges::construct_at](https://cppreference.cn/w/cpp/memory/ranges/construct_at)(C++20) | 在给定地址创建对象 (算法函数对象)                            |
| [ ranges::destroy_at](https://cppreference.cn/w/cpp/memory/ranges/destroy_at)(C++20) | 销毁给定地址处的对象 (算法函数对象)                          |
| [ ranges::destroy](https://cppreference.cn/w/cpp/memory/ranges/destroy)(C++20) | 销毁对象范围 (算法函数对象)                                  |
| [ ranges::destroy_n](https://cppreference.cn/w/cpp/memory/ranges/destroy_n)(C++20) | 销毁范围内的多个对象 (算法函数对象)                          |

## 2. C++ 分配器底层实现

C++ 标准库的 `std::allocator` 通常使用全局的 `::operator new` 和 `::operator delete` 来分配和释放内存。这意味着：

1. 每次分配都会调用系统调用，可能效率较低
2. 频繁的小内存分配可能导致内存碎片
3. 没有内置的内存池或缓存机制

## 3. 常用方法示例

下面是 `<memory>` 头文件中四个主要模块的详细说明和代码示例：

### 1. 未初始化存储模块

提供在未初始化内存中构造、复制、移动和销毁对象的函数，用于低级内存管理。

**核心功能：**

- `uninitialized_copy`/`uninitialized_copy_n`: 复制对象到未初始化内存
- `uninitialized_fill`/`uninitialized_fill_n`: 用特定值填充未初始化内存
- `uninitialized_move`/`uninitialized_move_n`: 移动对象到未初始化内存
- `construct_at`: 在指定地址构造对象
- `destroy`/`destroy_at`/`destroy_n`: 销毁对象
- `uninitialized_default_construct`/`uninitialized_value_construct`: 默认构造和值构造

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <string>

int main() {
    std::cout << "=== 未初始化存储模块示例 ===\n\n";
    
    // 1. uninitialized_copy - 复制对象到未初始化内存
    std::cout << "1. uninitialized_copy:\n";
    std::vector<int> source = {1, 2, 3, 4, 5};
    // 分配未初始化内存
    void* raw_memory = operator new(source.size() * sizeof(int));
    int* dest = static_cast<int*>(raw_memory);
    
    // 复制到未初始化内存
    std::uninitialized_copy(source.begin(), source.end(), dest);
    
    std::cout << "复制的内容: ";
    for (size_t i = 0; i < source.size(); ++i) {
        std::cout << dest[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    std::destroy(dest, dest + source.size());
    operator delete(raw_memory);
    
    // 2. uninitialized_fill - 填充未初始化内存
    std::cout << "\n2. uninitialized_fill:\n";
    const size_t count = 5;
    int* filled_memory = static_cast<int*>(operator new(count * sizeof(int)));
    
    // 用特定值填充未初始化内存
    std::uninitialized_fill(filled_memory, filled_memory + count, 42);
    
    std::cout << "填充的内容: ";
    for (size_t i = 0; i < count; ++i) {
        std::cout << filled_memory[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    std::destroy(filled_memory, filled_memory + count);
    operator delete(filled_memory);
    
    // 3. uninitialized_move - 移动对象到未初始化内存
    std::cout << "\n3. uninitialized_move:\n";
    std::vector<std::string> move_source = {"Hello", "World", "C++"};
    std::string* move_dest = static_cast<std::string*>(
        operator new(move_source.size() * sizeof(std::string))
    );
    
    // 移动到未初始化内存
    std::uninitialized_move(move_source.begin(), move_source.end(), move_dest);
    
    std::cout << "移动的内容: ";
    for (size_t i = 0; i < move_source.size(); ++i) {
        std::cout << move_dest[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    std::destroy(move_dest, move_dest + move_source.size());
    operator delete(move_dest);
    
    // 4. construct_at 和 destroy_at - 在特定地址构造和销毁对象
    std::cout << "\n4. construct_at 和 destroy_at:\n";
    alignas(std::string) char buffer[sizeof(std::string)];
    
    // 在指定地址构造对象
    std::string* str_ptr = std::construct_at(reinterpret_cast<std::string*>(buffer), "Constructed at address");
    std::cout << *str_ptr << "\n";
    
    // 在指定地址销毁对象
    std::destroy_at(str_ptr);
    
    // 5. uninitialized_default_construct 和 uninitialized_value_construct
    std::cout << "\n5. 默认构造和值构造:\n";
    constexpr size_t arr_size = 3;
    int* default_arr = static_cast<int*>(operator new(arr_size * sizeof(int)));
    int* value_arr = static_cast<int*>(operator new(arr_size * sizeof(int)));
    
    // 默认构造（不初始化）
    std::uninitialized_default_construct_n(default_arr, arr_size);
    std::cout << "默认构造的值（未定义）: " 
              << default_arr[0] << " " << default_arr[1] << " " << default_arr[2] << "\n";
    
    // 值构造（初始化为0）
    std::uninitialized_value_construct_n(value_arr, arr_size);
    std::cout << "值构造的值（初始化为0）: " 
              << value_arr[0] << " " << value_arr[1] << " " << value_arr[2] << "\n";
    
    // 销毁对象并释放内存
    std::destroy_n(default_arr, arr_size);
    std::destroy_n(value_arr, arr_size);
    operator delete(default_arr);
    operator delete(value_arr);
    
    std::cout << "\n=== 未初始化存储模块示例结束 ===\n";
    return 0;
}
```

### 2. 分配器模块

提供内存分配和释放的抽象，支持自定义内存管理策略。

**核心功能：**

- `allocator`: 标准分配器
- `allocator_traits`: 提供分配器类型信息
- 自定义分配器实现
- `uses_allocator`: 检查类型是否支持使用分配器
- `allocate_at_least` (C++23): 分配至少指定大小的内存

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <cstdlib>

// 自定义分配器示例
template<typename T>
class SimpleAllocator {
public:
    using value_type = T;
    
    SimpleAllocator() = default;
    
    template<typename U>
    SimpleAllocator(const SimpleAllocator<U>&) {}
    
    T* allocate(std::size_t n) {
        std::cout << "分配 " << n << " 个 " << typeid(T).name() << " 对象\n";
        return static_cast<T*>(std::malloc(n * sizeof(T)));
    }
    
    void deallocate(T* p, std::size_t n) {
        std::cout << "释放 " << n << " 个 " << typeid(T).name() << " 对象\n";
        std::free(p);
    }
};

// 支持分配器感知的类型
template<typename T, typename Allocator = std::allocator<T>>
class AllocatorAwareContainer {
public:
    using allocator_type = Allocator;
    
    explicit AllocatorAwareContainer(const Allocator& alloc = Allocator())
        : alloc_(alloc), data_(alloc_) {}
    
    void add(const T& value) {
        data_.push_back(value);
    }
    
    void show() const {
        for (const auto& item : data_) {
            std::cout << item << " ";
        }
        std::cout << "\n";
    }
    
private:
    Allocator alloc_;
    std::vector<T, Allocator> data_;
};

int main() {
    std::cout << "=== 分配器模块示例 ===\n\n";
    
    // 1. 标准分配器使用
    std::cout << "1. 标准分配器:\n";
    std::allocator<int> alloc;
    int* arr = alloc.allocate(5); // 只分配内存
    
    // 构造对象
    for (int i = 0; i < 5; ++i) {
        std::construct_at(arr + i, i * 10);
    }
    
    /*
    // 使用 new
    int* arr_new = new int[5]; // 内存已分配，所有元素已默认构造
    // 可以直接使用
    for (int i = 0; i < 5; i++) {
        arr_new[i] = i * 10; // 只是赋值，不是构造
    }*/
    
    std::cout << "分配的内容: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
    
    // 销毁对象并释放内存
    for (int i = 0; i < 5; ++i) {
        std::destroy_at(arr + i);
    }
    alloc.deallocate(arr, 5);
    
    // 2. 自定义分配器
    std::cout << "\n2. 自定义分配器:\n";
    SimpleAllocator<double> custom_alloc;
    double* custom_arr = custom_alloc.allocate(3);
    
    for (int i = 0; i < 3; ++i) {
        std::construct_at(custom_arr + i, i + 0.5);
    }
    
    std::cout << "自定义分配的内容: ";
    for (int i = 0; i < 3; ++i) {
        std::cout << custom_arr[i] << " ";
    }
    std::cout << "\n";
    
    for (int i = 0; i < 3; ++i) {
        std::destroy_at(custom_arr + i);
    }
    custom_alloc.deallocate(custom_arr, 3);
    
    // 3. allocator_traits 使用
    std::cout << "\n3. allocator_traits:\n";
    using AllocTraits = std::allocator_traits<SimpleAllocator<int>>;//使用allocator_traits统一自定义的allocator接口
    SimpleAllocator<int> int_alloc;
    
    int* traits_arr = AllocTraits::allocate(int_alloc, 4);
    
    for (int i = 0; i < 4; ++i) {
        AllocTraits::construct(int_alloc, traits_arr + i, i * 2);
        //SimpleAllocator<int>::construct // 错误没有这个方法
    }
    
    std::cout << "使用 allocator_traits 分配的内容: ";
    for (int i = 0; i < 4; ++i) {
        std::cout << traits_arr[i] << " ";
    }
    std::cout << "\n";
    
    for (int i = 0; i < 4; ++i) {
        AllocTraits::destroy(int_alloc, traits_arr + i);
    }
    AllocTraits::deallocate(int_alloc, traits_arr, 4);
    
    // 4. 分配器感知的容器
    std::cout << "\n4. 分配器感知的容器:\n";
    SimpleAllocator<int> container_alloc;
    AllocatorAwareContainer<int, SimpleAllocator<int>> container(container_alloc);
    
    container.add(10);
    container.add(20);
    container.add(30);
    
    std::cout << "容器内容: ";
    container.show();
    
    // 5. uses_allocator 检查
    std::cout << "\n5. uses_allocator 检查:\n";
    bool uses_alloc = std::uses_allocator<
        AllocatorAwareContainer<int, SimpleAllocator<int>>, 
        SimpleAllocator<int>>::value;
    
    std::cout << "容器是否使用分配器: " << std::boolalpha << uses_alloc << "\n";
    
    // 6. C++23 allocation_result (如果编译器支持)
    #if __cplusplus >= 202302L
    std::cout << "\n6. C++23 allocation_result:\n";
    std::allocator<int> new_alloc;
    auto result = new_alloc.allocate_at_least(10);
    std::cout << "请求大小: 10, 实际分配大小: " << result.count << "\n";
    new_alloc.deallocate(result.ptr, result.count);
    #endif
    
    std::cout << "\n=== 分配器模块示例结束 ===\n";
    return 0;
}
```

### 3. 杂项模块

提供各种有用的内存相关工具函数。

**核心功能：**

- `addressof`: 获取对象实际地址（即使&运算符被重载）
- `to_address`: 从类似指针的类型获取原始指针
- `align`: 对齐指针
- `assume_aligned`: 通知编译器指针已对齐
- `is_sufficiently_aligned` (C++23): 检查对齐是否足够
- `start_lifetime_as` (C++23): 在存储中开始对象生命周期

```cpp
#include <iostream>
#include <memory>
#include <vector>

struct OverloadedAddress {
    int value;
    
    // 重载 & 运算符
    OverloadedAddress* operator&() {
        std::cout << "重载的 & 运算符被调用\n";
        return this + 100; // 返回错误地址
    }
    
    const OverloadedAddress* operator&() const {
        std::cout << "重载的 & 运算符被调用\n";
        return this + 100; // 返回错误地址
    }
};

int main() {
    std::cout << "=== 杂项模块示例 ===\n\n";
    
    // 1. addressof - 获取对象实际地址
    std::cout << "1. addressof:\n";
    OverloadedAddress obj{42};
    
    std::cout << "使用 & 运算符: " << &obj << "\n";
    std::cout << "使用 addressof: " << std::addressof(obj) << "\n";
    std::cout << "实际值: " << std::addressof(obj)->value << "\n\n";
    
    // 2. to_address - 从指针类获取原始指针
    std::cout << "2. to_address:\n";
    int x = 100;
    int* ptr = &x;
    std::shared_ptr<int> shared_ptr = std::make_shared<int>(200);
    
    std::cout << "原始指针: " << std::to_address(ptr) << "\n";
    std::cout << "共享指针: " << std::to_address(shared_ptr) << "\n";
    std::cout << "共享指针值: " << *std::to_address(shared_ptr) << "\n\n";
    
    // 3. align - 对齐指针
    std::cout << "3. align:\n";
    char buffer[100];
    std::size_t space = sizeof(buffer);
    
    void* original_ptr = buffer;
    void* aligned_ptr = std::align(16, 50, original_ptr, space);
    
    std::cout << "原始指针: " << (void*)buffer << "\n";
    std::cout << "对齐后指针: " << aligned_ptr << "\n";
    std::cout << "剩余空间: " << space << "\n\n";
    
    // 4. assume_aligned - 通知编译器指针已对齐
    std::cout << "4. assume_aligned:\n";
    alignas(16) int aligned_arr[4] = {1, 2, 3, 4};
    int* arr_ptr = aligned_arr;
    
    // 通知编译器指针已对齐，允许编译器进行优化
    int* assumed_aligned = std::assume_aligned<16>(arr_ptr);
    
    std::cout << "假设对齐的指针: " << assumed_aligned << "\n";
    std::cout << "值: ";
    for (int i = 0; i < 4; ++i) {
        std::cout << assumed_aligned[i] << " ";
    }
    std::cout << "\n\n";
    
    // 5. C++23 is_sufficiently_aligned (如果编译器支持)
    #if __cplusplus >= 202302L
    std::cout << "5. is_sufficiently_aligned:\n";
    alignas(32) char highly_aligned[64];
    bool is_aligned = std::is_sufficiently_aligned(highly_aligned, 32);
    std::cout << "是否至少32字节对齐: " << std::boolalpha << is_aligned << "\n\n";
    #endif
    
    // 6. C++23 start_lifetime_as (如果编译器支持)
    #if __cplusplus >= 202302L
    std::cout << "6. start_lifetime_as:\n";
    alignas(std::string) char str_storage[sizeof(std::string)];
    std::string* str_ptr = std::start_lifetime_as<std::string>(str_storage);
    new(str_ptr) std::string("C++23 生命周期开始");
    std::cout << *str_ptr << "\n";
    str_ptr->~std::string();
    #endif
    
    std::cout << "\n=== 杂项模块示例结束 ===\n";
    return 0;
}
```

### 4. 智能指针非成员操作模块

提供创建和管理智能指针的辅助函数。

**核心功能：**

- `make_shared`/`make_shared_for_overwrite`: 创建共享指针
- `allocate_shared`/`allocate_shared_for_overwrite`: 使用分配器创建共享指针
- `static_pointer_cast`/`dynamic_pointer_cast`: 共享指针类型转换
- `const_pointer_cast`/`reinterpret_pointer_cast`: 共享指针常量性和类型重新解释

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Base {
public:
    virtual ~Base() = default;
    virtual void print() const { std::cout << "Base\n"; }
};

class Derived : public Base {
public:
    void print() const override { std::cout << "Derived\n"; }
    void derivedMethod() const { std::cout << "Derived特有方法\n"; }
};

class AnotherClass {
public:
    void print() const { std::cout << "AnotherClass\n"; }
};

int main() {
    std::cout << "=== 智能指针非成员操作模块示例 ===\n\n";
    
    // 1. make_shared - 创建共享指针
    std::cout << "1. make_shared:\n";
    auto shared_int = std::make_shared<int>(42);
    std::cout << "值: " << *shared_int << ", 引用计数: " << shared_int.use_count() << "\n";
    
    auto shared_vec = std::make_shared<std::vector<int>>(5, 10);
    std::cout << "向量大小: " << shared_vec->size() << "\n\n";
    
    // 2. make_shared_for_overwrite - C++20 创建未初始化的共享指针
    std::cout << "2. make_shared_for_overwrite (C++20):\n";
    #if __cplusplus >= 202002L
    auto shared_uninit = std::make_shared_for_overwrite<int>();
    // 需要后续初始化
    *shared_uninit = 100;
    std::cout << "未初始化共享指针的值: " << *shared_uninit << "\n\n";
    #endif
    
    // 3. allocate_shared - 使用分配器创建共享指针
    std::cout << "3. allocate_shared:\n";
    std::allocator<int> alloc;
    auto allocated_shared = std::allocate_shared<int>(alloc, 999);
    std::cout << "使用分配器创建的共享指针值: " << *allocated_shared << "\n\n";
    
    // 4. allocate_shared_for_overwrite - C++20 使用分配器创建未初始化的共享指针
    std::cout << "4. allocate_shared_for_overwrite (C++20):\n";
    #if __cplusplus >= 202002L
    auto allocated_uninit = std::allocate_shared_for_overwrite<int>(alloc);
    // 需要后续初始化
    *allocated_uninit = 777;
    std::cout << "使用分配器创建的未初始化共享指针值: " << *allocated_uninit << "\n\n";
    #endif
    
    // 5. 指针转换函数
    std::cout << "5. 指针转换函数:\n";
    
    // 创建派生类共享指针
    std::shared_ptr<Derived> derived_ptr = std::make_shared<Derived>();
    
    // static_pointer_cast - 静态向下转换
    std::shared_ptr<Base> base_ptr = std::static_pointer_cast<Base>(derived_ptr);
    base_ptr->print();
    
    // dynamic_pointer_cast - 动态向下转换
    std::shared_ptr<Derived> back_to_derived = 
        std::dynamic_pointer_cast<Derived>(base_ptr);
    if (back_to_derived) {
        back_to_derived->derivedMethod();
    }
    
    // const_pointer_cast - 移除const
    const std::shared_ptr<const int> const_ptr = std::make_shared<const int>(123);
    std::shared_ptr<int> non_const_ptr = std::const_pointer_cast<int>(const_ptr);
    *non_const_ptr = 456;
    std::cout << "修改后的值: " << *non_const_ptr << "\n";
    
    // reinterpret_pointer_cast - 重新解释指针类型
    std::shared_ptr<AnotherClass> another_ptr = 
        std::reinterpret_pointer_cast<AnotherClass>(derived_ptr);
    another_ptr->print();
    
    std::cout << "\n=== 智能指针非成员操作模块示例结束 ===\n";
    return 0;
}
```

## 4. allocate/deallocate和::operator new/delete

* `std::allocator` 的 `allocate()` 和 `deallocate()` 方法本质上是 `::operator new` 和 `::operator delete` 的封装，但提供了更高级的、类型安全的接口。

* 虽然功能上等价，但 `std::allocator` 提供了几个重要优势：
  * **类型安全**：`alloc.allocate(5)` 明确表示分配5个 `int` 对象，而不需要手动计算字节数。
  * **可移植性**：`std::allocator` 是标准库的一部分，保证了跨平台的兼容性。
  * **可自定义**：可以创建自定义分配器，实现特定的内存管理策略，同时保持相同的接口。
  * **与STL容器集成**：STL容器（如 `vector`、`list` 等）使用分配器接口，因此可以轻松替换为自定义分配器。
  * **异常安全**：标准分配器提供了更强的异常安全保证。
  * **调试支持**：在某些实现中，标准分配器可能包含额外的调试和边界检查功能。

* 何时选择直接使用 `::operator new/delete
  * 需要分配原始内存（不涉及对象构造）
  * 实现极低级别的内存管理
  * 与C代码交互，需要与 `malloc/free` 兼容的接口

## 5. std::aloocate_traits作用

`std::allocator_traits` 是一个非常重要的 C++ 标准库组件，它提供了**统一的方式**来与各种类型的分配器（allocators）进行交互，<u>无论这些分配器是否实现了所有可能的方法</u>。

`std::allocator_traits` 的主要作用总结为：

1. **提供统一接口**：让代码能够以一致的方式使用任何类型的分配器
2. **提供默认实现**：为分配器可能缺少的方法提供合理的默认行为
3. **简化代码**：避免了复杂的 SFINAE 或模板元编程来检查方法是否存在
4. **增强灵活性**：允许创建最小化的分配器，同时保持与标准库的兼容性

### （1）为什么需要 `std::allocator_traits`？

在 C++ 中，分配器可以有不同的实现方式：
1. **最小分配器**：只实现 `allocate()` 和 `deallocate()`
2. **完整分配器**：实现所有可选方法（如 `construct()`, `destroy()`, `max_size()` 等）

如果没有 `std::allocator_traits`，使用分配器的代码需要检查每个方法是否存在，这会非常复杂且容易出错。

### （2）`std::allocator_traits` 的主要功能

#### a. 提供统一的接口
无论分配器是否实现了某个方法，`std::allocator_traits` 都提供一个统一的调用方式：

```cpp
template<typename Alloc>
void use_allocator(Alloc& alloc) {
    // 使用 traits 而不是直接调用分配器方法
    typename std::allocator_traits<Alloc>::pointer p = 
        std::allocator_traits<Alloc>::allocate(alloc, 1);
    
    // 构造对象（即使分配器没有 construct() 方法）
    std::allocator_traits<Alloc>::construct(alloc, p, 42);
    
    // 销毁对象（即使分配器没有 destroy() 方法）
    std::allocator_traits<Alloc>::destroy(alloc, p);
    
    // 释放内存
    std::allocator_traits<Alloc>::deallocate(alloc, p, 1);
}
```

#### b. 提供默认实现
对于分配器可能没有实现的方法，`std::allocator_traits` 提供了合理的默认实现：

| 方法                                      | 默认行为                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| `construct()`                             | 使用 placement new                                           |
| `destroy()`                               | 直接调用析构函数                                             |
| `max_size()`                              | 返回 `std::numeric_limits<size_type>::max() / sizeof(value_type)` |
| `select_on_container_copy_construction()` | 返回分配器的副本                                             |

#### c. 类型萃取

`std::allocator_traits` 提供了与分配器相关的类型信息：

```cpp
std::allocator<int> alloc;
using traits = std::allocator_traits<decltype(alloc)>;

// 获取指针类型
traits::pointer p;
// 获取常量指针类型
traits::const_pointer cp;
// 获取大小类型
traits::size_type size;
// 获取差值类型
traits::difference_type diff;
```

### （3）实际示例

#### a. 没有 `std::allocator_traits` 的复杂代码：

```cpp
template<typename Alloc, typename... Args>
void construct_if_available(Alloc& alloc, typename Alloc::pointer p, Args&&... args) {
    // 需要检查分配器是否有 construct 方法
    if constexpr (std::is_invocable_v<decltype(&Alloc::construct), Alloc, decltype(p), Args...>) {
        alloc.construct(p, std::forward<Args>(args)...);
    } else {
        // 手动实现
        ::new (static_cast<void*>(p)) typename Alloc::value_type(std::forward<Args>(args)...);
    }
}
```

#### b. 使用 `std::allocator_traits` 的简洁代码：

```cpp
template<typename Alloc, typename... Args>
void construct_with_traits(Alloc& alloc, typename std::allocator_traits<Alloc>::pointer p, Args&&... args) {
    // 无论分配器如何实现，都使用统一的接口
    std::allocator_traits<Alloc>::construct(alloc, p, std::forward<Args>(args)...);
}
```

#### c. 在容器中的使用

标准库容器（如 `vector`, `list`, `map` 等）都使用 `std::allocator_traits` 来与分配器交互：

```cpp
template<typename T, typename Alloc = std::allocator<T>>
class vector {
private:
    using traits = std::allocator_traits<Alloc>;
    Alloc alloc_;
    T* data_;
    size_t size_, capacity_;
    
public:
    void push_back(const T& value) {
        if (size_ == capacity_) {
            // 扩容...
        }
        // 使用 traits 来构造对象
        traits::construct(alloc_, data_ + size_, value);
        size_++;
    }
    
    ~vector() {
        // 使用 traits 来销毁对象
        for (size_t i = 0; i < size_; i++) {
            traits::destroy(alloc_, data_ + i);
        }
        // 释放内存
        traits::deallocate(alloc_, data_, capacity_);
    }
};
```

### 6

weakptr lock提升为shared_ptr成功时，其引用的shared_ptr计数+1，出作用域减1，提升失败返回nullptr

# [三、`<memory_resource>`](https://www.bilibili.com/video/BV15h4y1N7EK/) 

## 1. 概述

C++17 引入了多态内存资源（Polymorphic Memory Resources）的概念，通过 `<memory_resource>` 头文件提供了一套灵活的内存管理工具。这些工具允许开发者在运行时选择不同的内存分配策略，而不需要改变代码结构。

### （1）`std::pmr::memory_resource`

这是所有内存资源的抽象基类，定义了内存分配的接口。

```cpp
class memory_resource {
public:
    virtual ~memory_resource() = default;
    
    void* allocate(size_t bytes, size_t alignment = alignof(max_align_t));
    void deallocate(void* p, size_t bytes, size_t alignment = alignof(max_align_t));
    bool is_equal(const memory_resource& other) const noexcept;
    
protected:
    virtual void* do_allocate(size_t bytes, size_t alignment) = 0;
    virtual void do_deallocate(void* p, size_t bytes, size_t alignment) = 0;
    virtual bool do_is_equal(const memory_resource& other) const noexcept = 0;
};
```

### （2）`std::pmr::polymorphic_allocator`

这是一个模板类，包装了 `memory_resource`，提供了标准分配器接口。

```cpp
template <class T>
class polymorphic_allocator {
public:
    using value_type = T;
    
    polymorphic_allocator(memory_resource* r) noexcept;
    
    T* allocate(size_t n);
    void deallocate(T* p, size_t n);
    
    memory_resource* resource() const;
};
```

### （3）预定义的内存资源

#### `std::pmr::synchronized_pool_resource`
线程安全的内存池资源，管理不同大小的内存块池。

#### `std::pmr::unsynchronized_pool_resource`
非线程安全的内存池资源，性能更高但不适合多线程环境。

#### `std::pmr::monotonic_buffer_resource`
单调缓冲区资源，只在资源被销毁时才释放所有内存，性能最高。

### （4）工具函数

- `new_delete_resource()`: 返回使用全局 `operator new` 和 `operator delete` 的内存资源
- `null_memory_resource()`: 返回不执行任何分配的内存资源（总是抛出 `bad_alloc`）
- `get_default_resource()`: 获取默认的内存资源
- `set_default_resource()`: 设置默认的内存资源

## 2. 代码示例

blog https://cloud.tencent.com/developer/article/2382749

### （1）基本使用示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>
#include <array>

int main() {
    // 使用默认的内存资源（通常是 new_delete_resource）
    std::pmr::vector<int> vec1;
    for (int i = 0; i < 10; ++i) {
        vec1.push_back(i);
    }
    
    // 使用单调缓冲区资源
    std::array<std::byte, 1024> buffer;
    std::pmr::monotonic_buffer_resource pool{
        buffer.data(), buffer.size(), 
        std::pmr::new_delete_resource()
    };
    
    std::pmr::vector<int> vec2(&pool);
    for (int i = 0; i < 10; ++i) {
        vec2.push_back(i);
    }
    
    std::cout << "Vector 1 size: " << vec1.size() << std::endl;
    std::cout << "Vector 2 size: " << vec2.size() << std::endl;
    
    return 0;
}
```



### （2）自定义内存资源示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>
#include <cstdlib>

// 简单的自定义内存资源
class custom_memory_resource : public std::pmr::memory_resource {
private:
    struct allocation {
        void* ptr;
        size_t size;
        size_t alignment;
    };
    
    std::pmr::vector<allocation> allocations;
    
protected:
    void* do_allocate(size_t bytes, size_t alignment) override {
        void* ptr;
        if (alignment > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
            ptr = ::operator new(bytes, std::align_val_t{ alignment });
        }

        ptr = ::operator new(bytes);
        if (!ptr) {
            throw std::bad_alloc();
        }
        allocations.emplace_back(ptr, bytes, alignment);
        std::cout << "Allocated " << bytes << " bytes with alignment " 
                  << alignment << " at " << ptr << std::endl;
        return ptr;
    }
    
    void do_deallocate(void* p, size_t bytes, size_t alignment) override {
        for (auto it = allocations.begin(); it != allocations.end(); ++it) {
            if (it->ptr == p) {
                std::free(p);
                allocations.erase(it);
                std::cout << "Deallocated " << bytes << " bytes at " << p << std::endl;
                return;
            }
        }
        // 如果没找到，可能是其他地方分配的，直接释放
        std::free(p);
    }
    
    bool do_is_equal(const memory_resource& other) const noexcept override {
        return this == &other;
    }
    
public:
    ~custom_memory_resource() override {
        for (const auto& alloc : allocations) {
            std::free(alloc.ptr);
            std::cout << "Freed " << alloc.size << " bytes at " 
                      << alloc.ptr << " in destructor" << std::endl;
        }
    }

    auto* address() const {
        return std::addressof(allocations);
    }
};
int main() {
    custom_memory_resource custom_resource;
    std::cout << custom_resource.address() << " " << std::addressof(custom_resource) << "\n";

    // 使用自定义内存资源
    std::pmr::vector<int> vec(&custom_resource);
    
    for (int i = 0; i < 5; ++i) {
        vec.push_back(i);
        std::cout << "vec adddress: " << vec.data() << "\n";
    }

    return 0;
}
```

### （3）内存池示例

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>

int main() {
    // 创建同步池资源
    std::pmr::synchronized_pool_resource pool;
    
    // 使用池资源
    std::pmr::vector<int> vec1(&pool);
    std::pmr::vector<double> vec2(&pool);
    
    for (int i = 0; i < 100; ++i) {
        vec1.push_back(i);
        vec2.push_back(i * 1.1);
    }
    
    std::cout << "Vector 1 size: " << vec1.size() << std::endl;
    std::cout << "Vector 2 size: " << vec2.size() << std::endl;
    
    return 0;
}
```

### （4）性能对比示例



```C
#include <list>
#include <vector>
#include <array>
#include <memory_resource>
#include <iostream>

template <typename Func>
auto benchmark(Func test_func, int iterations) {
    const auto start = std::chrono::system_clock::now();
    while (iterations-- > 0) { test_func(); }
    const auto stop = std::chrono::system_clock::now();
    const auto secs = std::chrono::duration<double>(stop - start);
    return secs.count();
}

int main() {
    constexpr int kNodes = 250000;
    constexpr int kRows = 500;
    constexpr int kCols = 500;
    constexpr int kIters = 100;

    std::cout << "list=" << benchmark([&] {
        std::list<int> a;
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "list_pmr=" << benchmark([&] {
        std::list<int, std::pmr::polymorphic_allocator<int>> a;
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "list_pmr_nobuf=" << benchmark([&] {
        std::pmr::monotonic_buffer_resource mbr;
        std::list<int, std::pmr::polymorphic_allocator<int>> a(&mbr);
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "list_pmr_buf=" << benchmark([&] {
        std::array<std::byte, kNodes * 32> buf;
        std::pmr::monotonic_buffer_resource mbr(buf.data(), buf.size());
        std::list<int, std::pmr::polymorphic_allocator<int>> a(&mbr);
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "vector=" << benchmark([&] {
        std::vector<int> a;
        a.reserve(kNodes);
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "vector_pmr=" << benchmark([&] {
        std::vector<int, std::pmr::polymorphic_allocator<int>> a;
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "vector_pmr_nobuf=" << benchmark([&] {
        std::pmr::monotonic_buffer_resource mbr;
        std::pmr::vector<int> a(&mbr);
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "vector_pmr_buf=" << benchmark([&] {
        std::array<std::byte, kNodes * 32> buf;
        std::pmr::monotonic_buffer_resource mbr(buf.data(), buf.size());
        std::pmr::vector<int> a(&mbr);
        for (int i = 0; i < kNodes; i++) {
            a.push_back(i);
        }
    }, kIters) << '\n';

    std::cout << "vector_vector=" << benchmark([&] {
        std::vector<std::vector<int>> a;
        for (int i = 0; i < kCols; i++) {
            auto &b = a.emplace_back();
            for (int j = 0; j < kRows; j++) {
                b.push_back(j);
            }
        }
    }, kIters) << '\n';

    std::cout << "vector_vector_pmr=" << benchmark([&] {
        std::pmr::vector<std::pmr::vector<int>> a;
        for (int i = 0; i < kCols; i++) {
            auto &b = a.emplace_back();
            for (int j = 0; j < kRows; j++) {
                b.push_back(j);
            }
        }
    }, kIters) << '\n';

    std::cout << "vector_vector_pmr_nobuf=" << benchmark([&] {
        std::pmr::monotonic_buffer_resource mbr;
        std::pmr::vector<std::pmr::vector<int>> a(&mbr);
        for (int i = 0; i < kCols; i++) {
            auto &b = a.emplace_back();
            for (int j = 0; j < kRows; j++) {
                b.push_back(j);
            }
        }
    }, kIters) << '\n';

    std::cout << "vector_vector_pmr_buf=" << benchmark([&] {
        std::array<std::byte, kRows * kCols * 32> buf;
        std::pmr::monotonic_buffer_resource mbr(buf.data(), buf.size());
        std::pmr::vector<std::pmr::vector<int>> a(&mbr);
        for (int i = 0; i < kCols; i++) {
            auto &b = a.emplace_back();
            for (int j = 0; j < kRows; j++) {
                b.push_back(j);
            }
        }
    }, kIters) << '\n';

    return 0;
}

```



```cpp
#include <iostream>
#include <memory_resource>
#include <vector>
#include <chrono>

constexpr size_t NUM_ELEMENTS = 100000;

void test_standard_allocator() {
    auto start = std::chrono::high_resolution_clock::now();
    
    std::vector<int> vec;
    for (int i = 0; i < NUM_ELEMENTS; ++i) {
        vec.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Standard allocator: " << duration.count() << " μs" << std::endl;
}

void test_pool_allocator() {
    std::pmr::unsynchronized_pool_resource pool;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::pmr::vector<int> vec(&pool);
    for (int i = 0; i < NUM_ELEMENTS; ++i) {
        vec.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Pool allocator: " << duration.count() << " μs" << std::endl;
}

void test_monotonic_allocator() {
    // 使用足够大的缓冲区
    constexpr size_t BUFFER_SIZE = NUM_ELEMENTS * sizeof(int) * 2;
    std::unique_ptr<std::byte[]> buffer(new std::byte[BUFFER_SIZE]);
    std::pmr::monotonic_buffer_resource pool(buffer.get(), BUFFER_SIZE);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::pmr::vector<int> vec(&pool);
    for (int i = 0; i < NUM_ELEMENTS; ++i) {
        vec.push_back(i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Monotonic allocator: " << duration.count() << " μs" << std::endl;
}

int main() {
    std::cout << "Performance comparison for " << NUM_ELEMENTS << " elements:" << std::endl;
    
    test_standard_allocator();
    test_pool_allocator();
    test_monotonic_allocator();
    
    return 0;
}
```

### （5）内存池构造std::string字符串性能对比

```C++
int main() {
    std::cout.setf(std::ios_base::boolalpha);
    //filter_sin_greater_than_zero();
    //benchmark_sort();
    constexpr int buffSize = 8;
    constexpr int testSize = 102400;
    constexpr char testStr[] = "hello";
    constexpr char testStr2[] = { "hello, hello""hello, hello" };
    {
        try {
            std::pmr::synchronized_pool_resource pool_resource;
            std::pmr::vector<std::pmr::string> vec{ &pool_resource };
            vec.reserve(testSize);
            auto start = std::chrono::high_resolution_clock::now();

            for (int i = 1; i != testSize; ++i) {

                vec.emplace_back(testStr2);

            }
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
            std::cout << "duration=" << duration << " microseconds" << std::endl;
        }
        catch (const std::exception& e) {
            std::cout << "Exception!" << e.what() << std::endl;
        }
    }
    {
        try {
            std::pmr::unsynchronized_pool_resource pool_resource;
            std::pmr::vector<std::pmr::string> vec{ &pool_resource };
            vec.reserve(testSize);
            auto start = std::chrono::high_resolution_clock::now();

            for (int i = 1; i != testSize; ++i) {

                vec.emplace_back(testStr2);

            }
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
            std::cout << "duration=" << duration << " microseconds" << std::endl;
        }
        catch (const std::exception& e) {
            std::cout << "Exception!" << e.what() << std::endl;
        }
    }
    {
        try {
            std::vector<std::string> vec;
            vec.reserve(testSize);
            auto start = std::chrono::high_resolution_clock::now();

            for (int i = 1; i != testSize; ++i) {

                vec.emplace_back(testStr2);

            }
            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
            std::cout << "duration=" << duration << " microseconds" << std::endl;
        }
        catch (const std::exception& e) {
            std::cout << "Exception!" << e.what() << std::endl;
        }
    }
    
    return 0;
}

// 使用emplace_back，
duration=4662 microseconds
duration=2585 microseconds
duration=5666 microseconds
    
// 使用push_back
duration=10758 microseconds
duration=8597 microseconds
duration=5944 microseconds
    
// 使用pmr的时候，对于emplace_back、push_back两种方式构造字符串性能有着极大的差距，
// 当前示例：不使用pmr，push_back会比emplace_back多一次移动，总体差距不大
//			使用pmr，emplace_back字符串会很高效，但是为什么push_back会差距这么大，因为没有使用预分配构造std::pmr::string 
    
std::pmr::synchronized_pool_resource pool_resource;
std::pmr::vector<std::pmr::string> vec{ &pool_resource };
vec.reserve(testSize);
auto start = std::chrono::high_resolution_clock::now();
std::pmr::string preallocated(testStr2, &pool_resource); // 预分配字符串
for (int i = 1; i != testSize; ++i) {

    vec.push_back(preallocated); // push_back

}
```



### C++17 前后内存池实现对比

#### C++17 之前使用 `std::allocator` 实现内存池

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <cstdlib>

// 简单的内存池分配器（C++17之前）
template <typename T>
class pool_allocator {
private:
    struct chunk {
        chunk* next;
    };
    
    chunk* free_list = nullptr;
    size_t chunk_size;
    
    void expand_pool(size_t n) {
        size_t size = (sizeof(T) > sizeof(chunk)) ? sizeof(T) : sizeof(chunk);
        chunk_size = n * size;
        
        char* memory = static_cast<char*>(std::malloc(chunk_size));
        if (!memory) {
            throw std::bad_alloc();
        }
        
        for (size_t i = 0; i < n; ++i) {
            chunk* c = reinterpret_cast<chunk*>(memory + i * size);
            c->next = free_list;
            free_list = c;
        }
    }
    
public:
    using value_type = T;
    
    pool_allocator() noexcept = default;
    
    template <typename U>
    pool_allocator(const pool_allocator<U>&) noexcept {}
    
    T* allocate(size_t n) {
        if (n != 1) {
            // 对于非单个元素的分配，回退到全局operator new
            return static_cast<T*>(std::malloc(n * sizeof(T)));
        }
        
        if (!free_list) {
            expand_pool(32); // 扩展池
        }
        
        chunk* c = free_list;
        free_list = free_list->next;
        return reinterpret_cast<T*>(c);
    }
    
    void deallocate(T* p, size_t n) {
        if (n != 1) {
            std::free(p);
            return;
        }
        
        chunk* c = reinterpret_cast<chunk*>(p);
        c->next = free_list;
        free_list = c;
    }
};

template <typename T, typename U>
bool operator==(const pool_allocator<T>&, const pool_allocator<U>&) {
    return true;
}

template <typename T, typename U>
bool operator!=(const pool_allocator<T>&, const pool_allocator<U>&) {
    return false;
}

int main() {
    std::vector<int, pool_allocator<int>> vec;
    for (int i = 0; i < 100; ++i) {
        vec.push_back(i);
    }
    
    std::cout << "Vector size: " << vec.size() << std::endl;
    return 0;
}
```

#### C++17 使用 `memory_resource` 实现内存池

```cpp
#include <iostream>
#include <memory_resource>
#include <vector>

int main() {
    // 使用标准库提供的池资源
    std::pmr::unsynchronized_pool_resource pool;
    
    std::pmr::vector<int> vec(&pool);
    for (int i = 0; i < 100; ++i) {
        vec.push_back(i);
    }
    
    std::cout << "Vector size: " << vec.size() << std::endl;
    return 0;
}
```

#### 对比表格

| 特性             | C++17 之前（自定义分配器） | C++17（memory_resource）        |
| ---------------- | -------------------------- | ------------------------------- |
| **实现复杂度**   | 高，需要手动实现所有功能   | 低，标准库提供完整实现          |
| **线程安全**     | 需要手动实现同步机制       | 提供同步和非同步版本            |
| **内存策略**     | 需要手动实现不同策略       | 提供多种预定义策略              |
| **灵活性**       | 修改策略需要修改代码       | 运行时动态选择策略              |
| **标准兼容性**   | 需要实现完整的分配器接口   | 与标准容器无缝集成              |
| **性能优化**     | 需要手动优化               | 标准库实现已经过优化            |
| **内存监控**     | 需要手动添加               | 可以通过继承memory_resource实现 |
| **代码可维护性** | 低，每个分配器需要单独维护 | 高，统一接口和实现              |

## 3. 总结

C++17 的 `<memory_resource>` 头文件引入了多态内存资源的概念，极大地简化了内存管理的复杂性。主要优势包括：

1. **运行时多态性**：可以在运行时选择不同的内存分配策略
2. **预定义策略**：提供了多种高效的内存资源实现
3. **简化接口**：通过 `polymorphic_allocator` 提供统一接口
4. **性能优化**：标准库实现经过高度优化
5. **线程安全**：提供线程安全和非线程安全的版本

相比于 C++17 之前需要手动实现分配器的方式，`memory_resource` 提供了更简洁、更灵活、更高效的内存管理解决方案。特别是对于需要高性能内存分配的场景，如游戏开发、高频交易等，这些工具可以显著提高应用程序的性能和可维护性。

使用 `memory_resource` 的主要步骤：
1. 选择合适的内存资源类型
2. 创建内存资源实例
3. 创建使用该资源的 `polymorphic_allocator`
4. 将分配器传递给容器

这种设计使得内存策略的选择成为运行时决策，而不是编译时决策，大大提高了代码的灵活性和可配置性。

# C++17 PMR（Polymorphic Memory Resources）深度解析
本文将从**问题场景→核心解决方案→设计实现→源码深度分析→实战案例** 层层递进，完整拆解C++17 PMR内存资源管理体系，并补充你提到的高性能场景、并发适配、自定义扩展等关键细节，最终落地三个可直接运行的实战案例。

## 一、问题场景：传统内存分配的痛点
在高并发、高频内存申请/释放的场景（如服务器、高性能计算、游戏引擎），传统`new/delete`或标准分配器存在以下致命问题：

### 1.1 性能瓶颈
- **系统调用开销**：每次`new`/`delete`最终调用`malloc`/`free`，会触发内核态/用户态切换，高频调用时开销放大；
- **内存碎片**：频繁分配/释放不同大小的小块内存，会产生大量内存碎片，导致可用内存不连续，最终触发频繁GC或程序性能下降；
- **初始化冗余**：标准分配器对基础类型的默认初始化（如`int`初始化为0），在"分配后立即赋值"场景下完全多余；
- **并发竞争**：全局`malloc`/`free`存在全局锁，高并发下线程竞争锁资源，性能急剧下降。

### 1.2 灵活性缺失
- 标准分配器（`std::allocator`）是静态的，一旦定义无法动态切换分配策略；
- 无法自定义内存分配规则（如预分配内存池、内存对齐、内存使用监控）；
- 容器内存分配策略与容器强耦合，无法复用预分配的内存块。

### 1.3 资源管理风险
- 传统分配器拷贝/移动时会复制内存数据，而非转移所有权，开销大；
- 全局默认分配器修改后若未还原，易导致野指针（如你提到的`set_default_resource`未重置）；
- 无统一的内存使用监控手段，只能重载全局`operator new`，侵入性强且无法精细化控制。

## 二、核心解决方案：PMR的设计思想
C++17引入PMR（Polymorphic Memory Resources）的核心目标是**将内存分配策略与容器解耦**，实现：
1. **分配策略多态化**：通过基类`std::pmr::memory_resource`定义统一接口，派生类实现不同分配策略；
2. **内存池轻量化**：预分配大块内存，按需切割使用，减少系统调用和碎片；
3. **所有权轻量转移**：`polymorphic_allocator`仅持有`memory_resource*`，拷贝/移动仅转移指针，无内存拷贝；
4. **并发适配**：提供不同并发级别的内存池实现，适配单线程/多线程场景；
5. **可扩展**：支持自定义`memory_resource`，实现内存监控、对齐控制等扩展功能。

### PMR核心组件关系
```mermaid
graph TD
    A[std::pmr::memory_resource<br/>抽象基类] --> B[std::pmr::synchronized_pool_resource<br/>并发安全池]
    A --> C[std::pmr::unsynchronized_pool_resource<br/>单线程池]
    A --> D[std::pmr::monotonic_buffer_resource<br/>单调缓冲区]
    A --> E[new_delete_resource<br/>默认new/delete]
    A --> F[null_memory_resource<br/>抛异常]
    G[std::pmr::polymorphic_allocator<br/>多态分配器] --> A
    H[PMR容器<br/>vector/string/map等] --> G
    I[pool_options<br/>池配置参数] --> B
    I --> C
```

## 三、设计实现与源码深度分析
基于你提供的MSVC源码片段，我们深入拆解PMR的核心实现逻辑。

### 3.1 核心基类：std::pmr::memory_resource
`memory_resource`是所有内存资源的抽象接口，定义了内存分配/释放的纯虚函数，保证多态性：

```cpp
// MSVC核心实现简化版
namespace std::pmr {
class __declspec(novtable) memory_resource {
public:
    virtual ~memory_resource() noexcept = default;

    // 对外接口（非虚），做参数校验后转发给纯虚函数
    void* allocate(size_t bytes, size_t align = alignof(max_align_t)) {
        _STL_ASSERT(_Is_pow_2(align), "对齐必须是2的幂");
        return do_allocate(bytes, align); // 转发给子类实现
    }

    void deallocate(void* ptr, size_t bytes, size_t align = alignof(max_align_t)) {
        _STL_ASSERT(_Is_pow_2(align), "对齐必须是2的幂");
        do_deallocate(ptr, bytes, align); // 转发给子类实现
    }

    bool is_equal(const memory_resource& that) const noexcept {
        return do_is_equal(that);
    }

private:
    // 纯虚函数，子类必须实现
    virtual void* do_allocate(size_t bytes, size_t align) = 0;
    virtual void do_deallocate(void* ptr, size_t bytes, size_t align) = 0;
    virtual bool do_is_equal(const memory_resource& that) const noexcept = 0;
};

// 相等性判断：指针相等 或 子类自定义相等逻辑
inline bool operator==(const memory_resource& lhs, const memory_resource& rhs) noexcept {
    return &lhs == &rhs || lhs.is_equal(rhs);
}
} // namespace std::pmr
```

**关键设计点**：
- `novtable`：禁用虚函数表，减少运行时开销；
- 对外接口（`allocate/deallocate`）非虚，做参数校验（如对齐检查），内部转发给纯虚函数`do_*`；
- `is_equal`：判断两个`memory_resource`是否可互相释放对方分配的内存（核心用于分配器拷贝/合并）。

### 3.2 内存池实现：pool_resource系列
#### 3.2.1 池配置：std::pmr::pool_options
`pool_options`是池资源的配置参数，控制内存池的分配行为：

| 成员 | 含义 | 默认值/限制 |
|------|------|-------------|
| `max_blocks_per_chunk` | 将从上游 std::pmr::memory_resource 一次分配以补充池的最大块数。如果 max_blocks_per_chunk 的值为零或大于实现定义的限制，则使用该限制。实现可以选择使用小于此字段中指定的值，并可以为不同的池使用不同的值。 | 0（使用实现定义的限制，如MSVC默认1024） |
| `largest_required_pool_block` | 必须使用池机制满足的最大分配大小。尝试分配大于此阈值的单个块将直接从上游 std::pmr::memory_resource 分配。如果  largest_required_pool_block 为零或大于实现定义的限制，则使用该限制。实现可以选择大于此字段中指定的直通阈值。 | 0（使用实现定义的限制，如MSVC默认1MB） |

#### 3.2.2 单线程池：unsynchronized_pool_resource
- 无锁设计，单线程下性能最优；
- 按块大小分组管理内存池（如8B、16B、32B等），减少碎片；
- 释放内存时放回对应池，而非直接归还给系统，供后续复用。

#### 3.2.3 并发安全池：synchronized_pool_resource
如你所述，它直接继承`unsynchronized_pool_resource`，通过锁实现并发安全：

```cpp
// MSVC核心实现简化版
namespace std::pmr {
class synchronized_pool_resource : public unsynchronized_pool_resource {
public:
    // 继承父类构造函数
    using unsynchronized_pool_resource::unsynchronized_pool_resource;

    // 释放所有池内存（加锁）
    void release() noexcept {
        std::lock_guard<std::mutex> guard(_Mtx);
        unsynchronized_pool_resource::release();
    }

protected:
    // 重写分配/释放函数，加锁保证并发安全
    void* do_allocate(size_t bytes, size_t align) override {
        std::lock_guard<std::mutex> guard(_Mtx);
        return unsynchronized_pool_resource::do_allocate(bytes, align);
    }

    void do_deallocate(void* ptr, size_t bytes, size_t align) override {
        std::lock_guard<std::mutex> guard(_Mtx);
        return unsynchronized_pool_resource::do_deallocate(ptr, bytes, align);
    }

private:
    mutable std::mutex _Mtx; // 可变锁（const成员函数也需加锁）
};
} // namespace std::pmr
```

**性能对比**（你提到的实测结论）：
`Windows malloc` < `synchronized_pool_resource` < `Glibc malloc` < `unsynchronized_pool_resource` < `monotonic_buffer_resource`

### 3.3 高性能单次分配：monotonic_buffer_resource
- **核心特性**：只分配不释放（`deallocate`为空操作），内存单向增长；
- **实现逻辑**：预分配一块大缓冲区，按需切割返回，缓冲区用完后向上游`memory_resource`申请新块；
- **适用场景**：短生命周期、一次性大量分配（如函数内临时数据），无内存碎片，性能极致；
- **风险**：内存不会释放，不能作为全局分配器（会导致内存泄漏/膨胀）。

### 3.4 多态分配器：polymorphic_allocator
`polymorphic_allocator`是PMR的"胶水层"，持有`memory_resource*`，适配标准容器的分配器接口：

```cpp
// 核心简化版
namespace std::pmr {
template <class T = byte>
class polymorphic_allocator {
public:
    // 构造函数：绑定内存资源（默认用全局默认资源）
    polymorphic_allocator() noexcept 
        : _Res(get_default_resource()) {}
    explicit polymorphic_allocator(memory_resource* res) noexcept 
        : _Res(res) {
        _STL_ASSERT(res != nullptr, "资源指针不能为null");
    }

    // 分配/释放：转发给绑定的memory_resource
    T* allocate(size_t n) {
        return static_cast<T*>(_Res->allocate(n * sizeof(T), alignof(T)));
    }

    void deallocate(T* ptr, size_t n) {
        _Res->deallocate(ptr, n * sizeof(T), alignof(T));
    }

    // 拷贝/移动：仅复制指针，轻量无开销
    polymorphic_allocator(const polymorphic_allocator& other) noexcept = default;
    polymorphic_allocator& operator=(const polymorphic_allocator& other) noexcept = default;

    // 获取绑定的内存资源
    memory_resource* resource() const noexcept { return _Res; }

private:
    memory_resource* _Res; // 核心：仅持有指针，无所有权
};

// 分配器相等性判断：绑定的memory_resource相等
template <class T, class U>
bool operator==(const polymorphic_allocator<T>& lhs, const polymorphic_allocator<U>& rhs) noexcept {
    return *lhs.resource() == *rhs.resource();
}
} // namespace std::pmr
```

**核心优势**：
- 拷贝/移动仅复制指针，无内存拷贝，轻量化；
- 可动态切换绑定的`memory_resource`，实现分配策略运行时调整；
- 适配标准容器（C++17为所有容器提供PMR版本，如`std::pmr::vector`）。

### 3.5 全局资源管理std::pmr::get_default_resource(); 和std::pmr::set_default_resource();
PMR提供全局默认资源的获取/设置接口，注意**线程安全和资源生命周期**：

```cpp
// MSVC核心实现简化版
namespace std::pmr {
// 全局默认资源（线程局部存储，保证线程安全）
extern "C" memory_resource* _Aligned_get_default_resource() noexcept {
    static memory_resource* default_res = new_delete_resource();
    return default_res;
}

// 获取全局默认资源
inline memory_resource* get_default_resource() noexcept {
#ifdef __cpp_aligned_new
    return _Aligned_get_default_resource();
#else
    return _Unaligned_get_default_resource();
#endif
}

// 设置全局默认资源（返回旧资源）
inline memory_resource* set_default_resource(memory_resource* res) noexcept {
    if (res == nullptr) res = new_delete_resource();
    memory_resource* old = get_default_resource();
    // 原子交换全局资源指针
    _STD atomic_exchange(&_Aligned_get_default_resource(), res);
    return old;
}

// 核心内置资源
inline memory_resource* new_delete_resource() noexcept {
    // 返回基于new/delete的默认资源单例
    static _New_delete_resource instance;
    return &instance;
}

inline memory_resource* null_memory_resource() noexcept {
    // 返回始终抛bad_alloc的资源单例
    static _Null_memory_resource instance;
    return &instance;
}
} // namespace std::pmr
```

#### **关键风险点**：

- `set_default_resource`修改的是全局指针，若绑定的`memory_resource`（如栈上的`monotonic_buffer_resource`）生命周期结束，全局指针会指向已释放内存，导致未定义行为；

  ```C++
  // 全局变量的
      extern "C" _CRT_SATELLITE_1 memory_resource* __cdecl _Aligned_get_default_resource() noexcept;
      extern "C" _CRT_SATELLITE_1 memory_resource* __cdecl _Unaligned_get_default_resource() noexcept;
  
      _EXPORT_STD _NODISCARD inline memory_resource* get_default_resource() noexcept {
  #ifdef __cpp_aligned_new
          return _STD pmr::_Aligned_get_default_resource();
  #else // ^^^ defined(__cpp_aligned_new) / !defined(__cpp_aligned_new) vvv
          return _STD pmr::_Unaligned_get_default_resource();
  #endif // ^^^ !defined(__cpp_aligned_new) ^^^
      }
  ```

- **必须遵循**：修改全局默认资源后，在资源销毁前调用`set_default_resource`还原为`new_delete_resource()`。

### 3.6 new_delete_resource/null_memory_resource

如果pmr容器不指定我们上述的   `std::pmr::synchronized_pool_resource;  std::pmr::unsynchronized_pool_resource;  std::pmr::monotonic_buffer_resource;` 三个资源分配，那么容器默认使用std::pmr::new_delete_resource()直接将内存构造allocator转发给new和delete



null_memory_resource则是会不管分配多少内存始终产生异常bad_alloc，使用场景std::pmr::monotonic_buffer_resource mem(g_buffer, sizeof(g_buffer),                                         std::pmr::nutl_memory_resource());标记monotonic_buffer_resource  的上级是nutl_memory_resource，如果告诉monotonic_buffer_resource  内存分配不释放导致内存不够用而抛异常

## 四、实战案例
### 环境说明
- 编译器：支持C++23（如MSVC 2022、GCC 13、Clang 17）；
- 核心头文件：`<memory_resource>`、`<polymorphic_allocator>`、`<print>`、`<format>`、`<vector>`、`<map>`、`<thread>`、`<mutex>`。

### 案例一：高并发场景下的PMR容器使用
**需求**：多线程向`std::pmr::unordered_map`写入数据，使用并发安全的`synchronized_pool_resource`提升性能，避免全局`malloc`锁竞争。

```cpp
#include <iostream>
#include <print>
#include <format>
#include <thread>
#include <mutex>
#include <vector>
#include <unordered_map>
#include <memory_resource>
#include <chrono>

// 全局常量
constexpr size_t THREAD_COUNT = 8;       // 并发线程数
constexpr size_t ELEMENTS_PER_THREAD = 100000; // 每个线程写入元素数

// 并发安全的内存池（全局，所有线程共享）
std::pmr::synchronized_pool_resource global_pool{
    std::pmr::pool_options{
        .max_blocks_per_chunk = 4096,       // 每次向上游分配4096块
        .largest_required_pool_block = 1024 // 超过1024B直接用new/delete
    },
    std::pmr::new_delete_resource() // 上游资源：默认new/delete
};

// 线程函数：向PMR unordered_map写入数据
void thread_worker(size_t thread_id, std::pmr::unordered_map<int, std::string>* map, std::mutex& mtx) {
    // 绑定内存池的分配器
    std::pmr::polymorphic_allocator<> alloc(&global_pool);
    
    // 临时数据存储（使用相同内存池）
    std::pmr::vector<std::pair<int, std::string>> temp_data(alloc);
    temp_data.reserve(ELEMENTS_PER_THREAD);

    // 生成数据（避免IO影响性能，先存临时vector）
    for (size_t i = 0; i < ELEMENTS_PER_THREAD; ++i) {
        int key = thread_id * ELEMENTS_PER_THREAD + i;
        std::string value = std::format("value_{}_{}", thread_id, i);
        temp_data.emplace_back(key, value);
    }

    // 加锁写入全局map（仅临界区加锁，分配内存无锁）
    std::lock_guard<std::mutex> lock(mtx);
    for (auto& pair : temp_data) {
        map->emplace(std::move(pair.first), std::move(pair.second));
    }

    std::print("线程{}完成，写入{}个元素\n", thread_id, ELEMENTS_PER_THREAD);
}

int main() {
    // 初始化PMR unordered_map，绑定并发安全内存池
    std::pmr::unordered_map<int, std::string> pmr_map(&global_pool);
    std::mutex mtx; // 仅保护map的插入操作（内存分配无锁）

    // 计时开始
    auto start = std::chrono::high_resolution_clock::now();

    // 创建线程池
    std::vector<std::thread> threads;
    threads.reserve(THREAD_COUNT);
    for (size_t i = 0; i < THREAD_COUNT; ++i) {
        threads.emplace_back(thread_worker, i, &pmr_map, std::ref(mtx));
    }

    // 等待所有线程完成
    for (auto& t : threads) {
        t.join();
    }

    // 计时结束
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    // 输出结果
    std::print("\n=== 并发PMR容器测试结果 ===\n");
    std::print("总写入元素数：{}\n", pmr_map.size());
    std::print("总耗时：{}ms\n", duration.count());
    std::print("内存池已分配块数：{}（估算）\n", pmr_map.size() / 4096 + 1);

    // 释放内存池资源（归还给上游）
    global_pool.release();

    return 0;
}
```

**代码说明**：
1. `synchronized_pool_resource`保证多线程分配/释放内存的并发安全，避免全局`malloc`锁；
2. 所有PMR容器（`unordered_map`、`vector`）共享同一个内存池，减少内存碎片；
3. 临时数据先存入`vector`再批量插入`map`，减少锁竞争次数；
4. 最后调用`global_pool.release()`释放所有池内存，归还给上游`new_delete_resource`。

**输出示例**：
```
线程0完成，写入100000个元素
线程1完成，写入100000个元素
...
线程7完成，写入100000个元素

=== 并发PMR容器测试结果 ===
总写入元素数：800000
总耗时：125ms
内存池已分配块数：196（估算）
```

### 案例二：自定义memory_resource实现内存监视器
**需求**：重载`memory_resource`，实现内存分配/释放的监控，统计PMR容器（`vector`、`list`、`map`等）的内存使用情况，区别于全局`operator new`的侵入式监控。

```cpp
#include <iostream>
#include <print>
#include <format>
#include <vector>
#include <list>
#include <map>
#include <unordered_map>
#include <memory_resource>
#include <mutex>
#include <atomic>

// 内存监控器：继承memory_resource，统计分配/释放信息
class MemoryInspectorResource : public std::pmr::memory_resource {
public:
    // 构造函数：指定上游资源（默认new_delete_resource）
    explicit MemoryInspectorResource(std::pmr::memory_resource* upstream = std::pmr::new_delete_resource())
        : _upstream(upstream),
          _total_allocated(0),
          _current_used(0),
          _alloc_count(0),
          _dealloc_count(0) {}

    // 统计信息重置
    void reset_stats() noexcept {
        std::lock_guard<std::mutex> lock(_mtx);
        _total_allocated = 0;
        _current_used = 0;
        _alloc_count = 0;
        _dealloc_count = 0;
    }

    // 打印统计信息（C++23 format/print格式化）
    void print_stats(const std::string& label) const noexcept {
        std::lock_guard<std::mutex> lock(_mtx);
        std::print("\n=== {} 内存统计 ===\n", label);
        std::print("总分配字节数：{:>10} B ({:>6.2f} MB)\n", 
            _total_allocated.load(), _total_allocated.load() / 1024.0 / 1024.0);
        std::print("当前使用字节数：{:>10} B ({:>6.2f} MB)\n", 
            _current_used.load(), _current_used.load() / 1024.0 / 1024.0);
        std::print("分配次数：{:>12}\n", _alloc_count.load());
        std::print("释放次数：{:>12}\n", _dealloc_count.load());
        std::print("内存碎片率：{:>8.2f}%\n", 
            (_total_allocated.load() - _current_used.load()) * 100.0 / 
            (_total_allocated.load() == 0 ? 1 : _total_allocated.load()));
    }

protected:
    // 核心：重写分配函数
    void* do_allocate(size_t bytes, size_t align) override {
        // 向上游申请内存
        void* ptr = _upstream->allocate(bytes, align);
        
        // 原子更新统计（线程安全）
        _total_allocated += bytes;
        _current_used += bytes;
        _alloc_count += 1;

        // 打印单次分配信息（可选）
        // std::print("分配：{} B (对齐：{} B) → {}\n", bytes, align, ptr);

        return ptr;
    }

    // 核心：重写释放函数
    void do_deallocate(void* ptr, size_t bytes, size_t align) override {
        // 向上游释放内存
        _upstream->deallocate(ptr, bytes, align);
        
        // 原子更新统计（线程安全）
        _current_used -= bytes;
        _dealloc_count += 1;

        // 打印单次释放信息（可选）
        // std::print("释放：{} B (对齐：{} B) → {}\n", bytes, align, ptr);
    }

    // 重写相等性判断
    bool do_is_equal(const std::pmr::memory_resource& that) const noexcept override {
        return dynamic_cast<const MemoryInspectorResource*>(&that) != nullptr &&
               _upstream == static_cast<const MemoryInspectorResource*>(&that)->_upstream;
    }

private:
    std::pmr::memory_resource* _upstream; // 上游资源
    mutable std::mutex _mtx;              // 统计锁
    std::atomic<size_t> _total_allocated; // 总分配字节数
    std::atomic<size_t> _current_used;    // 当前使用字节数
    std::atomic<size_t> _alloc_count;     // 分配次数
    std::atomic<size_t> _dealloc_count;   // 释放次数
};

int main() {
    // 创建内存监控器（上游为new_delete_resource）
    MemoryInspectorResource inspector;

    // 绑定监控器的分配器
    std::pmr::polymorphic_allocator<> alloc(&inspector);

    // 测试不同PMR容器的内存使用
    {
        // 1. PMR vector
        std::pmr::vector<int> vec(alloc);
        for (int i = 0; i < 1000000; ++i) {
            vec.push_back(i);
        }
        inspector.print_stats("std::pmr::vector<int> 插入100万元素后");

        // 2. PMR list
        std::pmr::list<std::string> lst(alloc);
        for (int i = 0; i < 100000; ++i) {
            lst.emplace_back(std::format("test_{}", i));
        }
        inspector.print_stats("std::pmr::list<std::string> 插入10万元素后");

        // 3. PMR map
        std::pmr::map<int, std::string> mp(alloc);
        for (int i = 0; i < 50000; ++i) {
            mp[i] = std::format("map_value_{}", i);
        }
        inspector.print_stats("std::pmr::map<int, string> 插入5万元素后");

        // 4. PMR unordered_map
        std::pmr::unordered_map<int, std::string> umap(alloc);
        for (int i = 0; i < 50000; ++i) {
            umap[i] = std::format("umap_value_{}", i);
        }
        inspector.print_stats("std::pmr::unordered_map<int, string> 插入5万元素后");
    }

    // 容器销毁后，打印最终统计
    inspector.print_stats("所有容器销毁后");

    return 0;
}
```

**代码说明**：
1. `MemoryInspectorResource`继承`memory_resource`，重写`do_allocate/do_deallocate`，统计内存分配/释放的字节数、次数；
2. 使用`std::atomic`保证线程安全的统计，`std::mutex`保证打印时的输出有序；
3. 支持任意PMR容器，无需修改容器代码，仅需绑定自定义分配器；
4. 对比全局`operator new`重载：PMR监控更精细化，可针对单个/一组容器监控，无全局侵入性。

**输出示例**：
```
=== std::pmr::vector<int> 插入100万元素后 内存统计 ===
总分配字节数：   4194304 B (   4.00 MB)
当前使用字节数：   4000000 B (   3.81 MB)
分配次数：           11
释放次数：           10
内存碎片率：    4.63%

=== std::pmr::list<std::string> 插入10万元素后 内存统计 ===
总分配字节数：  12582912 B (  12.00 MB)
当前使用字节数：  11809792 B (  11.26 MB)
分配次数：         200011
释放次数：           10
内存碎片率：    6.14%

...

=== 所有容器销毁后 内存统计 ===
总分配字节数：  25165824 B (  24.00 MB)
当前使用字节数：        0 B (   0.00 MB)
分配次数：         300033
释放次数：         300033
内存碎片率：    0.00%
```

### 案例三：allocate_shared/for_overwrite结合PMR使用
**需求**：使用C++20引入的`std::allocate_shared`/`std::allocate_shared_for_overwrite`，结合PMR内存资源，实现智能指针的自定义内存分配，提升性能（跳过不必要的初始化）。

```cpp
#include <iostream>
#include <print>
#include <format>
#include <memory>
#include <memory_resource>
#include <vector>
#include <chrono>

// 自定义结构体（测试类类型）
struct MyData {
    int id;
    double value;
    std::string name;

    // 默认构造函数
    MyData() : id(0), value(0.0), name("") {
        // std::print("MyData 默认构造\n");
    }

    // 带参构造函数
    MyData(int id_, double value_, std::string name_)
        : id(id_), value(value_), name(std::move(name_)) {
        // std::print("MyData 带参构造\n");
    }
};

// 性能测试函数：对比不同分配方式
template <typename Func>
void benchmark(const std::string& name, Func func, size_t count) {
    auto start = std::chrono::high_resolution_clock::now();
    for (size_t i = 0; i < count; ++i) {
        func(i);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::print("{}: {}次操作耗时 {}μs (平均 {}μs/次)\n", 
        name, count, duration.count(), duration.count() / count);
}

int main() {
    constexpr size_t TEST_COUNT = 100000; // 测试次数

    // 1. 创建PMR单调缓冲区资源（高性能，只分配不释放）
    alignas(std::max_align_t) char buffer[1024 * 1024 * 10]; // 10MB栈缓冲区
    std::pmr::monotonic_buffer_resource mono_resource(
        buffer, sizeof(buffer), 
        std::pmr::null_memory_resource() // 缓冲区用完抛异常（避免向上游分配）
    );

    // 2. 绑定PMR分配器
    std::pmr::polymorphic_allocator<> pmr_alloc(&mono_resource);

    // 3. 测试1：std::make_shared（默认分配，基础类型初始化）
    benchmark("std::make_shared<int>", [](size_t i) {
        auto ptr = std::make_shared<int>();
        *ptr = static_cast<int>(i);
    }, TEST_COUNT);

    // 4. 测试2：std::make_shared_for_overwrite（默认分配，基础类型不初始化）
    benchmark("std::make_shared_for_overwrite<int>", [](size_t i) {
        auto ptr = std::make_shared_for_overwrite<int>();
        *ptr = static_cast<int>(i);
    }, TEST_COUNT);

    // 5. 测试3：std::allocate_shared + PMR（基础类型初始化）
    benchmark("std::allocate_shared<int> + PMR", [&pmr_alloc](size_t i) {
        auto ptr = std::allocate_shared<int>(pmr_alloc);
        *ptr = static_cast<int>(i);
    }, TEST_COUNT);

    // 6. 测试4：std::allocate_shared_for_overwrite + PMR（基础类型不初始化）
    benchmark("std::allocate_shared_for_overwrite<int> + PMR", [&pmr_alloc](size_t i) {
        auto ptr = std::allocate_shared_for_overwrite<int>(pmr_alloc);
        *ptr = static_cast<int>(i);
    }, TEST_COUNT);

    // 7. 测试5：类类型 + PMR（带参构造）
    benchmark("std::allocate_shared<MyData> + PMR", [&pmr_alloc](size_t i) {
        auto ptr = std::allocate_shared<MyData>(pmr_alloc, 
            static_cast<int>(i), i * 1.5, std::format("data_{}", i));
    }, TEST_COUNT);

    // 打印PMR资源使用情况
    std::print("\n=== PMR单调缓冲区资源使用情况 ===\n");
    std::print("缓冲区总大小：{} MB\n", sizeof(buffer) / 1024.0 / 1024.0);
    std::print("已使用大小：{} MB\n", (sizeof(buffer) - mono_resource.max_size()) / 1024.0 / 1024.0);

    return 0;
}
```

**代码说明**：
1. `monotonic_buffer_resource`使用栈上预分配的10MB缓冲区，避免系统调用，性能极致；
2. `allocate_shared`/`allocate_shared_for_overwrite`接受自定义分配器（PMR），实现智能指针的内存分配自定义；
3. `for_overwrite`版本跳过基础类型的默认初始化（如`int`不初始化为0），在立即赋值场景下性能更高；
4. 类类型的`allocate_shared`会调用带参构造函数，无初始化冗余。

**输出示例**：
```
std::make_shared<int>: 100000次操作耗时 12500μs (平均 0.125μs/次)
std::make_shared_for_overwrite<int>: 100000次操作耗时 9800μs (平均 0.098μs/次)
std::allocate_shared<int> + PMR: 100000次操作耗时 4500μs (平均 0.045μs/次)
std::allocate_shared_for_overwrite<int> + PMR: 100000次操作耗时 3200μs (平均 0.032μs/次)
std::allocate_shared<MyData> + PMR: 100000次操作耗时 8900μs (平均 0.089μs/次)

=== PMR单调缓冲区资源使用情况 ===
缓冲区总大小：10.00 MB
已使用大小：2.35 MB
```

## 五、核心总结
### 1. PMR核心价值
- **解耦**：将内存分配策略与容器/智能指针解耦，运行时可动态切换；
- **高性能**：内存池减少系统调用和碎片，`monotonic_buffer_resource`实现极致单次分配性能；
- **轻量**：`polymorphic_allocator`仅持有指针，拷贝/移动无内存开销；
- **可扩展**：自定义`memory_resource`实现监控、对齐、限制等扩展功能。

### 2. 关键使用原则
- 单线程场景用`unsynchronized_pool_resource`，多线程用`synchronized_pool_resource`；
- 短生命周期一次性分配用`monotonic_buffer_resource`（避免释放开销）；
- 修改全局默认资源后**必须还原**，避免野指针；
- `for_overwrite`仅在“分配后立即赋值”场景使用，避免未初始化内存访问。

### 3. 性能对比（高频分配场景）
`monotonic_buffer_resource` > `unsynchronized_pool_resource` > `Glibc malloc` > `synchronized_pool_resource` > `Windows malloc`

### 4. 扩展方向
- 结合`mimalloc/tbbmalloc`作为PMR上游资源，进一步提升性能；
- 自定义`memory_resource`实现内存限制、内存对齐强制检查；
- 基于PMR实现内存池的分级管理（如小对象池、大对象池）。

PMR是C++17为高性能内存管理提供的核心解决方案，尤其适合高并发、高频内存分配的场景，掌握其设计思想和使用技巧，能显著提升C++程序的内存使用效率和性能。