# pb_ds

[C++ pb_dsåº“æŒ‡å—ï¼šè§£é”STLä¹‹å¤–æ•°æ®ç»“æ„](https://zhuanlan.zhihu.com/p/1932110357138245407#:~:text=pb_ds%20%EF%BC%88Policy-Based%20Data%20Structures%EF%BC%89%E6%98%AFGNU%20C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%AF%9E%E7%94%9F%E4%BA%8E%E5%AF%B9STL%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E7%81%B5%E6%B4%BB%E6%80%A7%E4%B8%8D%E8%B6%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82,%E5%AE%83%E9%87%87%E7%94%A8%20%E7%AD%96%E7%95%A5%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%20%E7%90%86%E5%BF%B5%EF%BC%8C%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%E5%92%8C%E8%8A%82%E7%82%B9%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%AF%94STL%E6%9B%B4%E9%AB%98%E6%95%88%E3%80%81%E6%9B%B4%E5%8F%AF%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%82%20%E2%84%B9%EF%B8%8F%20%E4%B8%8ESTL%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A%E9%9D%9E%E6%9B%BF%E4%BB%A3%E5%93%81%E8%80%8C%E6%98%AF%E5%A2%9E%E5%BC%BA%E5%8C%85%E3%80%82%20STL%E6%BB%A1%E8%B6%B3%E9%80%9A%E7%94%A8%E6%80%A7%EF%BC%8Cpb_ds%E4%B8%93%E6%B3%A8%E9%AB%98%E6%80%A7%E8%83%BD%E5%9C%BA%E6%99%AF)

GCCçš„PBDSï¼Œå…¨ç§°ä¸ºâ€œPolicy-Based Data Structuresâ€ï¼Œæ˜¯GNU C++æ ‡å‡†åº“æä¾›çš„ä¸€å¥—åŠŸèƒ½å¼ºå¤§ä¸”å¯é«˜åº¦å®šåˆ¶çš„æ•°æ®ç»“æ„æ‰©å±•åº“ã€‚å®ƒè¢«ç§°ä¸ºâ€œå¹³æ¿ç”µè§†â€ï¼Œä¸»è¦æ˜¯ä¸ºäº†å¼¥è¡¥æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰åœ¨æŸäº›åœºæ™¯ä¸‹çš„æ€§èƒ½æˆ–åŠŸèƒ½ä¸è¶³ã€‚

> å®‰è£… MinGW  min GCC of Windows , é€‚é…Windowsçš„GCCä»£ç ï¼Œ\c++\ext\pb_ds
>
> æˆ–è€…å®‰è£… vcpkg å®‰è£… perl ï¼Œ  \vcpkg-2025.06.13\downloads\tools\perl\5.40.2.1\c\include\c++\13.2.0\ext\pb_ds

## ğŸ“¦ æ ¸å¿ƒæ•°æ®ç»“æ„ä¸€è§ˆ
ä¸‹è¡¨æ•´ç†äº†PBDSåº“ä¸­å‡ ä¸ªæœ€å¸¸ç”¨å’Œæ ¸å¿ƒçš„ç»„ä»¶ï¼Œä»¥åŠå®ƒä»¬ä¸STLçš„å¯¹æ¯”ï¼š

| æ•°æ®ç»“æ„ç±»å‹      | å¯¹åº”PBDSå®¹å™¨                       | æ ¸å¿ƒç‰¹ç‚¹ / ä¼˜åŠ¿                                              | å…¸å‹åº”ç”¨åœºæ™¯                                          |
| :---------------- | :--------------------------------- | :----------------------------------------------------------- | :---------------------------------------------------- |
| **æœ‰åºé›†åˆ/æ˜ å°„** | `tree`                             | æ”¯æŒ**æ’åæŸ¥è¯¢**ï¼ˆ`order_of_key`ï¼‰å’Œ**æŒ‰æ’åæŸ¥æ‰¾**ï¼ˆ`find_by_order`ï¼‰ï¼Œè¿™æ˜¯STLçš„`set/map`ä¸å…·å¤‡çš„é«˜çº§åŠŸèƒ½ã€‚åº•å±‚é€šå¸¸ä¸ºçº¢é»‘æ ‘ã€‚ | éœ€è¦æŸ¥è¯¢ç¬¬Kå¤§å…ƒç´ ã€å…ƒç´ æ’åçš„é¢˜ç›®ï¼ˆå¦‚å¹³è¡¡æ ‘æ¨¡æ¿é¢˜ï¼‰ã€‚ |
| **å“ˆå¸Œè¡¨**        | `gp_hash_table`<br>`cc_hash_table` | é€šå¸¸**æ¯”STLçš„`unordered_map`æ›´å¿«**ã€‚`gp_hash_table`ï¼ˆæ¢æµ‹æ³•ï¼‰é»˜è®¤æ›´å¿«ï¼›`cc_hash_table`ï¼ˆæ‹‰é“¾æ³•ï¼‰åœ¨æŸäº›é«˜å†²çªåœºæ™¯æ›´ç¨³å®šã€‚ | éœ€è¦æé€ŸæŸ¥æ‰¾ã€æ’å…¥ï¼Œä¸”å…è®¸ä½¿ç”¨éæ ‡å‡†åº“çš„åœºæ™¯ã€‚        |
| **ä¼˜å…ˆé˜Ÿåˆ— (å †)** | `priority_queue`                   | æ”¯æŒ**é«˜æ•ˆåˆå¹¶**ï¼ˆ`join`ï¼ŒæŸäº›å®ç°ä¸ºO(1)ï¼‰å’Œ**ä¿®æ”¹å †ä¸­ä»»æ„å…ƒç´ **ï¼ˆ`modify`ï¼‰ã€‚æä¾›å¤šç§åº•å±‚å®ç°ï¼ˆå¦‚é…å¯¹å †ã€äºŒå‰å †ï¼‰ã€‚ | å›¾ç®—æ³•ä¼˜åŒ–ï¼ˆå¦‚Dijkstraï¼‰ã€éœ€è¦åˆå¹¶å †çš„æ“ä½œã€‚          |
| **Trie (å­—å…¸æ ‘)** | `trie`, `pat_trie`                 | æä¾›æ ‡å‡†å­—å…¸æ ‘å’Œå‹ç¼©å‰ç¼€æ ‘ï¼ˆPatricia Trieï¼‰ï¼Œæ–¹ä¾¿è¿›è¡Œå‰ç¼€åŒ¹é…ç­‰å­—ç¬¦ä¸²æ“ä½œã€‚ | å­—ç¬¦ä¸²å‰ç¼€æŸ¥è¯¢ã€æœ€é•¿å…¬å…±å‰ç¼€ç­‰ã€‚                      |
| **å¯æŒä¹…åŒ–æ•°ç»„**  | `rope` (ä½äº`__gnu_cxx`)           | æ”¯æŒ**O(âˆšn)æˆ–O(log n)çš„éšæœºæ’å…¥å’Œåˆ é™¤**ï¼Œå¯ä»¥åƒ`vector`ä¸€æ ·ä½¿ç”¨ï¼Œä½†åŠŸèƒ½æ›´å¼ºã€‚ | æ–‡æœ¬ç¼–è¾‘å™¨ã€éœ€è¦å¤§é‡éšæœºæ’å…¥åˆ é™¤çš„åºåˆ—é—®é¢˜ã€‚          |

## âš–ï¸ ä¸»è¦ä¼˜åŠ¿ä¸é™åˆ¶
### **ä¸»è¦ä¼˜åŠ¿3**
1.  **æ€§èƒ½ä¼˜åŠ¿**ï¼šå…¶å“ˆå¸Œè¡¨ï¼ˆ`gp_hash_table`ï¼‰å’Œå †ï¼ˆå¦‚`pairing_heap_tag`ï¼‰åœ¨æ€§èƒ½ä¸Šé€šå¸¸ä¼˜äºSTLå¯¹åº”å®¹å™¨ã€‚
2.  **åŠŸèƒ½æ‰©å±•**ï¼šæä¾›äº†STLå®¹å™¨æ²¡æœ‰çš„å®ç”¨åŠŸèƒ½ï¼Œä¾‹å¦‚`tree`çš„æ’åæŸ¥è¯¢ã€å †çš„åˆå¹¶ä¸ä¿®æ”¹ã€‚
3.  **ç­–ç•¥å®šåˆ¶**ï¼šå…è®¸é€šè¿‡æ¨¡æ¿å‚æ•°å®šåˆ¶æ•°æ®ç»“æ„çš„è¡Œä¸ºï¼Œä¾‹å¦‚é€‰æ‹©ä¸åŒçš„å¹³è¡¡æ ‘ç±»å‹æˆ–å“ˆå¸Œå‡½æ•°ã€‚

### **é‡è¦é™åˆ¶ä¸æ³¨æ„äº‹é¡¹**
1.  **ç¼–è¯‘å™¨ä¾èµ–**ï¼šPBDSæ˜¯**GCCï¼ˆg++ï¼‰çš„æ‰©å±•åº“**ï¼Œä¸æ˜¯C++æ ‡å‡†çš„ä¸€éƒ¨åˆ†ã€‚è¿™æ„å‘³ç€åœ¨**MSVCï¼ˆVisual Studioï¼‰æˆ–Clangï¼ˆé™¤éé“¾æ¥libstdc++åº“ï¼‰ä¸‹æ— æ³•ä½¿ç”¨**ã€‚
2.  **å‘½åç©ºé—´**ï¼šæ‰€æœ‰ç»„ä»¶ä½äº `__gnu_pbds` å‘½åç©ºé—´ä¸­ï¼ˆ`rope` åœ¨ `__gnu_cxx`ï¼‰ã€‚ä¸ºäº†é¿å…ä¸STLçš„åŒåå®¹å™¨ï¼ˆå¦‚`priority_queue`ï¼‰å†²çªï¼Œé€šå¸¸å»ºè®®æ˜¾å¼æŒ‡å®šå‘½åç©ºé—´æˆ–ä½¿ç”¨ç±»å‹åˆ«åã€‚
3.  **ç«èµ›å¯ç”¨æ€§**ï¼šåœ¨**å›½å†…NOIç³»åˆ—ä¿¡æ¯å­¦ç«èµ›ä¸­ï¼Œå…è®¸ä½¿ç”¨PBDSåº“**ã€‚ä½†åœ¨å…¶ä»–å¹³å°æˆ–å·¥ç¨‹é¡¹ç›®ä¸­éœ€è°¨æ…è€ƒè™‘å…¶å¯ç§»æ¤æ€§ã€‚

# ğŸ”§ åŸºç¡€ä½¿ç”¨

# <assoc_container.hpp>

## ä¸€ã€ æ¦‚è¿°

`assoc_container.hpp` æ˜¯GCCçš„pb_dsï¼ˆPolicy-Based Data Structuresï¼‰åº“çš„ä¸€éƒ¨åˆ†ï¼Œæä¾›äº†ä¸€ç³»åˆ—é«˜åº¦å¯é…ç½®çš„å…³è”å®¹å™¨ã€‚è¿™äº›å®¹å™¨é€šè¿‡ç­–ç•¥ï¼ˆpolicyï¼‰æ¥å®šåˆ¶åº•å±‚æ•°æ®ç»“æ„çš„è¡Œä¸ºï¼Œä½¿å¾—å¼€å‘è€…å¯ä»¥æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©æœ€åˆé€‚çš„æ•°æ®ç»“æ„ã€‚

pb_dsåº“ä¸»è¦æä¾›ä»¥ä¸‹ä¸‰ç§ç±»å‹çš„å…³è”å®¹å™¨ï¼š

1. **å“ˆå¸Œå®¹å™¨ï¼ˆHash-based containersï¼‰**ï¼šåŒ…æ‹¬ç¢°æ’é“¾å“ˆå¸Œè¡¨ï¼ˆ`cc_hash_table`ï¼‰å’Œçº¿æ€§æ¢æµ‹å“ˆå¸Œè¡¨ï¼ˆ`gp_hash_table`ï¼‰ã€‚
2. **åˆ†æ”¯å®¹å™¨ï¼ˆBranch-based containersï¼‰**ï¼šåŒ…æ‹¬æ ‘ï¼ˆ`tree`ï¼‰å’Œå­—å…¸æ ‘ï¼ˆ`trie`ï¼‰ã€‚
3. **åˆ—è¡¨æ›´æ–°å®¹å™¨ï¼ˆList-based containersï¼‰**ï¼šåŒ…æ‹¬åˆ—è¡¨æ›´æ–°å®¹å™¨ï¼ˆ`list_update`ï¼‰ã€‚

è¿™äº›å®¹å™¨åœ¨åŠŸèƒ½ä¸Šç±»ä¼¼äºC++æ ‡å‡†åº“ä¸­çš„å…³è”å®¹å™¨ï¼ˆå¦‚`std::map`ã€`std::unordered_map`ï¼‰ï¼Œä½†æä¾›äº†æ›´å¤šçš„ç­–ç•¥å’Œé…ç½®é€‰é¡¹ã€‚

### 1. ä¸»è¦ç‰¹ç‚¹

pb_dsï¼ˆPolicy-Based Data Structuresï¼‰æ˜¯ GCC æ‰©å±•åº“ï¼Œæä¾›äº†é«˜åº¦å¯é…ç½®çš„å…³è”å®¹å™¨ï¼š

- **å¤šç­–ç•¥æ”¯æŒ**ï¼šé€šè¿‡æ¨¡æ¿å‚æ•°é…ç½®åº•å±‚æ•°æ®ç»“æ„çš„è¡Œä¸º
- **æ€§èƒ½ä¼˜åŒ–**ï¼šé’ˆå¯¹ä¸åŒä½¿ç”¨åœºæ™¯æä¾›å¤šç§æ•°æ®ç»“æ„
- **åŠŸèƒ½ä¸°å¯Œ**ï¼šæ”¯æŒå“ˆå¸Œè¡¨ã€å¹³è¡¡æ ‘ã€å­—å…¸æ ‘ç­‰å¤šç§ç»“æ„
- **è‡ªå®šä¹‰ç­–ç•¥**ï¼šå…è®¸ç”¨æˆ·å®šä¹‰æ¯”è¾ƒå‡½æ•°ã€å“ˆå¸Œå‡½æ•°ã€èŠ‚ç‚¹æ›´æ–°ç­–ç•¥ç­‰

### 2. ä¸æ ‡å‡†åº“å…³è”å®¹å™¨çš„å¯¹æ¯”

| ç‰¹æ€§         | GCC pb_dsåº“                                        | C++æ ‡å‡†åº“                        |
| ------------ | -------------------------------------------------- | -------------------------------- |
| å“ˆå¸Œè¡¨å®ç°   | æä¾›ä¸¤ç§ï¼šç¢°æ’é“¾å’Œçº¿æ€§æ¢æµ‹                         | é€šå¸¸åªæœ‰ä¸€ç§å®ç°ï¼ˆå–å†³äºç¼–è¯‘å™¨ï¼‰ |
| æ ‘ç»“æ„       | æ”¯æŒå¤šç§æ ‘ï¼šçº¢é»‘æ ‘ã€ä¼¸å±•æ ‘ã€æœ‰åºå‘é‡æ ‘             | é€šå¸¸åªæœ‰çº¢é»‘æ ‘ï¼ˆå¦‚`std::map`ï¼‰   |
| å­—å…¸æ ‘       | æä¾›å­—å…¸æ ‘ï¼ˆtrieï¼‰                                 | ä¸æä¾›                           |
| åˆ—è¡¨æ›´æ–°å®¹å™¨ | æä¾›åŸºäºåˆ—è¡¨çš„æ›´æ–°å®¹å™¨                             | ä¸æä¾›                           |
| ç­–ç•¥é…ç½®     | é«˜åº¦å¯é…ç½®ï¼Œå¯ä»¥æŒ‡å®šå“ˆå¸Œå‡½æ•°ã€æ¯”è¾ƒå‡½æ•°ã€è°ƒæ•´ç­–ç•¥ç­‰ | é…ç½®é€‰é¡¹æœ‰é™                     |
| å­˜å‚¨å“ˆå¸Œå€¼   | å¯ä»¥é€‰æ‹©æ˜¯å¦å­˜å‚¨å“ˆå¸Œå€¼ä»¥åŠ å¿«é‡æ–°å“ˆå¸Œ               | ä¸å¯é€‰                           |
| æ€§èƒ½è°ƒä¼˜     | é€šè¿‡ç­–ç•¥è°ƒæ•´å¯ä»¥é’ˆå¯¹ç‰¹å®šåœºæ™¯ä¼˜åŒ–                   | é€šå¸¸ä¸ºé€šç”¨åœºæ™¯è®¾è®¡               |

pb_dsåº“çš„å®¹å™¨åœ¨æ€§èƒ½ä¸Šå¯èƒ½ä¼˜äºæ ‡å‡†åº“å®¹å™¨ï¼Œç‰¹åˆ«æ˜¯åœ¨ç‰¹å®šåœºæ™¯ä¸‹é€šè¿‡ç­–ç•¥è°ƒä¼˜åã€‚ä½†æ˜¯ï¼Œç”±äºé…ç½®å¤æ‚ï¼Œéœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚è¿›è¡Œé€‰æ‹©ã€‚

## äºŒã€å®šä¹‰çš„ç±»åŠå…¶ä½œç”¨

### 1. **å“ˆå¸Œè¡¨å®¹å™¨ (Hash-Based Containers)**

#### `basic_hash_table`

å“ˆå¸Œè¡¨çš„æŠ½è±¡åŸºç±»ï¼Œé€šè¿‡ç­–ç•¥å‚æ•°æ´¾ç”Ÿå‡ºå…·ä½“å®ç°ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `Key`ï¼šé”®ç±»å‹
- `Mapped`ï¼šå€¼ç±»å‹
- `Hash_Fn`ï¼šå“ˆå¸Œå‡½æ•°
- `Eq_Fn`ï¼šç›¸ç­‰æ¯”è¾ƒå‡½æ•°
- `Resize_Policy`ï¼šè°ƒæ•´å¤§å°ç­–ç•¥
- `Store_Hash`ï¼šæ˜¯å¦å­˜å‚¨å“ˆå¸Œå€¼
- `Tag`ï¼šå“ˆå¸Œè¡¨ç±»å‹æ ‡ç­¾

#### `cc_hash_table` (ç¢°æ’é“¾å“ˆå¸Œè¡¨)

ä½¿ç”¨é“¾åœ°å€æ³•è§£å†³å†²çªçš„å“ˆå¸Œè¡¨ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `Comb_Hash_Fn`ï¼šç»„åˆå“ˆå¸Œå‡½æ•°

#### `gp_hash_table` (é€šç”¨æ¢æµ‹å“ˆå¸Œè¡¨)

ä½¿ç”¨æ¢æµ‹æ³•ï¼ˆå¦‚çº¿æ€§æ¢æµ‹ã€äºŒæ¬¡æ¢æµ‹ï¼‰è§£å†³å†²çªçš„å“ˆå¸Œè¡¨ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `Comb_Probe_Fn`ï¼šç»„åˆæ¢æµ‹å‡½æ•°
- `Probe_Fn`ï¼šæ¢æµ‹å‡½æ•°

### 2. **åˆ†æ”¯å®¹å™¨ (Branch-Based Containers)**

#### `basic_branch`

æ ‘å’Œå­—å…¸æ ‘çš„æŠ½è±¡åŸºç±»ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `Tag`ï¼šå®¹å™¨ç±»å‹æ ‡ç­¾
- `Node_Update`ï¼šèŠ‚ç‚¹æ›´æ–°ç­–ç•¥

#### `tree` (å¹³è¡¡æ ‘)

æ”¯æŒå¤šç§å¹³è¡¡æ ‘çš„å®ç°ï¼Œå¦‚çº¢é»‘æ ‘ã€ä¼¸å±•æ ‘ç­‰ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `Cmp_Fn`ï¼šæ¯”è¾ƒå‡½æ•°
- `Tag`ï¼šæ ‘ç±»å‹æ ‡ç­¾
- `Node_Update`ï¼šèŠ‚ç‚¹æ›´æ–°ç­–ç•¥

#### `trie` (å­—å…¸æ ‘)

å‰ç¼€æ ‘å®ç°ï¼Œç”¨äºå­—ç¬¦ä¸²æˆ–åºåˆ—çš„å¿«é€Ÿæ£€ç´¢ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `_ATraits`ï¼šå…ƒç´ è®¿é—®ç‰¹æ€§
- `Tag`ï¼šå­—å…¸æ ‘ç±»å‹æ ‡ç­¾
- `Node_Update`ï¼šèŠ‚ç‚¹æ›´æ–°ç­–ç•¥

### 3. **åˆ—è¡¨æ›´æ–°å®¹å™¨ (List-Based Containers)**

#### `list_update`

åŸºäºåˆ—è¡¨çš„å…³è”å®¹å™¨ï¼Œæ”¯æŒç¼“å­˜å‹å¥½çš„è®¿é—®æ¨¡å¼ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**

- `Eq_Fn`ï¼šç›¸ç­‰æ¯”è¾ƒå‡½æ•°
- `Update_Policy`ï¼šæ›´æ–°ç­–ç•¥

------

## ä¸‰ã€C++ æ ‡å‡†åº“çš„å¹³æ›¿åŠŸèƒ½

### 1. å¯ä»¥ç›´æ¥å¹³æ›¿çš„åŠŸèƒ½

| pb_ds åŠŸèƒ½                     | C++ æ ‡å‡†åº“å¹³æ›¿       | è¯´æ˜                     |
| ------------------------------ | -------------------- | ------------------------ |
| `cc_hash_table`                | `std::unordered_map` | åŠŸèƒ½ç±»ä¼¼ï¼Œéƒ½æ˜¯å“ˆå¸Œè¡¨     |
| `gp_hash_table`                | `std::unordered_map` | å®ç°æ–¹å¼ä¸åŒï¼Œä½†æ¥å£ç±»ä¼¼ |
| `tree` (rb_tree_tag)           | `std::map`           | çº¢é»‘æ ‘å®ç°çš„æœ‰åºæ˜ å°„     |
| åŸºæœ¬æ“ä½œ (insert, find, erase) | å¯¹åº”æ ‡å‡†åº“æ“ä½œ       | æ¥å£åŸºæœ¬å…¼å®¹             |

### 2. pb_ds ç‹¬æœ‰çš„åŠŸèƒ½

| pb_ds åŠŸèƒ½   | C++ æ ‡å‡†åº“è¿‘ä¼¼å®ç°     | è¯´æ˜                             |
| ------------ | ---------------------- | -------------------------------- |
| å¤šç§å“ˆå¸Œç­–ç•¥ | éœ€è¦æ‰‹åŠ¨å®ç°           | pb_ds æä¾›å¤šç§å“ˆå¸Œå†²çªè§£å†³æ–¹æ¡ˆ   |
| å­—å…¸æ ‘æ”¯æŒ   | éœ€è¦ç¬¬ä¸‰æ–¹åº“æˆ–æ‰‹åŠ¨å®ç° | æ ‡å‡†åº“æ²¡æœ‰å­—å…¸æ ‘å®ç°             |
| èŠ‚ç‚¹æ›´æ–°ç­–ç•¥ | æ— ç›´æ¥å¯¹åº”             | pb_ds å…è®¸è‡ªå®šä¹‰èŠ‚ç‚¹ç»´æŠ¤é€»è¾‘     |
| å¤šç±»å‹å¹³è¡¡æ ‘ | éœ€è¦ä¸åŒåº“             | pb_ds æ”¯æŒçº¢é»‘æ ‘ã€ä¼¸å±•æ ‘ç­‰å¤šç§æ ‘ |

### 3. æ€§èƒ½å¯¹æ¯”

| æ“ä½œç±»å‹     | pb_ds ä¼˜åŠ¿åœºæ™¯            | æ ‡å‡†åº“ä¼˜åŠ¿åœºæ™¯        |
| ------------ | ------------------------- | --------------------- |
| å¤§é‡æ’å…¥åˆ é™¤ | å¯é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„ä¼˜åŒ–  | é€šç”¨åœºæ™¯è¡¨ç°ç¨³å®š      |
| å‰ç¼€æœç´¢     | `trie` å®¹å™¨æ•ˆç‡æé«˜       | éœ€è¦å¤æ‚å®ç°          |
| æœ‰åºéå†     | `tree` å®¹å™¨æ”¯æŒå¤šç§å¹³è¡¡æ ‘ | `std::map` ç¨³å®šä½†å•ä¸€ |
| å†…å­˜ä½¿ç”¨     | å¯é…ç½®å­˜å‚¨ç­–ç•¥ä¼˜åŒ–        | å›ºå®šå®ç°              |

## å››ã€ä½¿ç”¨ç¤ºä¾‹

```cpp
#include <print>
#include <string>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/trie_policy.hpp>

using namespace __gnu_pbds;

int main() {
    // 1. ç¢°æ’é“¾å“ˆå¸Œè¡¨ç¤ºä¾‹
    std::println("=== ç¢°æ’é“¾å“ˆå¸Œè¡¨ç¤ºä¾‹ ===");
    
    cc_hash_table<std::string, int> cc_ht;
    cc_ht["apple"] = 5;
    cc_ht["banana"] = 3;
    cc_ht["orange"] = 8;
    
    std::println("å“ˆå¸Œè¡¨å¤§å°: {}", cc_ht.size());
    std::println("apple çš„æ•°é‡: {}", cc_ht["apple"]);
    
    // éå†å“ˆå¸Œè¡¨
    for (const auto& [key, value] : cc_ht) {
        std::println("{}: {}", key, value);
    }
    
    // 2. é€šç”¨æ¢æµ‹å“ˆå¸Œè¡¨ç¤ºä¾‹
    std::println("\n=== é€šç”¨æ¢æµ‹å“ˆå¸Œè¡¨ç¤ºä¾‹ ===");
    
    gp_hash_table<int, std::string> gp_ht;
    gp_ht[1] = "one";
    gp_ht[2] = "two";
    gp_ht[3] = "three";
    
    // æŸ¥æ‰¾æ“ä½œ
    auto it = gp_ht.find(2);
    if (it != gp_ht.end()) {
        std::println("æ‰¾åˆ°é”® 2: {}", it->second);
    }
    
    // åˆ é™¤æ“ä½œ
    gp_ht.erase(1);
    std::println("åˆ é™¤åå¤§å°: {}", gp_ht.size());
    
    // 3. çº¢é»‘æ ‘ç¤ºä¾‹
    std::println("\n=== çº¢é»‘æ ‘ç¤ºä¾‹ ===");
    
    tree<int, std::string, std::less<int>, rb_tree_tag> rb_tree;
    rb_tree.insert({1, "one"});
    rb_tree.insert({3, "three"});
    rb_tree.insert({2, "two"});
    
    // æœ‰åºéå†
    std::println("æœ‰åºéå†:");
    for (const auto& [key, value] : rb_tree) {
        std::println("{}: {}", key, value);
    }
    
    // æŸ¥æ‰¾ç¬¬ k å°çš„å…ƒç´ 
    auto kth_it = rb_tree.find_by_order(1);  // 0-based
    if (kth_it != rb_tree.end()) {
        std::println("ç¬¬ 2 å°çš„å…ƒç´ : {}: {}", kth_it->first, kth_it->second);
    }
    
    // 4. å­—å…¸æ ‘ç¤ºä¾‹
    std::println("\n=== å­—å…¸æ ‘ç¤ºä¾‹ ===");
    
    trie<std::string, int, pat_trie_tag> my_trie;
    my_trie["hello"] = 1;
    my_trie["world"] = 2;
    my_trie["help"] = 3;
    my_trie["hel"] = 4;
    
    std::println("å­—å…¸æ ‘å¤§å°: {}", my_trie.size());
    
    // å‰ç¼€æœç´¢
    std::println("ä»¥ 'hel' ä¸ºå‰ç¼€çš„é”®:");
    auto prefix_range = my_trie.prefix_range("hel");
    for (auto it = prefix_range.first; it != prefix_range.second; ++it) {
        std::println("  {}", it->first);
    }
    
    // 5. åˆ—è¡¨æ›´æ–°å®¹å™¨ç¤ºä¾‹
    std::println("\n=== åˆ—è¡¨æ›´æ–°å®¹å™¨ç¤ºä¾‹ ===");
    
    list_update<std::string, int> lu_container;
    lu_container["first"] = 1;
    lu_container["second"] = 2;
    lu_container["third"] = 3;
    
    // è®¿é—®ä¼šæ›´æ–°å…ƒç´ ä½ç½®ï¼ˆæ ¹æ®ç­–ç•¥ï¼‰
    std::println("è®¿é—®å‰:");
    for (const auto& [key, value] : lu_container) {
        std::println("  {}: {}", key, value);
    }
    
    // æŸ¥æ‰¾æ“ä½œä¼šç§»åŠ¨å…ƒç´ åˆ°å‰é¢
    lu_container.find("third");
    
    std::println("è®¿é—® third å:");
    for (const auto& [key, value] : lu_container) {
        std::println("  {}: {}", key, value);
    }
    
    // 6. è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ç¤ºä¾‹
    std::println("\n=== è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ç¤ºä¾‹ ===");
    
    struct custom_hash {
        std::size_t operator()(const std::string& s) const {
            std::size_t hash = 0;
            for (char c : s) {
                hash = hash * 31 + c;
            }
            return hash;
        }
    };
    
    cc_hash_table<std::string, int, custom_hash> custom_ht;
    custom_ht["test"] = 42;
    std::println("è‡ªå®šä¹‰å“ˆå¸Œè¡¨ test çš„å€¼: {}", custom_ht["test"]);
    
    return 0;
}
```



### ä»£ç è¯´æ˜

#### 1. ç¢°æ’é“¾å“ˆå¸Œè¡¨ç¤ºä¾‹

- å±•ç¤ºäº† `cc_hash_table` çš„åŸºæœ¬ä½¿ç”¨
- æ”¯æŒç±»ä¼¼ `std::unordered_map` çš„æ¥å£
- ä½¿ç”¨é“¾åœ°å€æ³•è§£å†³å“ˆå¸Œå†²çª

#### 2. é€šç”¨æ¢æµ‹å“ˆå¸Œè¡¨ç¤ºä¾‹

- å±•ç¤ºäº† `gp_hash_table` çš„ä½¿ç”¨
- ä½¿ç”¨æ¢æµ‹æ³•è§£å†³å“ˆå¸Œå†²çª
- æ¥å£ä¸æ ‡å‡†åº“å“ˆå¸Œè¡¨å…¼å®¹

#### 3. çº¢é»‘æ ‘ç¤ºä¾‹

- å±•ç¤ºäº† `tree` å®¹å™¨çš„ä½¿ç”¨
- æ”¯æŒæœ‰åºéå†å’Œé¡ºåºç»Ÿè®¡
- `find_by_order()` å¯ä»¥æŸ¥æ‰¾ç¬¬ k å°çš„å…ƒç´ 

#### 4. å­—å…¸æ ‘ç¤ºä¾‹

- å±•ç¤ºäº† `trie` å®¹å™¨çš„ä½¿ç”¨
- æ”¯æŒå‰ç¼€æœç´¢å’Œé«˜æ•ˆå­—ç¬¦ä¸²æ£€ç´¢
- `prefix_range()` å¯ä»¥è·å–æŒ‡å®šå‰ç¼€çš„æ‰€æœ‰é”®

#### 5. åˆ—è¡¨æ›´æ–°å®¹å™¨ç¤ºä¾‹

- å±•ç¤ºäº† `list_update` å®¹å™¨çš„ä½¿ç”¨
- è®¿é—®å…ƒç´ ä¼šæ ¹æ®æ›´æ–°ç­–ç•¥è°ƒæ•´ä½ç½®
- é€‚ç”¨äºç¼“å­˜å‹å¥½çš„è®¿é—®æ¨¡å¼

#### 6. è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ç¤ºä¾‹

- å±•ç¤ºäº†å¦‚ä½•ä¸º pb_ds å®¹å™¨æä¾›è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°
- æ”¯æŒç”¨æˆ·å®šä¹‰çš„å“ˆå¸Œç­–ç•¥

------

## äº”ã€é«˜çº§ç”¨æ³•ç¤ºä¾‹

```cpp
#include <print>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

// è‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°ç­–ç•¥ï¼Œç»´æŠ¤å­æ ‘å¤§å°
template<typename Node_CItr, typename Node_Itr,
         typename Cmp_Fn, typename _Alloc>
class custom_node_update {
public:
    typedef int metadata_type;
    
    // æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯
    void operator()(Node_Itr it, Node_CItr end_it) {
        Node_Itr l_child = it.get_l_child();
        Node_Itr r_child = it.get_r_child();
        
        int left_size = 0, right_size = 0;
        if (l_child != end_it) left_size = l_child.get_metadata();
        if (r_child != end_it) right_size = r_child.get_metadata();
        
        // å½“å‰èŠ‚ç‚¹çš„å…ƒæ•°æ® = å·¦å­æ ‘å¤§å° + å³å­æ ‘å¤§å° + 1
        const_cast<metadata_type&>(it.get_metadata()) = 
            left_size + right_size + 1;
    }
    
    // æŸ¥æ‰¾ç¬¬ k å°çš„å…ƒç´ 
    typename Node_CItr::value_type
    find_by_order(Node_CItr it, int k) const {
        Node_CItr end_it = it;
        while (it != end_it) {
            Node_CItr l_child = it.get_l_child();
            Node_CItr r_child = it.get_r_child();
            
            int left_size = 0;
            if (l_child != end_it) left_size = l_child.get_metadata();
            
            if (k == left_size) {
                return *it;
            } else if (k < left_size) {
                it = l_child;
            } else {
                k -= left_size + 1;
                it = r_child;
            }
        }
        return end_it->second;
    }
};

int main() {
    std::println("=== é«˜çº§ç”¨æ³•ï¼šè‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–° ===");
    
    // ä½¿ç”¨è‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°ç­–ç•¥çš„æ ‘
    tree<int, std::string, std::less<int>, 
         rb_tree_tag, custom_node_update> advanced_tree;
    
    // æ’å…¥å…ƒç´ 
    advanced_tree.insert({5, "five"});
    advanced_tree.insert({3, "three"});
    advanced_tree.insert({7, "seven"});
    advanced_tree.insert({1, "one"});
    advanced_tree.insert({9, "nine"});
    
    // éå†
    std::println("æ ‘å†…å®¹:");
    for (const auto& [key, value] : advanced_tree) {
        std::println("  {}: {}", key, value);
    }
    
    // ä½¿ç”¨è‡ªå®šä¹‰çš„ find_by_order
    // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦è®¿é—®èŠ‚ç‚¹çš„å…ƒæ•°æ®
    std::println("ç¬¬ 3 å°çš„å…ƒç´ : {}", 
                 advanced_tree.node_begin().get_metadata());
    
    // 2. å¤šé‡é›†ç¤ºä¾‹ï¼ˆå…è®¸é‡å¤é”®ï¼‰
    std::println("\n=== å¤šé‡é›†ç¤ºä¾‹ ===");
    
    tree<int, null_type, std::less<int>, 
         rb_tree_tag, tree_order_statistics_node_update> multiset_tree;
    
    multiset_tree.insert(5);
    multiset_tree.insert(3);
    multiset_tree.insert(5);  // å…è®¸é‡å¤
    multiset_tree.insert(7);
    multiset_tree.insert(3);  // å…è®¸é‡å¤
    
    std::println("å¤šé‡é›†å†…å®¹:");
    for (const auto& key : multiset_tree) {
        std::println("  {}", key);
    }
    
    // ç»Ÿè®¡å°äºç­‰äº 5 çš„å…ƒç´ æ•°é‡
    int count = multiset_tree.order_of_key(6);  // ä¸¥æ ¼å°äº 6 çš„å…ƒç´ æ•°é‡
    std::println("å°äº 6 çš„å…ƒç´ æ•°é‡: {}", count);
    
    // æŸ¥æ‰¾ç¬¬ 3 å°çš„å…ƒç´ ï¼ˆ0-basedï¼‰
    auto kth = multiset_tree.find_by_order(2);
    if (kth != multiset_tree.end()) {
        std::println("ç¬¬ 3 å°çš„å…ƒç´ : {}", *kth);
    }
    
    return 0;
}
```



### é«˜çº§ç‰¹æ€§è¯´æ˜

#### 1. è‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°ç­–ç•¥

- å…è®¸åœ¨æ ‘èŠ‚ç‚¹ä¸­å­˜å‚¨é¢å¤–ä¿¡æ¯
- åœ¨æ’å…¥ã€åˆ é™¤æ—¶è‡ªåŠ¨æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯
- å¯ç”¨äºå®ç°é¡ºåºç»Ÿè®¡ã€åŒºé—´å’Œç­‰é«˜çº§åŠŸèƒ½

#### 2. å¤šé‡é›†æ”¯æŒ

- é€šè¿‡ `null_type` ä½œä¸ºå€¼ç±»å‹å®ç°å¤šé‡é›†
- é…åˆ `tree_order_statistics_node_update` æ”¯æŒé¡ºåºç»Ÿè®¡
- `order_of_key()` è¿”å›ä¸¥æ ¼å°äºç»™å®šé”®çš„å…ƒç´ æ•°é‡
- `find_by_order()` è¿”å›ç¬¬ k å°çš„å…ƒç´ 

#### 3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

- å¯é€‰æ‹©ä¸åŒçš„å“ˆå¸Œå‡½æ•°å’Œå†²çªè§£å†³ç­–ç•¥
- å¯è°ƒæ•´æ ‘çš„å¹³è¡¡ç­–ç•¥
- å¯é…ç½®æ˜¯å¦å­˜å‚¨å“ˆå¸Œå€¼ä»¥ä¼˜åŒ–æ€§èƒ½

------

## å…­ã€æ€»ç»“

GCC pb_ds åº“æä¾›äº†ä¸€å¥—åŠŸèƒ½ä¸°å¯Œã€é«˜åº¦å¯é…ç½®çš„å…³è”å®¹å™¨ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **å¤šæ ·æ€§**ï¼šæä¾›å“ˆå¸Œè¡¨ã€å¹³è¡¡æ ‘ã€å­—å…¸æ ‘ã€åˆ—è¡¨æ›´æ–°ç­‰å¤šç§æ•°æ®ç»“æ„
2. **å¯é…ç½®æ€§**ï¼šé€šè¿‡ç­–ç•¥æ¨¡å¼æ”¯æŒé«˜åº¦å®šåˆ¶
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé’ˆå¯¹ä¸åŒä½¿ç”¨åœºæ™¯æä¾›ä¼˜åŒ–é€‰é¡¹
4. **é«˜çº§åŠŸèƒ½**ï¼šæ”¯æŒé¡ºåºç»Ÿè®¡ã€å‰ç¼€æœç´¢ã€èŠ‚ç‚¹æ›´æ–°ç­‰é«˜çº§åŠŸèƒ½
5. **å…¼å®¹æ€§**ï¼šæ¥å£è®¾è®¡å°½é‡ä¸æ ‡å‡†åº“å…¼å®¹ï¼Œä¾¿äºè¿ç§»

ä¸ C++ æ ‡å‡†åº“ç›¸æ¯”ï¼Œpb_ds åœ¨ä»¥ä¸‹åœºæ™¯ä¸­æ›´å…·ä¼˜åŠ¿ï¼š

1. **éœ€è¦ç‰¹å®šæ•°æ®ç»“æ„**ï¼šå¦‚å­—å…¸æ ‘ã€å¤šç§å¹³è¡¡æ ‘ç­‰
2. **éœ€è¦é«˜çº§ç»Ÿè®¡åŠŸèƒ½**ï¼šå¦‚é¡ºåºç»Ÿè®¡ã€å‰ç¼€æœç´¢ç­‰
3. **éœ€è¦æ€§èƒ½è°ƒä¼˜**ï¼šå¯æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä¼˜çš„æ•°æ®ç»“æ„
4. **éœ€è¦è‡ªå®šä¹‰è¡Œä¸º**ï¼šå¦‚è‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°ç­–ç•¥

ç„¶è€Œï¼Œpb_ds æ˜¯ GCC æ‰©å±•ï¼Œä¸æ˜¯ C++ æ ‡å‡†çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤åœ¨è·¨å¹³å°å’Œç¼–è¯‘å™¨å…¼å®¹æ€§æ–¹é¢éœ€è¦æ³¨æ„ã€‚å¯¹äºéœ€è¦æ ‡å‡†å…¼å®¹æ€§çš„é¡¹ç›®ï¼Œåº”ä¼˜å…ˆä½¿ç”¨ C++ æ ‡å‡†åº“çš„å…³è”å®¹å™¨ã€‚

# <hash_policy.hpp>

## ä¸€ã€æ¦‚è¿°

`hash_policy.hpp` æ˜¯ GCC çš„ PBDSï¼ˆPolicy-Based Data Structuresï¼‰åº“ä¸­ä¸“é—¨ç”¨äºå®šä¹‰å“ˆå¸Œè¡¨ç­–ç•¥çš„å¤´æ–‡ä»¶ã€‚è¯¥æ–‡ä»¶æä¾›äº†å¤šç§å“ˆå¸Œç­–ç•¥å’Œè°ƒæ•´å¤§å°ç­–ç•¥ï¼Œå…è®¸ç”¨æˆ·é«˜åº¦å®šåˆ¶å“ˆå¸Œè¡¨çš„è¡Œä¸ºã€‚è¿™äº›ç­–ç•¥ä½¿å¾— `gp_hash_table` å’Œ `cc_hash_table` èƒ½å¤Ÿæ ¹æ®ä¸åŒçš„ä½¿ç”¨åœºæ™¯è¿›è¡Œä¼˜åŒ–ã€‚

### ä¸»è¦åŠŸèƒ½å’Œä½œç”¨

1. **å“ˆå¸Œå‡½æ•°å®šåˆ¶**ï¼šæä¾›å¤šç§é¢„å®šä¹‰å“ˆå¸Œå‡½æ•°ï¼Œä¹Ÿæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°ã€‚
2. **å†²çªè§£å†³ç­–ç•¥**ï¼šå®šä¹‰äº†å“ˆå¸Œå†²çªçš„è§£å†³æ–¹æ³•ï¼ŒåŒ…æ‹¬é“¾åœ°å€æ³•ï¼ˆchainingï¼‰å’Œå¼€æ”¾åœ°å€æ³•ï¼ˆopen addressingï¼‰ã€‚
3. **è°ƒæ•´å¤§å°ç­–ç•¥**ï¼šæ§åˆ¶å“ˆå¸Œè¡¨åœ¨è´Ÿè½½å› å­è¾¾åˆ°é˜ˆå€¼æ—¶å¦‚ä½•é‡æ–°å“ˆå¸Œå’Œæ‰©å®¹ã€‚
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡ç­–ç•¥ç»„åˆå®ç°ä¸åŒåœºæ™¯ä¸‹çš„æ€§èƒ½ä¼˜åŒ–ï¼Œå¦‚æŸ¥æ‰¾å¯†é›†ã€æ’å…¥å¯†é›†ç­‰ã€‚

### ä¸æ ‡å‡†åº“ C++ `std::hash` çš„åŒºåˆ«

| ç‰¹æ€§             | PBDS `hash_policy.hpp`                         | C++ æ ‡å‡†åº“ `std::hash`               |
| ---------------- | ---------------------------------------------- | ------------------------------------ |
| **ç­–ç•¥å¯é…ç½®æ€§** | é«˜åº¦å¯é…ç½®ï¼Œæ”¯æŒå¤šç§å“ˆå¸Œç­–ç•¥å’Œè°ƒæ•´ç­–ç•¥         | å›ºå®šå®ç°ï¼Œåªèƒ½é€šè¿‡ç‰¹åŒ–è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•° |
| **å†²çªè§£å†³æ–¹å¼** | æ”¯æŒé“¾åœ°å€æ³•å’Œå¤šç§æ¢æµ‹æ³•ï¼ˆçº¿æ€§ã€äºŒæ¬¡ã€éšæœºç­‰ï¼‰ | å®ç°å®šä¹‰ï¼Œé€šå¸¸ä¸ºé“¾åœ°å€æ³•             |
| **è°ƒæ•´ç­–ç•¥**     | æä¾›å¤šç§è´Ÿè½½å› å­é˜ˆå€¼å’Œè°ƒæ•´ç®—æ³•                 | å®ç°å®šä¹‰ï¼Œé€šå¸¸ä¸ºå›ºå®šé˜ˆå€¼             |
| **å­˜å‚¨ä¼˜åŒ–**     | å¯é€‰æ‹©æ˜¯å¦å­˜å‚¨å“ˆå¸Œå€¼ä»¥åŠ é€Ÿé‡æ–°å“ˆå¸Œ             | é€šå¸¸ä¸å­˜å‚¨å“ˆå¸Œå€¼                     |
| **æ€§èƒ½è°ƒä¼˜**     | å¯æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä¼˜ç­–ç•¥                     | é€šç”¨è®¾è®¡ï¼Œè¾ƒå°‘è°ƒä¼˜é€‰é¡¹               |
| **é¢„å®šä¹‰å“ˆå¸Œ**   | æä¾›å¤šç§æ•´æ•°ã€å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°                   | åªæä¾›åŸºæœ¬ç±»å‹çš„å“ˆå¸Œ                 |
| **å¯æ‰©å±•æ€§**     | é€šè¿‡ç­–ç•¥ç±»è½»æ¾æ‰©å±•æ–°è¡Œä¸º                       | éœ€è¦é€šè¿‡ç‰¹åŒ–æˆ–æ–°ç±»å‹æ‰©å±•             |

## äºŒã€å®šä¹‰çš„ç±»åŠå…¶ä½œç”¨

### 1. **å“ˆå¸Œå‡½æ•°ç­–ç•¥ç±»**

#### `direct_mask_range_hashing`
- **ä½œç”¨**ï¼šç›´æ¥ä½¿ç”¨é”®çš„å“ˆå¸Œå€¼é€šè¿‡æ©ç è®¡ç®—ç´¢å¼•ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼šå“ˆå¸Œè¡¨å¤§å°ä¸º 2 çš„å¹‚æ—¶çš„é«˜æ•ˆç´¢å¼•è®¡ç®—ã€‚
- **ç‰¹ç‚¹**ï¼šä½¿ç”¨ä½æ“ä½œï¼Œæ€§èƒ½é«˜ã€‚

#### `direct_mod_range_hashing`
- **ä½œç”¨**ï¼šä½¿ç”¨å–æ¨¡è¿ç®—è®¡ç®—ç´¢å¼•ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼šå“ˆå¸Œè¡¨å¤§å°ä»»æ„æ—¶ã€‚
- **ç‰¹ç‚¹**ï¼šé€šç”¨æ€§æ›´å¼ºï¼Œä½†å–æ¨¡è¿ç®—å¯èƒ½è¾ƒæ…¢ã€‚

#### `linear_probe_fn`
- **ä½œç”¨**ï¼šçº¿æ€§æ¢æµ‹å†²çªè§£å†³ç­–ç•¥ã€‚
- **å…¬å¼**ï¼š`h(k, i) = (h(k) + i) mod N`
- **ç‰¹ç‚¹**ï¼šç®€å•ï¼Œä½†å¯èƒ½äº§ç”Ÿèšé›†ï¼ˆclusteringï¼‰ã€‚

#### `quadratic_probe_fn`
- **ä½œç”¨**ï¼šäºŒæ¬¡æ¢æµ‹å†²çªè§£å†³ç­–ç•¥ã€‚
- **å…¬å¼**ï¼š`h(k, i) = (h(k) + c1*i + c2*iÂ²) mod N`
- **ç‰¹ç‚¹**ï¼šå‡å°‘èšé›†ï¼Œä½†è®¡ç®—ç¨å¤æ‚ã€‚

#### `hash_standard_resize_policy`
- **ä½œç”¨**ï¼šæ ‡å‡†è°ƒæ•´å¤§å°ç­–ç•¥ï¼ŒåŸºäºè´Ÿè½½å› å­è§¦å‘é‡æ–°å“ˆå¸Œã€‚
- **å‚æ•°**ï¼š
  - `Load_Factor`ï¼šè´Ÿè½½å› å­é˜ˆå€¼
  - `Trigger_Policy`ï¼šè§¦å‘ç­–ç•¥ï¼ˆå¦‚ `hash_exponential_size_policy`ï¼‰
  - `External_Load_Access`ï¼šæ˜¯å¦å¤–éƒ¨è®¿é—®è´Ÿè½½å› å­
- **ç‰¹ç‚¹**ï¼šå¹³è¡¡æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨ã€‚

#### `hash_exponential_size_policy`
- **ä½œç”¨**ï¼šæŒ‡æ•°å¢é•¿ç­–ç•¥ï¼Œæ¯æ¬¡æ‰©å®¹ä¸ºåŸå¤§å°çš„å€æ•°ã€‚
- **å…¬å¼**ï¼š`new_size = old_size * growth_factor`
- **ç‰¹ç‚¹**ï¼šå‡å°‘é¢‘ç¹é‡æ–°å“ˆå¸Œï¼Œé€‚åˆå¿«é€Ÿå¢é•¿åœºæ™¯ã€‚

### 2. **ç»„åˆç­–ç•¥ç±»**

#### `comb_hash_fn`
- **ä½œç”¨**ï¼šç»„åˆå“ˆå¸Œå‡½æ•°ï¼Œå°†å¤šä¸ªå“ˆå¸Œå‡½æ•°ç»„åˆä»¥æé«˜åˆ†å¸ƒæ€§ã€‚
- **ç‰¹ç‚¹**ï¼šå‡å°‘å“ˆå¸Œå†²çªï¼Œæé«˜å‡åŒ€æ€§ã€‚

#### `comb_probe_fn`
- **ä½œç”¨**ï¼šç»„åˆæ¢æµ‹å‡½æ•°ï¼Œæ”¯æŒå¤šç§æ¢æµ‹æ–¹æ³•ã€‚
- **ç‰¹ç‚¹**ï¼šæä¾›æ›´çµæ´»çš„å†²çªè§£å†³ã€‚

## ä¸‰ã€ä½¿ç”¨ç¤ºä¾‹

```cpp
#include <print>
#include <string>
#include <functional>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>

// ä½¿ç”¨ pb_ds å‘½åç©ºé—´
using namespace __gnu_pbds;

// è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°
struct custom_string_hash {
    std::size_t operator()(const std::string& s) const {
        std::size_t h = 0;
        for (char c : s) {
            h = h * 131 + c;  // ç®€å•ä¹˜åŠ å“ˆå¸Œ
        }
        return h;
    }
};

int main() {
    // ç¤ºä¾‹1ï¼šåŸºæœ¬å“ˆå¸Œè¡¨ä½¿ç”¨
    std::println("=== ç¤ºä¾‹1ï¼šåŸºæœ¬å“ˆå¸Œè¡¨ä½¿ç”¨ ===");
    
    // ä½¿ç”¨é“¾åœ°å€æ³•çš„å“ˆå¸Œè¡¨
    cc_hash_table<int, std::string> chain_table;
    chain_table[1] = "one";
    chain_table[2] = "two";
    chain_table[3] = "three";
    
    std::println("é“¾åœ°å€å“ˆå¸Œè¡¨å†…å®¹:");
    for (const auto& [key, value] : chain_table) {
        std::println("  {}: {}", key, value);
    }
    
    // ä½¿ç”¨æ¢æµ‹æ³•çš„å“ˆå¸Œè¡¨
    gp_hash_table<int, std::string> probe_table;
    probe_table[10] = "ten";
    probe_table[20] = "twenty";
    probe_table[30] = "thirty";
    
    std::println("\næ¢æµ‹æ³•å“ˆå¸Œè¡¨å†…å®¹:");
    for (const auto& [key, value] : probe_table) {
        std::println("  {}: {}", key, value);
    }
    
    // ç¤ºä¾‹2ï¼šè‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°
    std::println("\n=== ç¤ºä¾‹2ï¼šè‡ªå®šä¹‰å“ˆå¸Œå‡½æ•° ===");
    
    cc_hash_table<std::string, int, custom_string_hash> custom_chain_table;
    custom_chain_table["apple"] = 5;
    custom_chain_table["banana"] = 3;
    custom_chain_table["orange"] = 8;
    
    std::println("è‡ªå®šä¹‰å“ˆå¸Œå‡½æ•°è¡¨å†…å®¹:");
    for (const auto& [key, value] : custom_chain_table) {
        std::println("  {}: {}", key, value);
    }
    
    // ç¤ºä¾‹3ï¼šé…ç½®è°ƒæ•´ç­–ç•¥
    std::println("\n=== ç¤ºä¾‹3ï¼šé…ç½®è°ƒæ•´ç­–ç•¥ ===");
    
    // ä½¿ç”¨æ ‡å‡†è°ƒæ•´ç­–ç•¥ï¼Œè´Ÿè½½å› å­é˜ˆå€¼ 0.5
    typedef hash_standard_resize_policy<
        hash_exponential_size_policy<>,
        hash_load_check_resize_trigger<true>,
        true> resize_policy;
    
    // å®šä¹‰ä½¿ç”¨ç‰¹å®šè°ƒæ•´ç­–ç•¥çš„å“ˆå¸Œè¡¨
    typedef cc_hash_table<
        int,
        std::string,
        std::hash<int>,
        std::equal_to<int>,
        resize_policy> custom_resize_table;
    
    custom_resize_table resizable_table;
    
    // æ’å…¥å¤šä¸ªå…ƒç´ ä»¥è§¦å‘è°ƒæ•´
    for (int i = 0; i < 100; ++i) {
        resizable_table[i] = std::format("value_{}", i);
    }
    
    std::println("è°ƒæ•´åå“ˆå¸Œè¡¨å¤§å°: {}", resizable_table.size());
    std::println("æ¡¶æ•°é‡: {}", resizable_table.get_actual_size());
    
    // ç¤ºä¾‹4ï¼šæ€§èƒ½å¯¹æ¯”
    std::println("\n=== ç¤ºä¾‹4ï¼šæ€§èƒ½å¯¹æ¯” ===");
    
    // åˆ›å»ºä¸¤ä¸ªä¸åŒç­–ç•¥çš„å“ˆå¸Œè¡¨
    cc_hash_table<int, int> chain_perf_table;
    gp_hash_table<int, int> probe_perf_table;
    
    // æµ‹è¯•æ’å…¥æ€§èƒ½
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 10000; ++i) {
        chain_perf_table[i] = i * i;
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto chain_duration = std::chrono::duration<double, std::milli>(end - start);
    
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 10000; ++i) {
        probe_perf_table[i] = i * i;
    }
    end = std::chrono::high_resolution_clock::now();
    auto probe_duration = std::chrono::duration<double, std::milli>(end - start);
    
    std::println("é“¾åœ°å€æ³•æ’å…¥ 10000 ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", chain_duration.count());
    std::println("æ¢æµ‹æ³•æ’å…¥ 10000 ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", probe_duration.count());
    
    // æµ‹è¯•æŸ¥æ‰¾æ€§èƒ½
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 10000; ++i) {
        [[maybe_unused]] auto val = chain_perf_table.find(i);
    }
    end = std::chrono::high_resolution_clock::now();
    chain_duration = std::chrono::duration<double, std::milli>(end - start);
    
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 10000; ++i) {
        [[maybe_unused]] auto val = probe_perf_table.find(i);
    }
    end = std::chrono::high_resolution_clock::now();
    probe_duration = std::chrono::duration<double, std::milli>(end - start);
    
    std::println("é“¾åœ°å€æ³•æŸ¥æ‰¾ 10000 ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", chain_duration.count());
    std::println("æ¢æµ‹æ³•æŸ¥æ‰¾ 10000 ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", probe_duration.count());
    
    // ç¤ºä¾‹5ï¼šé«˜çº§ç­–ç•¥ç»„åˆ
    std::println("\n=== ç¤ºä¾‹5ï¼šé«˜çº§ç­–ç•¥ç»„åˆ ===");
    
    // ä½¿ç”¨äºŒæ¬¡æ¢æµ‹å’Œè‡ªå®šä¹‰è°ƒæ•´ç­–ç•¥
    typedef gp_hash_table<
        int,
        std::string,
        std::hash<int>,
        std::equal_to<int>,
        direct_mod_range_hashing<>,
        quadratic_probe_fn<>,
        hash_standard_resize_policy<
            hash_exponential_size_policy<>,
            hash_load_check_resize_trigger<true>,
            true>> advanced_table_type;
    
    advanced_table_type advanced_table;
    
    // æ’å…¥å¹¶å±•ç¤º
    for (int i = 0; i < 20; ++i) {
        advanced_table[i * i] = std::format("square_{}", i);
    }
    
    std::println("é«˜çº§ç­–ç•¥å“ˆå¸Œè¡¨å†…å®¹ï¼ˆå‰10é¡¹ï¼‰:");
    int count = 0;
    for (const auto& [key, value] : advanced_table) {
        if (count++ >= 10) break;
        std::println("  {}: {}", key, value);
    }
    
    // ç¤ºä¾‹6ï¼šä¸æ ‡å‡†åº“å“ˆå¸Œè¡¨å¯¹æ¯”
    std::println("\n=== ç¤ºä¾‹6ï¼šä¸æ ‡å‡†åº“å¯¹æ¯” ===");
    
    #include <unordered_map>
    
    std::unordered_map<int, std::string> std_map;
    gp_hash_table<int, std::string> pbds_map;
    
    // æ’å…¥å¯¹æ¯”
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 50000; ++i) {
        std_map[i] = std::format("std_{}", i);
    }
    end = std::chrono::high_resolution_clock::now();
    auto std_insert_duration = std::chrono::duration<double, std::milli>(end - start);
    
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < 50000; ++i) {
        pbds_map[i] = std::format("pbds_{}", i);
    }
    end = std::chrono::high_resolution_clock::now();
    auto pbds_insert_duration = std::chrono::duration<double, std::milli>(end - start);
    
    std::println("æ ‡å‡†åº“æ’å…¥ 50000 ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", std_insert_duration.count());
    std::println("PBDS æ’å…¥ 50000 ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", pbds_insert_duration.count());
    std::println("PBDS ç›¸å¯¹äºæ ‡å‡†åº“çš„åŠ é€Ÿæ¯”: {:.2f}%", 
                 (std_insert_duration.count() - pbds_insert_duration.count()) / 
                 std_insert_duration.count() * 100);
    
    return 0;
}
```

## å››ã€é«˜çº§é…ç½®ç¤ºä¾‹

```cpp
#include <print>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>

using namespace __gnu_pbds;

// è‡ªå®šä¹‰è°ƒæ•´ç­–ç•¥ï¼šå½“è´Ÿè½½å› å­è¶…è¿‡0.75æ—¶è§¦å‘é‡æ–°å“ˆå¸Œ
struct custom_resize_trigger {
    // è¿”å›æ˜¯å¦åº”è¯¥è°ƒæ•´å¤§å°
    inline bool operator()(std::size_t n, std::size_t m) const {
        // n: å…ƒç´ æ•°é‡ï¼Œm: æ¡¶æ•°é‡
        return static_cast<double>(n) / m > 0.75;
    }
};

int main() {
    std::println("=== é«˜çº§é…ç½®ï¼šè‡ªå®šä¹‰è°ƒæ•´ç­–ç•¥ ===");
    
    // å®šä¹‰ä½¿ç”¨è‡ªå®šä¹‰è°ƒæ•´ç­–ç•¥çš„å“ˆå¸Œè¡¨ç±»å‹
    typedef hash_standard_resize_policy<
        hash_exponential_size_policy<>,
        custom_resize_trigger,
        true> custom_resize_policy;
    
    typedef cc_hash_table<
        int,
        std::string,
        std::hash<int>,
        std::equal_to<int>,
        custom_resize_policy> custom_table_type;
    
    custom_table_type custom_table;
    
    // ç›‘æ§è°ƒæ•´è¿‡ç¨‹
    std::println("åˆå§‹æ¡¶æ•°é‡: {}", custom_table.get_actual_size());
    
    // æ’å…¥å…ƒç´ ç›´åˆ°è§¦å‘è°ƒæ•´
    for (int i = 0; i < 1000; ++i) {
        custom_table[i] = std::format("val_{}", i);
        
        // æ¯100ä¸ªå…ƒç´ æ‰“å°ä¸€æ¬¡çŠ¶æ€
        if (i % 100 == 0) {
            std::println("æ’å…¥ {} ä¸ªå…ƒç´ å - æ¡¶æ•°é‡: {}, è´Ÿè½½å› å­: {:.2f}", 
                        i + 1, 
                        custom_table.get_actual_size(),
                        static_cast<double>(custom_table.size()) / 
                        custom_table.get_actual_size());
        }
    }
    
    // ç¤ºä¾‹ï¼šä½¿ç”¨ä¸åŒçš„æ¢æµ‹æ–¹æ³•
    std::println("\n=== ä¸åŒæ¢æµ‹æ–¹æ³•å¯¹æ¯” ===");
    
    // çº¿æ€§æ¢æµ‹
    typedef gp_hash_table<
        int,
        int,
        std::hash<int>,
        std::equal_to<int>,
        direct_mod_range_hashing<>,
        linear_probe_fn<>,
        hash_standard_resize_policy<>,
        false> linear_probe_table;
    
    // äºŒæ¬¡æ¢æµ‹
    typedef gp_hash_table<
        int,
        int,
        std::hash<int>,
        std::equal_to<int>,
        direct_mod_range_hashing<>,
        quadratic_probe_fn<>,
        hash_standard_resize_policy<>,
        false> quadratic_probe_table;
    
    linear_probe_table linear_table;
    quadratic_probe_table quadratic_table;
    
    // æµ‹è¯•å†²çªæƒ…å†µ
    std::println("æ’å…¥æ•…æ„å†²çªçš„é”®å€¼å¯¹...");
    
    // ä½¿ç”¨ç®€å•çš„å“ˆå¸Œå‡½æ•°åˆ¶é€ å†²çª
    struct bad_hash {
        std::size_t operator()(int x) const {
            return x % 10;  // åªæœ‰10ä¸ªä¸åŒçš„å“ˆå¸Œå€¼
        }
    };
    
    typedef gp_hash_table<
        int,
        int,
        bad_hash,
        std::equal_to<int>,
        direct_mod_range_hashing<>,
        linear_probe_fn<>,
        hash_standard_resize_policy<>,
        false> bad_hash_linear_table;
    
    bad_hash_linear_table conflict_table;
    
    for (int i = 0; i < 100; ++i) {
        conflict_table[i] = i;
    }
    
    std::println("é«˜å†²çªåœºæ™¯ä¸‹å“ˆå¸Œè¡¨å¤§å°: {}", conflict_table.size());
    std::println("æ¡¶æ•°é‡: {}", conflict_table.get_actual_size());
    
    // ç»Ÿè®¡æ¢æµ‹é•¿åº¦
    int total_probes = 0;
    for (int i = 0; i < 100; ++i) {
        auto it = conflict_table.find(i);
        if (it != conflict_table.end()) {
            // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–äº†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æ–¹æ³•æ¥è·å–æ¢æµ‹é•¿åº¦
            total_probes++;
        }
    }
    
    std::println("å¹³å‡æ¯æ¬¡æŸ¥æ‰¾çš„è¿‘ä¼¼æ¢æµ‹æ¬¡æ•°: {:.2f}", 
                 static_cast<double>(total_probes) / 100);
    
    return 0;
}
```

## äº”ã€æ€»ç»“

`hash_policy.hpp` æ˜¯ PBDS åº“ä¸­å“ˆå¸Œè¡¨åŠŸèƒ½çš„æ ¸å¿ƒç­–ç•¥å¤´æ–‡ä»¶ï¼Œæä¾›äº†ï¼š

### ä¸»è¦ä¼˜åŠ¿ï¼š
1. **é«˜åº¦å¯é…ç½®æ€§**ï¼šæ”¯æŒå¤šç§å“ˆå¸Œå‡½æ•°ã€å†²çªè§£å†³æ–¹æ³•å’Œè°ƒæ•´ç­–ç•¥
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¯æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä¼˜ç­–ç•¥ï¼Œé€šå¸¸æ¯”æ ‡å‡†åº“å“ˆå¸Œè¡¨æ›´å¿«
3. **å†…å­˜æ§åˆ¶**ï¼šå¯ç²¾ç»†æ§åˆ¶è´Ÿè½½å› å­å’Œæ‰©å®¹è¡Œä¸º
4. **ç­–ç•¥ç»„åˆ**ï¼šæ”¯æŒä¸åŒç­–ç•¥çš„è‡ªç”±ç»„åˆï¼Œé€‚åº”å„ç§åœºæ™¯

### é€‚ç”¨åœºæ™¯ï¼š
1. **é«˜æ€§èƒ½éœ€æ±‚**ï¼šéœ€è¦æè‡´æŸ¥æ‰¾ã€æ’å…¥æ€§èƒ½çš„åœºæ™¯
2. **ç‰¹æ®Šæ•°æ®åˆ†å¸ƒ**ï¼šæ•°æ®æœ‰ç‰¹å®šåˆ†å¸ƒæ¨¡å¼ï¼Œéœ€è¦å®šåˆ¶å“ˆå¸Œç­–ç•¥
3. **å†…å­˜æ•æ„Ÿ**ï¼šéœ€è¦ç²¾ç¡®æ§åˆ¶å†…å­˜ä½¿ç”¨çš„åœºæ™¯
4. **å†²çªæ•æ„Ÿ**ï¼šé«˜å†²çªç¯å¢ƒä¸‹éœ€è¦ç‰¹æ®Šå¤„ç†

### æ³¨æ„äº‹é¡¹ï¼š
1. **ç¼–è¯‘å™¨ä¾èµ–**ï¼šä»…é™ GCC ç¼–è¯‘å™¨ä½¿ç”¨
2. **å­¦ä¹ æˆæœ¬**ï¼šé…ç½®é€‰é¡¹è¾ƒå¤šï¼Œéœ€è¦ç†è§£å„ç­–ç•¥çš„å½±å“
3. **è°ƒè¯•å¤æ‚æ€§**ï¼šå¤æ‚ç­–ç•¥ç»„åˆå¯èƒ½å¢åŠ è°ƒè¯•éš¾åº¦

ä¸ C++ æ ‡å‡†åº“çš„ `std::unordered_map` ç›¸æ¯”ï¼ŒPBDS å“ˆå¸Œè¡¨åœ¨å¯é…ç½®æ€§å’Œæ€§èƒ½æ–¹é¢å…·æœ‰æ˜æ˜¾ä¼˜åŠ¿ï¼Œä½†ç‰ºç‰²äº†æ ‡å‡†å…¼å®¹æ€§å’Œç®€æ˜“æ€§ã€‚åœ¨é€‰æ‹©æ—¶åº”æ ¹æ®å…·ä½“éœ€æ±‚æƒè¡¡åˆ©å¼Šã€‚

# <priority_queue.hpp>

## ä¸€ã€æ¦‚è¿°

`priority_queue.hpp` æ˜¯ GCC çš„ PBDSï¼ˆPolicy-Based Data Structuresï¼‰åº“ä¸­æä¾›å¤šç§å †ï¼ˆHeapï¼‰å®ç°çš„æ ¸å¿ƒå¤´æ–‡ä»¶ã€‚è¯¥æ–‡ä»¶å®šä¹‰äº†ä¸€ä¸ªé«˜åº¦å¯é…ç½®çš„ä¼˜å…ˆé˜Ÿåˆ—æ¨¡æ¿ç±»ï¼Œæ”¯æŒäº”ç§ä¸åŒçš„åº•å±‚å †æ•°æ®ç»“æ„ï¼Œæ¯ç§éƒ½æœ‰å…¶ç‰¹å®šçš„æ€§èƒ½ç‰¹å¾å’Œé€‚ç”¨åœºæ™¯ã€‚

### ä¸»è¦åŠŸèƒ½å’Œä½œç”¨

1. **å¤šç§å †å®ç°**ï¼šæä¾›äº”ç§ä¸åŒçš„å †æ•°æ®ç»“æ„ï¼Œæ¯ç§é’ˆå¯¹ç‰¹å®šæ“ä½œè¿›è¡Œäº†ä¼˜åŒ–ã€‚
2. **ç­–ç•¥å®šåˆ¶**ï¼šé€šè¿‡æ¨¡æ¿å‚æ•°é€‰æ‹©åº•å±‚å †ç±»å‹ã€æ¯”è¾ƒå‡½æ•°å’Œåˆ†é…å™¨ã€‚
3. **é«˜çº§æ“ä½œ**ï¼šæ”¯æŒåˆå¹¶ï¼ˆjoinï¼‰ã€ä¿®æ”¹ï¼ˆmodifyï¼‰ç­‰æ ‡å‡†åº“ä¼˜å…ˆé˜Ÿåˆ—ä¸å…·å¤‡çš„æ“ä½œã€‚
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šé’ˆå¯¹ä¸åŒä½¿ç”¨åœºæ™¯ï¼ˆæ’å…¥å¯†é›†ã€åˆ é™¤å¯†é›†ã€åˆå¹¶é¢‘ç¹ç­‰ï¼‰æä¾›ä¸“é—¨çš„å †å®ç°ã€‚

### æ”¯æŒçš„å †ç±»å‹ï¼ˆTag å‚æ•°ï¼‰

1. **`pairing_heap_tag`**ï¼ˆé»˜è®¤ï¼‰ï¼šé…å¯¹å †ï¼Œå¤§å¤šæ•°æ“ä½œå…·æœ‰ä¼˜ç§€çš„å¹³æ‘Šæ—¶é—´å¤æ‚åº¦ã€‚
2. **`binary_heap_tag`**ï¼šäºŒå‰å †ï¼Œå†…å­˜ç´§å‡‘ï¼Œé€‚åˆå°æ•°æ®é‡æˆ–å¯¹ç¼“å­˜å‹å¥½çš„åœºæ™¯ã€‚
3. **`binomial_heap_tag`**ï¼šäºŒé¡¹å †ï¼Œæ”¯æŒé«˜æ•ˆçš„åˆå¹¶æ“ä½œã€‚
4. **`rc_binomial_heap_tag`**ï¼šç¼“å¼äºŒé¡¹å †ï¼ŒäºŒé¡¹å †çš„å˜ç§ï¼ŒæŸäº›æ“ä½œæ›´é«˜æ•ˆã€‚
5. **`thin_heap_tag`**ï¼šç˜¦å †ï¼ŒDijkstraç®—æ³•ç­‰å›¾ç®—æ³•çš„ä¼˜åŒ–é€‰æ‹©ã€‚

## äºŒã€ä¸æ ‡å‡†åº“ `std::priority_queue` çš„åŒºåˆ«

| ç‰¹æ€§               | PBDS `priority_queue`              | C++ æ ‡å‡†åº“ `std::priority_queue` |
| ------------------ | ---------------------------------- | -------------------------------- |
| **åº•å±‚å®ç°å¤šæ ·æ€§** | 5ç§ä¸åŒå †å®ç°å¯é€‰                  | é€šå¸¸åªæœ‰ä¸€ç§å®ç°ï¼ˆé€šå¸¸æ˜¯äºŒå‰å †ï¼‰ |
| **åˆå¹¶æ“ä½œ**       | æ”¯æŒ `join()` æ“ä½œï¼ŒæŸäº›å †ä¸º O(1)  | ä¸æ”¯æŒåˆå¹¶                       |
| **ä¿®æ”¹æ“ä½œ**       | æ”¯æŒ `modify()` ä¿®æ”¹å †ä¸­å…ƒç´        | ä¸æ”¯æŒï¼Œéœ€è¦å…ˆåˆ é™¤å†æ’å…¥         |
| **è¿­ä»£å™¨æ”¯æŒ**     | æä¾›è¿­ä»£å™¨ï¼Œå¯éå†å †å…ƒç´            | ä¸æä¾›è¿­ä»£å™¨ï¼Œåªèƒ½è®¿é—®é¡¶éƒ¨å…ƒç´    |
| **æ€§èƒ½è°ƒä¼˜**       | å¯æ ¹æ®æ“ä½œç‰¹å¾é€‰æ‹©æœ€ä¼˜å †ç±»å‹       | å›ºå®šå®ç°ï¼Œæ— æ³•è°ƒä¼˜               |
| **å†…å­˜å¸ƒå±€**       | æŸäº›å®ç°ï¼ˆå¦‚é…å¯¹å †ï¼‰ä½¿ç”¨æŒ‡é’ˆç»“æ„   | é€šå¸¸ä½¿ç”¨æ•°ç»„å­˜å‚¨ï¼Œç¼“å­˜å‹å¥½       |
| **æ¥å£ä¸€è‡´æ€§**     | æ¥å£æ›´ä¸°å¯Œï¼Œæ”¯æŒå¤šç§é«˜çº§æ“ä½œ       | æ¥å£ç®€å•ï¼Œç¬¦åˆSTLå®¹å™¨é€‚é…å™¨æ¨¡å¼  |
| **è‡ªå®šä¹‰èŠ‚ç‚¹**     | å¯å®šåˆ¶èŠ‚ç‚¹æ›´æ–°ç­–ç•¥                 | ä¸æ”¯æŒè‡ªå®šä¹‰èŠ‚ç‚¹                 |
| **ç¨³å®šæ€§**         | æŸäº›æ“ä½œï¼ˆå¦‚ä¿®æ”¹ï¼‰å¯èƒ½ä½¿è¿­ä»£å™¨å¤±æ•ˆ | æ“ä½œç›¸å¯¹ç¨³å®š                     |

### æ—¶é—´å¤æ‚åº¦å¯¹æ¯”

| æ“ä½œ                  | PBDSï¼ˆé…å¯¹å †ï¼‰ | `std::priority_queue`ï¼ˆäºŒå‰å †ï¼‰ |
| --------------------- | -------------- | ------------------------------- |
| æ’å…¥ï¼ˆpushï¼‰          | O(1) å¹³æ‘Š      | O(log n)                        |
| æŸ¥çœ‹é¡¶éƒ¨ï¼ˆtopï¼‰       | O(1)           | O(1)                            |
| åˆ é™¤é¡¶éƒ¨ï¼ˆpopï¼‰       | O(log n) å¹³æ‘Š  | O(log n)                        |
| åˆå¹¶ï¼ˆjoinï¼‰          | O(1)           | ä¸æ”¯æŒ                          |
| ä¿®æ”¹å…ƒç´ ï¼ˆmodifyï¼‰    | O(log n) å¹³æ‘Š  | ä¸æ”¯æŒ                          |
| åˆ é™¤ä»»æ„å…ƒç´ ï¼ˆeraseï¼‰ | O(log n) å¹³æ‘Š  | ä¸æ”¯æŒ                          |

## ä¸‰ã€å®šä¹‰çš„ç±»åŠå…¶ä½œç”¨

### `priority_queue` æ¨¡æ¿ç±»

```cpp
template<typename _Tv,
         typename Cmp_Fn = std::less<_Tv>,
         typename Tag = pairing_heap_tag,
         typename _Alloc = std::allocator<char> >
class priority_queue;
```

#### æ¨¡æ¿å‚æ•°ï¼š
- **_Tv**ï¼šå­˜å‚¨åœ¨ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å…ƒç´ ç±»å‹ã€‚
- **Cmp_Fn**ï¼šæ¯”è¾ƒå‡½æ•°å¯¹è±¡ç±»å‹ï¼Œé»˜è®¤ä¸º `std::less<_Tv>`ã€‚
- **Tag**ï¼šå †ç±»å‹æ ‡ç­¾ï¼Œå†³å®šåº•å±‚æ•°æ®ç»“æ„ã€‚
- **_Alloc**ï¼šåˆ†é…å™¨ç±»å‹ï¼Œé»˜è®¤ä¸º `std::allocator<char>`ã€‚

#### æ”¯æŒçš„ Tag ç±»å‹ï¼š

1. **`pairing_heap_tag`**ï¼ˆé»˜è®¤ï¼‰
   - **ç‰¹ç‚¹**ï¼šå¤§å¤šæ•°æ“ä½œå…·æœ‰ä¼˜ç§€çš„å¹³æ‘Šæ—¶é—´å¤æ‚åº¦ï¼Œç‰¹åˆ«é€‚åˆé¢‘ç¹æ’å…¥å’Œåˆå¹¶çš„åœºæ™¯ã€‚
   - **é€‚ç”¨åœºæ™¯**ï¼šé€šç”¨ä¼˜å…ˆé˜Ÿåˆ—éœ€æ±‚ï¼Œç‰¹åˆ«æ˜¯éœ€è¦åˆå¹¶æ“ä½œæ—¶ã€‚

2. **`binary_heap_tag`**
   - **ç‰¹ç‚¹**ï¼šä½¿ç”¨æ•°ç»„å­˜å‚¨ï¼Œå†…å­˜ç´§å‡‘ï¼Œç¼“å­˜å‹å¥½ã€‚
   - **é€‚ç”¨åœºæ™¯**ï¼šå°æ•°æ®é‡æˆ–å¯¹æ€§èƒ½æœ‰ä¸¥æ ¼è¦æ±‚ï¼Œä¸éœ€è¦åˆå¹¶æ“ä½œã€‚

3. **`binomial_heap_tag`**
   - **ç‰¹ç‚¹**ï¼šæ”¯æŒé«˜æ•ˆçš„åˆå¹¶æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(log n)ã€‚
   - **é€‚ç”¨åœºæ™¯**ï¼šéœ€è¦é¢‘ç¹åˆå¹¶å¤šä¸ªä¼˜å…ˆé˜Ÿåˆ—ã€‚

4. **`rc_binomial_heap_tag`**
   - **ç‰¹ç‚¹**ï¼šäºŒé¡¹å †çš„å˜ç§ï¼ŒæŸäº›æ“ä½œï¼ˆå¦‚æ’å…¥ï¼‰å…·æœ‰æ›´å¥½çš„å¹³æ‘Šæ—¶é—´å¤æ‚åº¦ã€‚
   - **é€‚ç”¨åœºæ™¯**ï¼šéœ€è¦åˆå¹¶æ“ä½œä¸”æ’å…¥æ“ä½œé¢‘ç¹ã€‚

5. **`thin_heap_tag`**
   - **ç‰¹ç‚¹**ï¼šé’ˆå¯¹Dijkstraç­‰å›¾ç®—æ³•ä¼˜åŒ–ï¼Œå‡å°‘ä¸å¿…è¦çš„æŒ‡é’ˆæ“ä½œã€‚
   - **é€‚ç”¨åœºæ™¯**ï¼šå›¾ç®—æ³•ä¸­çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼Œç‰¹åˆ«æ˜¯å•æºæœ€çŸ­è·¯å¾„ç®—æ³•ã€‚

## å››ã€ä½¿ç”¨ç¤ºä¾‹

```cpp
#include <print>
#include <vector>
#include <functional>
#include <ext/pb_ds/priority_queue.hpp>

// ä½¿ç”¨ pb_ds å‘½åç©ºé—´
using namespace __gnu_pbds;

// è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼šæœ€å°å †
struct min_heap_comparator {
    template<typename T>
    bool operator()(const T& a, const T& b) const {
        return a > b;  // å¯¹äºæœ€å°å †ï¼Œa > b æ—¶è¿”å› true
    }
};

int main() {
    // ç¤ºä¾‹1ï¼šåŸºæœ¬ä½¿ç”¨ - é»˜è®¤é…å¯¹å †
    std::println("=== ç¤ºä¾‹1ï¼šåŸºæœ¬ä½¿ç”¨ï¼ˆé»˜è®¤é…å¯¹å †ï¼‰===");
    
    priority_queue<int> pq1;
    
    // æ’å…¥å…ƒç´ 
    pq1.push(10);
    pq1.push(30);
    pq1.push(20);
    pq1.push(50);
    pq1.push(40);
    
    std::println("å †å¤§å°: {}", pq1.size());
    std::println("å †é¡¶å…ƒç´ : {}", pq1.top());
    
    // éå†å †ï¼ˆæ³¨æ„ï¼šå †éå†ä¸ä¿è¯é¡ºåºï¼‰
    std::println("å †å†…å®¹ï¼ˆéå†é¡ºåºä¸ç¡®å®šï¼‰:");
    for (const auto& val : pq1) {
        std::print("{} ", val);
    }
    std::println();
    
    // å¼¹å‡ºå…ƒç´ 
    pq1.pop();
    std::println("å¼¹å‡ºåå †é¡¶: {}", pq1.top());
    
    // ç¤ºä¾‹2ï¼šæœ€å°å †
    std::println("\n=== ç¤ºä¾‹2ï¼šæœ€å°å † ===");
    
    priority_queue<int, min_heap_comparator> min_pq;
    min_pq.push(10);
    min_pq.push(30);
    min_pq.push(20);
    min_pq.push(5);
    min_pq.push(40);
    
    std::println("æœ€å°å †é¡¶éƒ¨: {}", min_pq.top());
    
    // å¼¹å‡ºæ‰€æœ‰å…ƒç´ ï¼ˆæŒ‰å‡åºï¼‰
    std::println("æŒ‰å‡åºå¼¹å‡º:");
    while (!min_pq.empty()) {
        std::print("{} ", min_pq.top());
        min_pq.pop();
    }
    std::println();
    
    // ç¤ºä¾‹3ï¼šä¸åŒå †ç±»å‹çš„æ€§èƒ½å¯¹æ¯”
    std::println("\n=== ç¤ºä¾‹3ï¼šä¸åŒå †ç±»å‹å¯¹æ¯” ===");
    
    // ä½¿ç”¨äºŒå‰å †
    priority_queue<int, std::less<int>, binary_heap_tag> binary_heap;
    // ä½¿ç”¨äºŒé¡¹å †
    priority_queue<int, std::less<int>, binomial_heap_tag> binomial_heap;
    // ä½¿ç”¨ç¼“å¼äºŒé¡¹å †
    priority_queue<int, std::less<int>, rc_binomial_heap_tag> rc_binomial_heap;
    // ä½¿ç”¨ç˜¦å †
    priority_queue<int, std::less<int>, thin_heap_tag> thin_heap;
    
    // æµ‹è¯•æ’å…¥æ€§èƒ½
    constexpr int NUM_ELEMENTS = 10000;
    
    auto test_insert = [](auto& heap, std::string_view name) {
        auto start = std::chrono::high_resolution_clock::now();
        for (int i = 0; i < NUM_ELEMENTS; ++i) {
            heap.push(std::rand() % 10000);
        }
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration<double, std::milli>(end - start);
        std::println("{} æ’å…¥ {} ä¸ªå…ƒç´ è€—æ—¶: {:.2f} ms", name, NUM_ELEMENTS, duration.count());
        return duration;
    };
    
    auto d1 = test_insert(binary_heap, "äºŒå‰å †");
    auto d2 = test_insert(binomial_heap, "äºŒé¡¹å †");
    auto d3 = test_insert(rc_binomial_heap, "ç¼“å¼äºŒé¡¹å †");
    auto d4 = test_insert(thin_heap, "ç˜¦å †");
    
    // ç¤ºä¾‹4ï¼šåˆå¹¶æ“ä½œï¼ˆåªæœ‰æŸäº›å †æ”¯æŒé«˜æ•ˆåˆå¹¶ï¼‰
    std::println("\n=== ç¤ºä¾‹4ï¼šåˆå¹¶æ“ä½œ ===");
    
    priority_queue<int, std::less<int>, pairing_heap_tag> heap_a;
    priority_queue<int, std::less<int>, pairing_heap_tag> heap_b;
    
    for (int i = 0; i < 5; ++i) {
        heap_a.push(i * 10);
        heap_b.push(i * 10 + 5);
    }
    
    std::println("åˆå¹¶å‰ - å †Aå¤§å°: {}, å †Bå¤§å°: {}", heap_a.size(), heap_b.size());
    std::println("å †Aé¡¶éƒ¨: {}, å †Bé¡¶éƒ¨: {}", heap_a.top(), heap_b.top());
    
    // åˆå¹¶å †Båˆ°å †A
    heap_a.join(heap_b);
    
    std::println("åˆå¹¶å - å †Aå¤§å°: {}, å †Bå¤§å°: {}", heap_a.size(), heap_b.size());
    std::println("åˆå¹¶åå †Aé¡¶éƒ¨: {}", heap_a.top());
    
    // ç¤ºä¾‹5ï¼šä¿®æ”¹æ“ä½œï¼ˆéœ€è¦point_iteratorï¼‰
    std::println("\n=== ç¤ºä¾‹5ï¼šä¿®æ”¹æ“ä½œ ===");
    
    priority_queue<int, std::less<int>, pairing_heap_tag> modifiable_heap;
    
    // æ’å…¥å…ƒç´ å¹¶è·å–è¿­ä»£å™¨
    modifiable_heap.push(10);
    modifiable_heap.push(20);
    modifiable_heap.push(30);
    
    // è·å–é¡¶éƒ¨å…ƒç´ çš„è¿­ä»£å™¨
    auto top_it = modifiable_heap.top();
    std::println("ä¿®æ”¹å‰é¡¶éƒ¨: {}", *top_it);
    
    // ä¿®æ”¹é¡¶éƒ¨å…ƒç´ çš„å€¼ï¼ˆæ³¨æ„ï¼šè¿™ä¼šä½¿å †é‡æ–°è°ƒæ•´ï¼‰
    modifiable_heap.modify(top_it, 5);
    std::println("ä¿®æ”¹åé¡¶éƒ¨: {}", modifiable_heap.top());
    
    // ç¤ºä¾‹6ï¼šè‡ªå®šä¹‰æ•°æ®ç»“æ„
    std::println("\n=== ç¤ºä¾‹6ï¼šè‡ªå®šä¹‰æ•°æ®ç»“æ„ ===");
    
    struct Task {
        int priority;
        std::string name;
        
        bool operator<(const Task& other) const {
            return priority < other.priority;  // ä¼˜å…ˆçº§æ•°å€¼è¶Šå¤§è¶Šä¼˜å…ˆ
        }
        
        friend std::ostream& operator<<(std::ostream& os, const Task& task) {
            return os << "Task{" << task.name << ", prio=" << task.priority << "}";
        }
    };
    
    priority_queue<Task> task_queue;
    task_queue.push({1, "ä½ä¼˜å…ˆçº§ä»»åŠ¡"});
    task_queue.push({3, "é«˜ä¼˜å…ˆçº§ä»»åŠ¡"});
    task_queue.push({2, "ä¸­ä¼˜å…ˆçº§ä»»åŠ¡"});
    
    std::println("ä»»åŠ¡é˜Ÿåˆ—:");
    while (!task_queue.empty()) {
        std::println("  {}", task_queue.top());
        task_queue.pop();
    }
    
    return 0;
}
```

## äº”ã€é«˜çº§åŠŸèƒ½ç¤ºä¾‹

```cpp
#include <print>
#include <vector>
#include <ext/pb_ds/priority_queue.hpp>
#include <ext/pb_ds/assoc_container.hpp>  // ç”¨äºDijkstraç®—æ³•ä¸­çš„è·ç¦»ç®¡ç†

using namespace __gnu_pbds;

// Dijkstraç®—æ³•ç¤ºä¾‹
void dijkstra_algorithm_demo() {
    std::println("=== Dijkstraç®—æ³•ç¤ºä¾‹ï¼ˆä½¿ç”¨ç˜¦å †ä¼˜åŒ–ï¼‰===");
    
    // å›¾ç»“æ„ï¼šé‚»æ¥è¡¨è¡¨ç¤º
    struct Edge {
        int to;
        int weight;
    };
    
    constexpr int N = 6;  // é¡¶ç‚¹æ•°é‡
    std::vector<std::vector<Edge>> graph(N);
    
    // æ„å»ºå›¾
    graph[0].push_back({1, 7});
    graph[0].push_back({2, 9});
    graph[0].push_back({5, 14});
    graph[1].push_back({2, 10});
    graph[1].push_back({3, 15});
    graph[2].push_back({3, 11});
    graph[2].push_back({5, 2});
    graph[3].push_back({4, 6});
    graph[5].push_back({4, 9});
    
    // è·ç¦»æ•°ç»„
    std::vector<int> dist(N, INT_MAX);
    dist[0] = 0;  // èµ·ç‚¹
    
    // ä½¿ç”¨ç˜¦å †ä½œä¸ºä¼˜å…ˆé˜Ÿåˆ—ï¼ˆé’ˆå¯¹å›¾ç®—æ³•ä¼˜åŒ–ï¼‰
    // å­˜å‚¨ (è·ç¦», é¡¶ç‚¹) å¯¹ï¼ŒæŒ‰è·ç¦»æœ€å°ä¼˜å…ˆ
    struct DijkstraNode {
        int distance;
        int vertex;
        
        bool operator<(const DijkstraNode& other) const {
            return distance > other.distance;  // æœ€å°å †
        }
    };
    
    priority_queue<DijkstraNode, std::less<DijkstraNode>, thin_heap_tag> pq;
    
    // èµ·ç‚¹å…¥é˜Ÿ
    pq.push({0, 0});
    
    // å­˜å‚¨æ¯ä¸ªé¡¶ç‚¹åœ¨å †ä¸­çš„è¿­ä»£å™¨ï¼Œç”¨äºåç»­ä¿®æ”¹
    std::vector<decltype(pq)::point_iterator> node_iters(N, nullptr);
    
    while (!pq.empty()) {
        auto current = pq.top();
        pq.pop();
        
        int u = current.vertex;
        int d = current.distance;
        
        // å¦‚æœå½“å‰è·ç¦»ä¸æ˜¯æœ€çŸ­è·ç¦»ï¼Œè·³è¿‡
        if (d > dist[u]) continue;
        
        // éå†é‚»æ¥è¾¹
        for (const auto& edge : graph[u]) {
            int v = edge.to;
            int new_dist = dist[u] + edge.weight;
            
            if (new_dist < dist[v]) {
                dist[v] = new_dist;
                
                // å¦‚æœé¡¶ç‚¹å·²ç»åœ¨å †ä¸­ï¼Œä¿®æ”¹å…¶è·ç¦»
                if (node_iters[v] != nullptr) {
                    pq.modify(node_iters[v], {new_dist, v});
                } else {
                    // å¦åˆ™æ’å…¥æ–°èŠ‚ç‚¹
                    node_iters[v] = pq.push({new_dist, v});
                }
            }
        }
    }
    
    // è¾“å‡ºç»“æœ
    std::println("ä»é¡¶ç‚¹0åˆ°å„é¡¶ç‚¹çš„æœ€çŸ­è·ç¦»:");
    for (int i = 0; i < N; ++i) {
        std::println("  åˆ°é¡¶ç‚¹{}: {}", i, dist[i] == INT_MAX ? "ä¸å¯è¾¾" : std::to_string(dist[i]));
    }
}

// å †åˆå¹¶çš„é«˜çº§ç¤ºä¾‹
void heap_merging_demo() {
    std::println("\n=== å †åˆå¹¶é«˜çº§ç¤ºä¾‹ ===");
    
    // ä½¿ç”¨äºŒé¡¹å †ï¼Œæ”¯æŒé«˜æ•ˆçš„åˆå¹¶æ“ä½œ
    priority_queue<int, std::less<int>, binomial_heap_tag> heap1, heap2, heap3;
    
    // å¡«å……å †
    for (int i = 0; i < 10; i += 2) {
        heap1.push(i);
        heap2.push(i + 1);
        heap3.push(i * 10);
    }
    
    std::println("åˆå¹¶å‰:");
    std::println("  å †1å¤§å°: {}, é¡¶éƒ¨: {}", heap1.size(), heap1.top());
    std::println("  å †2å¤§å°: {}, é¡¶éƒ¨: {}", heap2.size(), heap2.top());
    std::println("  å †3å¤§å°: {}, é¡¶éƒ¨: {}", heap3.size(), heap3.top());
    
    // åˆå¹¶å †2åˆ°å †1
    heap1.join(heap2);
    std::println("\nåˆå¹¶å †2åˆ°å †1å:");
    std::println("  å †1å¤§å°: {}, é¡¶éƒ¨: {}", heap1.size(), heap1.top());
    std::println("  å †2å¤§å°: {}", heap2.size());
    
    // æ‰¹é‡åˆå¹¶å¤šä¸ªå †
    std::vector<decltype(heap1)> heaps;
    for (int i = 0; i < 5; ++i) {
        decltype(heap1) h;
        for (int j = 0; j < 3; ++j) {
            h.push(i * 10 + j);
        }
        heaps.push_back(h);
    }
    
    // é€æ­¥åˆå¹¶æ‰€æœ‰å †
    auto merged = heaps[0];
    for (size_t i = 1; i < heaps.size(); ++i) {
        merged.join(heaps[i]);
    }
    
    std::println("\næ‰¹é‡åˆå¹¶åå †å¤§å°: {}, é¡¶éƒ¨: {}", merged.size(), merged.top());
}

// æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜ç¤ºä¾‹
void performance_tuning_demo() {
    std::println("\n=== æ€§èƒ½è°ƒä¼˜ç¤ºä¾‹ ===");
    
    // æ ¹æ®æ“ä½œç‰¹å¾é€‰æ‹©æœ€ä¼˜å †ç±»å‹
    auto benchmark = [](auto& heap, std::string_view name, int ops) {
        auto start = std::chrono::high_resolution_clock::now();
        
        // æ··åˆæ“ä½œï¼šæ’å…¥ã€åˆ é™¤ã€ä¿®æ”¹
        std::vector<decltype(heap)::point_iterator> iters;
        
        for (int i = 0; i < ops; ++i) {
            // æ’å…¥
            auto it = heap.push(std::rand() % 1000);
            iters.push_back(it);
            
            // æ¯10æ¬¡æ“ä½œä¿®æ”¹ä¸€æ¬¡
            if (i % 10 == 0 && !iters.empty()) {
                int idx = std::rand() % iters.size();
                heap.modify(iters[idx], std::rand() % 1000);
            }
            
            // æ¯20æ¬¡æ“ä½œåˆ é™¤ä¸€æ¬¡
            if (i % 20 == 0 && !heap.empty()) {
                heap.pop();
            }
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration<double, std::milli>(end - start);
        std::println("  {}: {} æ¬¡æ··åˆæ“ä½œè€—æ—¶: {:.2f} ms", name, ops, duration.count());
    };
    
    constexpr int OPS = 10000;
    
    std::println("ä¸åŒå †ç±»å‹æ€§èƒ½å¯¹æ¯”ï¼ˆ{}æ¬¡æ··åˆæ“ä½œï¼‰:", OPS);
    
    priority_queue<int, std::less<int>, pairing_heap_tag> pairing_heap;
    priority_queue<int, std::less<int>, binary_heap_tag> binary_heap;
    priority_queue<int, std::less<int>, binomial_heap_tag> binomial_heap;
    
    benchmark(pairing_heap, "é…å¯¹å †", OPS);
    benchmark(binary_heap, "äºŒå‰å †", OPS);
    benchmark(binomial_heap, "äºŒé¡¹å †", OPS);
}

int main() {
    dijkstra_algorithm_demo();
    heap_merging_demo();
    performance_tuning_demo();
    
    // ç¤ºä¾‹ï¼šä½¿ç”¨è¿­ä»£å™¨çš„é«˜çº§æ“ä½œ
    std::println("\n=== è¿­ä»£å™¨é«˜çº§æ“ä½œ ===");
    
    priority_queue<int, std::less<int>, pairing_heap_tag> iter_heap;
    
    // æ’å…¥å…ƒç´ å¹¶ä¿å­˜è¿­ä»£å™¨
    std::vector<decltype(iter_heap)::point_iterator> iterators;
    for (int i = 0; i < 10; ++i) {
        iterators.push_back(iter_heap.push(i * 10));
    }
    
    // é€šè¿‡è¿­ä»£å™¨è®¿é—®å’Œä¿®æ”¹å…ƒç´ 
    std::println("é€šè¿‡è¿­ä»£å™¨è®¿é—®å…ƒç´ :");
    for (size_t i = 0; i < iterators.size(); i += 2) {
        std::println("  è¿­ä»£å™¨{}æŒ‡å‘: {}", i, *iterators[i]);
    }
    
    // åˆ é™¤æŒ‡å®šè¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ 
    if (!iterators.empty()) {
        std::println("\nåˆ é™¤ç¬¬3ä¸ªè¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ ...");
        iter_heap.erase(iterators[2]);
        std::println("åˆ é™¤åå †å¤§å°: {}, é¡¶éƒ¨: {}", iter_heap.size(), iter_heap.top());
    }
    
    return 0;
}
```

## å…­ã€æœ€ä½³å®è·µå’Œé€‰æ‹©æŒ‡å—

### å¦‚ä½•é€‰æ‹©å †ç±»å‹ï¼š

| ä½¿ç”¨åœºæ™¯                 | æ¨èå †ç±»å‹                                   | ç†ç”±                               |
| ------------------------ | -------------------------------------------- | ---------------------------------- |
| **é€šç”¨ä¼˜å…ˆé˜Ÿåˆ—**         | `pairing_heap_tag`ï¼ˆé»˜è®¤ï¼‰                   | å¤§å¤šæ•°æ“ä½œå…·æœ‰ä¼˜ç§€çš„å¹³æ‘Šæ—¶é—´å¤æ‚åº¦ |
| **å°æ•°æ®é‡æˆ–ç¼“å­˜æ•æ„Ÿ**   | `binary_heap_tag`                            | æ•°ç»„å­˜å‚¨ï¼Œç¼“å­˜å‹å¥½ï¼Œå®ç°ç®€å•       |
| **éœ€è¦é¢‘ç¹åˆå¹¶**         | `binomial_heap_tag` æˆ– `pairing_heap_tag`    | æ”¯æŒé«˜æ•ˆåˆå¹¶æ“ä½œ                   |
| **å›¾ç®—æ³•ï¼ˆå¦‚Dijkstraï¼‰** | `thin_heap_tag`                              | é’ˆå¯¹å›¾ç®—æ³•ä¼˜åŒ–ï¼Œå‡å°‘æŒ‡é’ˆæ“ä½œ       |
| **éœ€è¦ç¨³å®šæ€§èƒ½**         | `binary_heap_tag`                            | æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ç¡®å®š             |
| **æ’å…¥æ“ä½œæå…¶é¢‘ç¹**     | `pairing_heap_tag` æˆ– `rc_binomial_heap_tag` | æ’å…¥æ“ä½œå¹³æ‘ŠO(1)                   |

### æ³¨æ„äº‹é¡¹ï¼š

1. **è¿­ä»£å™¨å¤±æ•ˆ**ï¼š
   - ä¿®æ”¹æ“ä½œï¼ˆ`modify`ï¼‰å’Œåˆ é™¤æ“ä½œï¼ˆ`erase`ï¼‰å¯èƒ½ä½¿å…¶ä»–è¿­ä»£å™¨å¤±æ•ˆ
   - åˆå¹¶æ“ä½œï¼ˆ`join`ï¼‰ä¼šä½¿è¢«åˆå¹¶å †çš„æ‰€æœ‰è¿­ä»£å™¨å¤±æ•ˆ

2. **å†…å­˜ä½¿ç”¨**ï¼š
   - é…å¯¹å †ã€äºŒé¡¹å †ç­‰ä½¿ç”¨æŒ‡é’ˆç»“æ„ï¼Œå¯èƒ½æœ‰è¾ƒé«˜çš„å†…å­˜å¼€é”€
   - äºŒå‰å †ä½¿ç”¨è¿ç»­æ•°ç»„ï¼Œå†…å­˜æ›´ç´§å‡‘ä½†å¯èƒ½é¢‘ç¹é‡æ–°åˆ†é…

3. **å¼‚å¸¸å®‰å…¨**ï¼š
   - å¤§å¤šæ•°æ“ä½œæä¾›åŸºæœ¬å¼‚å¸¸å®‰å…¨ä¿è¯
   - å¤æ‚æ“ä½œï¼ˆå¦‚åˆå¹¶ï¼‰çš„å¼‚å¸¸å®‰å…¨æ€§å–å†³äºå…·ä½“å®ç°

4. **æ€§èƒ½ç‰¹å¾**ï¼š
   - å¹³æ‘Šæ—¶é—´å¤æ‚åº¦åœ¨å®é™…ä½¿ç”¨ä¸­å¾ˆé‡è¦
   - å¸¸æ•°å› å­å¯èƒ½å½±å“å®é™…æ€§èƒ½ï¼Œéœ€è¦æ ¹æ®å…·ä½“åœºæ™¯æµ‹è¯•

### ä»£ç ç¤ºä¾‹ï¼šå®é™…åº”ç”¨åœºæ™¯

```cpp
#include <print>
#include <ext/pb_ds/priority_queue.hpp>

// å®é™…åº”ç”¨ï¼šä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ
class TaskScheduler {
private:
    struct ScheduledTask {
        int priority;      // ä¼˜å…ˆçº§ï¼Œè¶Šå¤§è¶Šä¼˜å…ˆ
        int task_id;       // ä»»åŠ¡ID
        std::string description;
        
        bool operator<(const ScheduledTask& other) const {
            return priority < other.priority;
        }
    };
    
    // ä½¿ç”¨é…å¯¹å †ä½œä¸ºä»»åŠ¡é˜Ÿåˆ—
    __gnu_pbds::priority_queue<ScheduledTask> task_queue;
    int next_task_id = 0;
    
public:
    // æ·»åŠ ä»»åŠ¡
    int add_task(int priority, std::string description) {
        int task_id = next_task_id++;
        task_queue.push({priority, task_id, description});
        return task_id;
    }
    
    // æ‰§è¡Œæœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡
    bool execute_next() {
        if (task_queue.empty()) {
            return false;
        }
        
        auto task = task_queue.top();
        task_queue.pop();
        
        std::println("æ‰§è¡Œä»»åŠ¡: [ID:{}] {} (ä¼˜å…ˆçº§:{})", 
                    task.task_id, task.description, task.priority);
        return true;
    }
    
    // è·å–é˜Ÿåˆ—å¤§å°
    size_t pending_tasks() const {
        return task_queue.size();
    }
    
    // æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡
    void clear() {
        while (!task_queue.empty()) {
            task_queue.pop();
        }
    }
};

int main() {
    std::println("=== å®é™…åº”ç”¨ï¼šä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ ===");
    
    TaskScheduler scheduler;
    
    // æ·»åŠ ä»»åŠ¡
    scheduler.add_task(1, "å¤‡ä»½æ•°æ®åº“");
    scheduler.add_task(3, "å¤„ç†ç”¨æˆ·è¯·æ±‚");
    scheduler.add_task(5, "ç³»ç»Ÿç›‘æ§å‘Šè­¦");  // æœ€é«˜ä¼˜å…ˆçº§
    scheduler.add_task(2, "ç”Ÿæˆæ—¥æŠ¥");
    scheduler.add_task(4, "ç¼“å­˜é¢„çƒ­");
    
    std::println("å¾…å¤„ç†ä»»åŠ¡æ•°: {}", scheduler.pending_tasks());
    
    // æŒ‰ä¼˜å…ˆçº§æ‰§è¡Œä»»åŠ¡
    std::println("\næŒ‰ä¼˜å…ˆçº§æ‰§è¡Œä»»åŠ¡:");
    while (scheduler.execute_next()) {
        // ç»§ç»­æ‰§è¡Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©º
    }
    
    return 0;
}
```

## ä¸ƒã€æ€»ç»“

PBDS çš„ `priority_queue` æ˜¯ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§ä¸”é«˜åº¦å¯é…ç½®çš„ä¼˜å…ˆé˜Ÿåˆ—å®ç°ï¼Œç›¸æ¯”äºæ ‡å‡†åº“çš„ `std::priority_queue`ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

### ä¸»è¦ä¼˜åŠ¿ï¼š
1. **å¤šç§å®ç°é€‰æ‹©**ï¼š5ç§ä¸åŒçš„å †å®ç°ï¼Œå¯æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©æœ€ä¼˜æ–¹æ¡ˆã€‚
2. **é«˜çº§æ“ä½œæ”¯æŒ**ï¼šæ”¯æŒåˆå¹¶ã€ä¿®æ”¹ã€é€šè¿‡è¿­ä»£å™¨åˆ é™¤ç­‰é«˜çº§æ“ä½œã€‚
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé’ˆå¯¹ä¸åŒæ“ä½œæ¨¡å¼ï¼ˆæ’å…¥å¯†é›†ã€åˆå¹¶é¢‘ç¹ç­‰ï¼‰è¿›è¡Œä¸“é—¨ä¼˜åŒ–ã€‚
4. **çµæ´»æ€§**ï¼šæ”¯æŒè‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°å’Œè¿­ä»£å™¨æ“ä½œã€‚

### é€‚ç”¨åœºæ™¯ï¼š
1. **éœ€è¦é«˜çº§æ“ä½œ**ï¼šå¦‚åˆå¹¶å¤šä¸ªä¼˜å…ˆé˜Ÿåˆ—ã€ä¿®æ”¹å †ä¸­å…ƒç´ å€¼ã€‚
2. **æ€§èƒ½æ•æ„Ÿåº”ç”¨**ï¼šå¦‚å›¾ç®—æ³•ï¼ˆDijkstraã€Primç­‰ï¼‰ã€‚
3. **ç‰¹æ®Šæ•°æ®æ¨¡å¼**ï¼šéœ€è¦æ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä¼˜å †ç»“æ„ã€‚
4. **éœ€è¦è¿­ä»£å™¨æ”¯æŒ**ï¼šéœ€è¦éå†æˆ–é€šè¿‡è¿­ä»£å™¨æ“ä½œå †å…ƒç´ ã€‚

### æ³¨æ„äº‹é¡¹ï¼š
1. **éæ ‡å‡†æ‰©å±•**ï¼šPBDS æ˜¯ GCC æ‰©å±•ï¼Œåœ¨ MSVC ç­‰å…¶ä»–ç¼–è¯‘å™¨ä¸Šä¸å¯ç”¨ã€‚
2. **å­¦ä¹ æˆæœ¬**ï¼šéœ€è¦ç†è§£ä¸åŒå †ç±»å‹çš„ç‰¹æ€§å’Œé€‚ç”¨åœºæ™¯ã€‚
3. **è¿­ä»£å™¨ç®¡ç†**ï¼šæŸäº›æ“ä½œä¼šä½¿è¿­ä»£å™¨å¤±æ•ˆï¼Œéœ€è¦è°¨æ…ç®¡ç†ã€‚

é€šè¿‡åˆç†é€‰æ‹©å †ç±»å‹å’Œåˆ©ç”¨ PBDS æä¾›çš„é«˜çº§åŠŸèƒ½ï¼Œå¯ä»¥åœ¨è®¸å¤šåœºæ™¯ä¸­è·å¾—æ¯”æ ‡å‡†åº“æ›´å¥½çš„æ€§èƒ½ã€‚ç„¶è€Œï¼Œå¯¹äºç®€å•çš„ä¼˜å…ˆé˜Ÿåˆ—éœ€æ±‚æˆ–éœ€è¦è·¨å¹³å°å…¼å®¹æ€§çš„é¡¹ç›®ï¼Œæ ‡å‡†åº“çš„ `std::priority_queue` ä»ç„¶æ˜¯æ›´åˆé€‚çš„é€‰æ‹©ã€‚

# <ç­–ç•¥ä¸æ ‡ç­¾å¤´æ–‡ä»¶>

## ä¸€ã€æ¦‚è¿°

æœ¬èŠ‚ä»‹ç» PBDS åº“ä¸­çš„ç­–ç•¥ã€æ ‡ç­¾å’Œå¼‚å¸¸å¤„ç†å¤´æ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶å®šä¹‰äº† PBDS åº“çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼å’Œæ‰©å±•æœºåˆ¶ã€‚é€šè¿‡ç­–ç•¥æ¨¡å¼å’Œæ ‡ç­¾åˆ†å‘æœºåˆ¶ï¼ŒPBDS å®ç°äº†é«˜åº¦å¯é…ç½®çš„æ•°æ®ç»“æ„ã€‚

### åŒ…å«çš„å¤´æ–‡ä»¶åŠåŠŸèƒ½ï¼š

| å¤´æ–‡ä»¶                   | ä¸»è¦åŠŸèƒ½                         |
| ------------------------ | -------------------------------- |
| `trie_policy.hpp`        | å­—å…¸æ ‘ï¼ˆTrieï¼‰ç›¸å…³çš„ç­–ç•¥å’Œæ›´æ–°å™¨ |
| `tree_policy.hpp`        | å¹³è¡¡æ ‘ï¼ˆTreeï¼‰ç›¸å…³çš„ç­–ç•¥å’Œæ›´æ–°å™¨ |
| `list_update_policy.hpp` | åˆ—è¡¨æ›´æ–°å®¹å™¨çš„ç­–ç•¥               |
| `tag_and_trait.hpp`      | ç±»å‹æ ‡ç­¾å’Œå®¹å™¨ç‰¹å¾å®šä¹‰           |
| `exception.hpp`          | PBDS ä¸“ç”¨çš„å¼‚å¸¸ç±»å®šä¹‰            |

### è®¾è®¡æ¨¡å¼åˆ†æï¼š

1. **ç­–ç•¥æ¨¡å¼ï¼ˆPolicy Patternï¼‰**
   - é€šè¿‡æ¨¡æ¿å‚æ•°å…è®¸ç”¨æˆ·é€‰æ‹©ä¸åŒçš„ç®—æ³•å®ç°
   - ä¾‹å¦‚ï¼š`trie_string_access_traits` å®šä¹‰äº†å­—ç¬¦ä¸²è®¿é—®çš„ä¸åŒç­–ç•¥

2. **æ ‡ç­¾åˆ†å‘ï¼ˆTag Dispatchingï¼‰**
   - ä½¿ç”¨ç±»å‹æ ‡ç­¾åœ¨ç¼–è¯‘æ—¶é€‰æ‹©ä¸åŒçš„å®ç°
   - ä¾‹å¦‚ï¼š`rb_tree_tag`ã€`pairing_heap_tag` ç­‰

3. **èŠ‚ç‚¹æ›´æ–°å™¨æ¨¡å¼ï¼ˆNode Updater Patternï¼‰**
   - å…è®¸åœ¨æ ‘èŠ‚ç‚¹ä¸Šé™„åŠ è‡ªå®šä¹‰çš„æ›´æ–°é€»è¾‘
   - ä¾‹å¦‚ï¼š`trie_order_statistics_node_update` ç»´æŠ¤èŠ‚ç‚¹ç»Ÿè®¡ä¿¡æ¯

4. **ç‰¹å¾ç±»æ¨¡å¼ï¼ˆTraits Patternï¼‰**
   - é€šè¿‡ç‰¹å¾ç±»æè¿°ç±»å‹çš„å±æ€§
   - ä¾‹å¦‚ï¼š`container_traits` æè¿°å®¹å™¨çš„ç‰¹æ€§

## äºŒã€å„å¤´æ–‡ä»¶è¯¦ç»†è¯´æ˜

### 1. `trie_policy.hpp` - å­—å…¸æ ‘ç­–ç•¥

#### `trie_string_access_traits`
å­—ç¬¦ä¸²è®¿é—®ç‰¹å¾ç±»ï¼Œæ§åˆ¶å­—å…¸æ ‘å¦‚ä½•è®¿é—®å’Œéå†å­—ç¬¦ä¸²å…ƒç´ ã€‚

**ä¸»è¦æ¨¡æ¿å‚æ•°ï¼š**
- `String`ï¼šå­—ç¬¦ä¸²ç±»å‹ï¼Œé»˜è®¤ä¸º `std::string`
- `Min_E_Val`ï¼šæœ€å°å…ƒç´ å€¼
- `Max_E_Val`ï¼šæœ€å¤§å…ƒç´ å€¼
- `Reverse`ï¼šæ˜¯å¦åå‘éå†
- `_Alloc`ï¼šåˆ†é…å™¨ç±»å‹

**åŠŸèƒ½ç‰¹ç‚¹ï¼š**
- æ§åˆ¶å­—å…¸æ ‘çš„å­—ç¬¦é›†èŒƒå›´
- æ”¯æŒæ­£å‘æˆ–åå‘éå†å­—ç¬¦ä¸²
- å°†å­—ç¬¦æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•ä½ç½®

#### `trie_prefix_search_node_update`
å‰ç¼€æœç´¢èŠ‚ç‚¹æ›´æ–°å™¨ï¼Œä½¿å­—å…¸æ ‘æ”¯æŒå‰ç¼€æœç´¢åŠŸèƒ½ã€‚

**åŠŸèƒ½ç‰¹ç‚¹ï¼š**
- `prefix_range()`ï¼šæŸ¥æ‰¾åŒ¹é…ç‰¹å®šå‰ç¼€çš„æ‰€æœ‰é”®
- æ”¯æŒé€šè¿‡è¿­ä»£å™¨èŒƒå›´è¿›è¡Œå‰ç¼€æœç´¢
- ç»´æŠ¤å­—å…¸æ ‘çš„å‰ç¼€æœç´¢èƒ½åŠ›

#### `trie_order_statistics_node_update`
é¡ºåºç»Ÿè®¡èŠ‚ç‚¹æ›´æ–°å™¨ï¼Œä¸ºå­—å…¸æ ‘æ·»åŠ é¡ºåºç»Ÿè®¡åŠŸèƒ½ã€‚

**åŠŸèƒ½ç‰¹ç‚¹ï¼š**
- `find_by_order()`ï¼šæŸ¥æ‰¾ç¬¬ k å°çš„é”®
- `order_of_key()`ï¼šæŸ¥æ‰¾é”®çš„æ’å
- ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹çš„å­æ ‘å¤§å°ç»Ÿè®¡

### 2. `tree_policy.hpp` - å¹³è¡¡æ ‘ç­–ç•¥

#### `tree_order_statistics_node_update`
é¡ºåºç»Ÿè®¡èŠ‚ç‚¹æ›´æ–°å™¨ï¼Œä¸ºå¹³è¡¡æ ‘æ·»åŠ é¡ºåºç»Ÿè®¡åŠŸèƒ½ã€‚

**åŠŸèƒ½ç‰¹ç‚¹ï¼š**
- `find_by_order()`ï¼šæŸ¥æ‰¾ç¬¬ k å°çš„å…ƒç´ 
- `order_of_key()`ï¼šæŸ¥æ‰¾å…ƒç´ çš„æ’å
- ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹çš„å­æ ‘å¤§å°
- æ”¯æŒåœ¨æœ‰åºå®¹å™¨ä¸­å¿«é€Ÿè¿›è¡Œé¡ºåºç»Ÿè®¡

### 3. `list_update_policy.hpp` - åˆ—è¡¨æ›´æ–°ç­–ç•¥

#### `lu_move_to_front_policy`
ç§»åŠ¨è‡³å‰ç«¯ç­–ç•¥ï¼Œæ— æ¡ä»¶å°†è®¿é—®çš„å…ƒç´ ç§»åŠ¨åˆ°åˆ—è¡¨å‰ç«¯ã€‚

**ç‰¹ç‚¹ï¼š**
- æ¯æ¬¡è®¿é—®éƒ½å°†å…ƒç´ ç§»åŠ¨åˆ°å‰ç«¯
- æ— çŠ¶æ€ï¼Œä¸éœ€è¦é¢å¤–å…ƒæ•°æ®
- é€‚ç”¨äºè®¿é—®æ¨¡å¼é«˜åº¦å€¾æ–œçš„åœºæ™¯

#### `lu_counter_policy`
è®¡æ•°å™¨ç­–ç•¥ï¼Œæ ¹æ®è®¿é—®æ¬¡æ•°å†³å®šæ˜¯å¦å°†å…ƒç´ ç§»åŠ¨åˆ°å‰ç«¯ã€‚

**æ¨¡æ¿å‚æ•°ï¼š**
- `Max_Count`ï¼šç§»åŠ¨é˜ˆå€¼ï¼Œé»˜è®¤ä¸º 5
- `_Alloc`ï¼šåˆ†é…å™¨ç±»å‹

**ç‰¹ç‚¹ï¼š**
- å…ƒç´ è¢«è®¿é—® `Max_Count` æ¬¡åæ‰ç§»åŠ¨åˆ°å‰ç«¯
- å‡å°‘é¢‘ç¹ç§»åŠ¨çš„å¼€é”€
- ç»´æŠ¤è®¿é—®è®¡æ•°å™¨å…ƒæ•°æ®

### 4. `tag_and_trait.hpp` - æ ‡ç­¾ä¸ç‰¹å¾

#### ç±»å‹æ ‡ç­¾ç³»ç»Ÿ

**æ•°æ®ç»“æ„æ ‡ç­¾ï¼š**
- `container_tag`ï¼šå®¹å™¨åŸºæ ‡ç­¾
- `associative_tag`ï¼šå…³è”å®¹å™¨æ ‡ç­¾
- `priority_queue_tag`ï¼šä¼˜å…ˆé˜Ÿåˆ—æ ‡ç­¾

**å…·ä½“å®ç°æ ‡ç­¾ï¼š**
- `cc_hash_tag`ï¼šé“¾åœ°å€æ³•å“ˆå¸Œè¡¨
- `gp_hash_tag`ï¼šæ¢æµ‹æ³•å“ˆå¸Œè¡¨
- `rb_tree_tag`ï¼šçº¢é»‘æ ‘
- `splay_tree_tag`ï¼šä¼¸å±•æ ‘
- `pat_trie_tag`ï¼šPATRICIAå­—å…¸æ ‘
- `pairing_heap_tag`ï¼šé…å¯¹å †
- `binomial_heap_tag`ï¼šäºŒé¡¹å †

#### è¿­ä»£å™¨ä¿è¯æ ‡ç­¾

**å¤±æ•ˆä¿è¯ç­‰çº§ï¼š**
- `basic_invalidation_guarantee`ï¼šåŸºæœ¬ä¿è¯
- `point_invalidation_guarantee`ï¼šç‚¹è¿­ä»£å™¨ä¿è¯
- `range_invalidation_guarantee`ï¼šèŒƒå›´è¿­ä»£å™¨ä¿è¯

#### `container_traits`
å®¹å™¨ç‰¹å¾ç±»ï¼Œæè¿°å®¹å™¨çš„å„ç§ç‰¹æ€§ã€‚

**ç‰¹å¾å±æ€§ï¼š**
- `order_preserving`ï¼šæ˜¯å¦ä¿æŒé¡ºåº
- `erase_can_throw`ï¼šåˆ é™¤æ“ä½œæ˜¯å¦å¯èƒ½æŠ›å‡ºå¼‚å¸¸
- `split_join_can_throw`ï¼šåˆ†è£‚åˆå¹¶æ˜¯å¦å¯èƒ½æŠ›å‡ºå¼‚å¸¸
- `reverse_iteration`ï¼šæ˜¯å¦æ”¯æŒåå‘è¿­ä»£

### 5. `exception.hpp` - å¼‚å¸¸å¤„ç†

#### PBDS ä¸“ç”¨å¼‚å¸¸ç±»

**å¼‚å¸¸ç±»å±‚æ¬¡ç»“æ„ï¼š**
- `container_error`ï¼šå®¹å™¨é”™è¯¯åŸºç±»
  - `insert_error`ï¼šæ’å…¥é”™è¯¯
  - `join_error`ï¼šåˆå¹¶é”™è¯¯
  - `resize_error`ï¼šè°ƒæ•´å¤§å°é”™è¯¯

## ä¸‰ã€ç­–ç•¥æ¨¡å¼ç¤ºä¾‹ä»£ç 

```cpp
#include <print>
#include <string>
#include <vector>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/trie_policy.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/list_update_policy.hpp>

// ä½¿ç”¨ pb_ds å‘½åç©ºé—´
using namespace __gnu_pbds;

// è‡ªå®šä¹‰å­—ç¬¦ä¸²è®¿é—®ç‰¹å¾ï¼šåªå¤„ç†å°å†™å­—æ¯
struct lowercase_traits {
    typedef std::string key_type;
    typedef std::string::const_iterator const_iterator;
    typedef char e_type;
    
    enum {
        min_e_val = 'a',
        max_e_val = 'z',
        max_size = max_e_val - min_e_val + 1
    };
    
    static const_iterator begin(const key_type& key) {
        return key.begin();
    }
    
    static const_iterator end(const key_type& key) {
        return key.end();
    }
    
    static std::size_t e_pos(e_type e) {
        return static_cast<std::size_t>(e - min_e_val);
    }
};

int main() {
    // ç¤ºä¾‹1ï¼šå­—å…¸æ ‘ç­–ç•¥ç»„åˆ
    std::println("=== ç¤ºä¾‹1ï¼šå­—å…¸æ ‘ç­–ç•¥ç»„åˆ ===");
    
    // ä½¿ç”¨è‡ªå®šä¹‰ç‰¹å¾å’Œé¡ºåºç»Ÿè®¡æ›´æ–°å™¨çš„å­—å…¸æ ‘
    typedef trie<std::string, 
                 int,
                 trie_string_access_traits<>,
                 pat_trie_tag,
                 trie_order_statistics_node_update> order_stat_trie;
    
    order_stat_trie word_trie;
    
    // æ’å…¥å•è¯
    std::vector<std::string> words = {
        "apple", "application", "app", "banana", 
        "band", "bandage", "cat", "catalog"
    };
    
    for (size_t i = 0; i < words.size(); ++i) {
        word_trie[words[i]] = static_cast<int>(i);
    }
    
    std::println("å­—å…¸æ ‘å¤§å°: {}", word_trie.size());
    
    // ä½¿ç”¨é¡ºåºç»Ÿè®¡åŠŸèƒ½
    std::println("\né¡ºåºç»Ÿè®¡åŠŸèƒ½:");
    
    // æŸ¥æ‰¾ç¬¬ k å°çš„é”®
    for (size_t i = 0; i < word_trie.size(); ++i) {
        auto it = word_trie.find_by_order(i);
        std::println("  ç¬¬ {} å°çš„é”®: {}", i, it->first);
    }
    
    // æŸ¥æ‰¾é”®çš„æ’å
    std::println("\né”®çš„æ’å:");
    for (const auto& word : words) {
        size_t rank = word_trie.order_of_key(word);
        std::println("  '{}' çš„æ’å: {}", word, rank);
    }
    
    // å‰ç¼€æœç´¢ï¼ˆéœ€è¦å‰ç¼€æœç´¢æ›´æ–°å™¨ï¼‰
    typedef trie<std::string,
                 int,
                 trie_string_access_traits<>,
                 pat_trie_tag,
                 trie_prefix_search_node_update> prefix_trie;
    
    prefix_trie prefix_tree;
    for (size_t i = 0; i < words.size(); ++i) {
        prefix_tree[words[i]] = static_cast<int>(i);
    }
    
    std::println("\nå‰ç¼€æœç´¢åŠŸèƒ½:");
    
    // æŸ¥æ‰¾ä»¥ "app" ä¸ºå‰ç¼€çš„æ‰€æœ‰é”®
    auto app_range = prefix_tree.prefix_range("app");
    std::println("ä»¥ 'app' ä¸ºå‰ç¼€çš„é”®:");
    for (auto it = app_range.first; it != app_range.second; ++it) {
        std::println("  {}", it->first);
    }
    
    // ç¤ºä¾‹2ï¼šå¹³è¡¡æ ‘ç­–ç•¥
    std::println("\n=== ç¤ºä¾‹2ï¼šå¹³è¡¡æ ‘ç­–ç•¥ ===");
    
    // ä½¿ç”¨é¡ºåºç»Ÿè®¡æ›´æ–°å™¨çš„çº¢é»‘æ ‘
    typedef tree<int,
                 std::string,
                 std::less<int>,
                 rb_tree_tag,
                 tree_order_statistics_node_update> order_stat_tree;
    
    order_stat_tree number_tree;
    
    // æ’å…¥æ•°å­—
    for (int i = 0; i < 10; ++i) {
        number_tree[i * 10] = std::format("value_{}", i * 10);
    }
    
    std::println("å¹³è¡¡æ ‘å†…å®¹ï¼ˆæœ‰åºï¼‰:");
    for (const auto& [key, value] : number_tree) {
        std::println("  {}: {}", key, value);
    }
    
    // é¡ºåºç»Ÿè®¡åŠŸèƒ½
    std::println("\nå¹³è¡¡æ ‘é¡ºåºç»Ÿè®¡:");
    
    // æŸ¥æ‰¾ç¬¬ 3 å°çš„å…ƒç´ 
    auto third_it = number_tree.find_by_order(2);
    if (third_it != number_tree.end()) {
        std::println("  ç¬¬ 3 å°çš„å…ƒç´ : {}: {}", third_it->first, third_it->second);
    }
    
    // æŸ¥æ‰¾å…ƒç´  50 çš„æ’å
    size_t rank_50 = number_tree.order_of_key(50);
    std::println("  å…ƒç´  50 çš„æ’å: {}", rank_50);
    
    // æŸ¥æ‰¾èŒƒå›´ [25, 75] å†…çš„å…ƒç´ æ•°é‡
    size_t count_range = number_tree.order_of_key(75) - number_tree.order_of_key(25);
    std::println("  å€¼åœ¨ [25, 75] èŒƒå›´å†…çš„å…ƒç´ æ•°é‡: {}", count_range);
    
    // ç¤ºä¾‹3ï¼šåˆ—è¡¨æ›´æ–°ç­–ç•¥
    std::println("\n=== ç¤ºä¾‹3ï¼šåˆ—è¡¨æ›´æ–°ç­–ç•¥ ===");
    
    // ä½¿ç”¨è®¡æ•°å™¨ç­–ç•¥çš„åˆ—è¡¨æ›´æ–°å®¹å™¨
    typedef list_update<std::string,
                        int,
                        lu_counter_policy<3>> counter_list;
    
    counter_list access_list;
    
    // æ’å…¥å…ƒç´ 
    access_list["first"] = 1;
    access_list["second"] = 2;
    access_list["third"] = 3;
    access_list["fourth"] = 4;
    
    std::println("åˆå§‹é¡ºåº:");
    for (const auto& [key, value] : access_list) {
        std::println("  {}: {}", key, value);
    }
    
    // æ¨¡æ‹Ÿè®¿é—®æ¨¡å¼
    std::println("\næ¨¡æ‹Ÿè®¿é—®ï¼ˆè®¡æ•°å™¨ç­–ç•¥ï¼Œé˜ˆå€¼=3ï¼‰:");
    
    auto access_element = [&](const std::string& key) {
        std::println("  è®¿é—®å…ƒç´ : {}", key);
        auto it = access_list.find(key);
        if (it != access_list.end()) {
            // è®¿é—®ä¼šè§¦å‘ç­–ç•¥æ£€æŸ¥
            // æ¯è®¿é—®3æ¬¡ï¼Œå…ƒç´ ä¼šè¢«ç§»åŠ¨åˆ°å‰ç«¯
        }
    };
    
    // å¤šæ¬¡è®¿é—® "third"
    for (int i = 0; i < 5; ++i) {
        access_element("third");
    }
    
    // å¤šæ¬¡è®¿é—® "second"
    for (int i = 0; i < 2; ++i) {
        access_element("second");
    }
    
    std::println("\næœ€ç»ˆé¡ºåºï¼ˆè®¿é—®æ¬¡æ•°è¶³å¤Ÿçš„å…ƒç´ ä¼šç§»åŠ¨åˆ°å‰ç«¯ï¼‰:");
    for (const auto& [key, value] : access_list) {
        std::println("  {}: {}", key, value);
    }
    
    // å¯¹æ¯”ï¼šç§»åŠ¨è‡³å‰ç«¯ç­–ç•¥
    std::println("\nå¯¹æ¯”ï¼šç§»åŠ¨è‡³å‰ç«¯ç­–ç•¥");
    
    typedef list_update<std::string,
                        int,
                        lu_move_to_front_policy<>> mtf_list;
    
    mtf_list mtf_container;
    mtf_container["a"] = 1;
    mtf_container["b"] = 2;
    mtf_container["c"] = 3;
    
    std::println("åˆå§‹çŠ¶æ€:");
    for (const auto& [key, value] : mtf_container) {
        std::println("  {}: {}", key, value);
    }
    
    // è®¿é—®ä¸€ä¸ªå…ƒç´ ï¼ˆä¼šç«‹å³ç§»åŠ¨åˆ°å‰ç«¯ï¼‰
    mtf_container.find("c");
    
    std::println("è®¿é—® 'c' å:");
    for (const auto& [key, value] : mtf_container) {
        std::println("  {}: {}", key, value);
    }
    
    // ç¤ºä¾‹4ï¼šè‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°ç­–ç•¥
    std::println("\n=== ç¤ºä¾‹4ï¼šè‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°ç­–ç•¥ ===");
    
    // è‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°å™¨ï¼Œç»´æŠ¤èŠ‚ç‚¹æ·±åº¦ä¿¡æ¯
    template<typename Node_CItr, typename Node_Itr,
             typename Cmp_Fn, typename _Alloc>
    class depth_node_update {
    public:
        typedef int metadata_type;
        
        // æ›´æ–°èŠ‚ç‚¹æ·±åº¦ä¿¡æ¯
        void operator()(Node_Itr it, Node_CItr end_it) const {
            Node_Itr l_child = it.get_l_child();
            Node_Itr r_child = it.get_r_child();
            
            int left_depth = 0, right_depth = 0;
            if (l_child != end_it) left_depth = l_child.get_metadata();
            if (r_child != end_it) right_depth = r_child.get_metadata();
            
            // å½“å‰èŠ‚ç‚¹æ·±åº¦ = æœ€å¤§å­èŠ‚ç‚¹æ·±åº¦ + 1
            const_cast<metadata_type&>(it.get_metadata()) = 
                std::max(left_depth, right_depth) + 1;
        }
        
        // è·å–æ ‘çš„é«˜åº¦
        int get_height(Node_CItr it) const {
            if (it == Node_CItr()) return 0;
            return it.get_metadata();
        }
    };
    
    // ä½¿ç”¨è‡ªå®šä¹‰æ›´æ–°å™¨çš„æ ‘
    typedef tree<int,
                 std::string,
                 std::less<int>,
                 rb_tree_tag,
                 depth_node_update> depth_tree;
    
    depth_tree depth_aware_tree;
    
    // æ’å…¥å…ƒç´ 
    for (int i = 0; i < 20; ++i) {
        depth_aware_tree[i * 5] = std::format("val_{}", i * 5);
    }
    
    // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–äº†ï¼Œå®é™…éœ€è¦è·å–æ ¹èŠ‚ç‚¹è¿­ä»£å™¨æ¥è®¿é—®å…ƒæ•°æ®
    std::println("å¸¦æœ‰æ·±åº¦ä¿¡æ¯çš„æ ‘åˆ›å»ºå®Œæˆ");
    
    // ç¤ºä¾‹5ï¼šå¼‚å¸¸å¤„ç†
    std::println("\n=== ç¤ºä¾‹5ï¼šå¼‚å¸¸å¤„ç† ===");
    
    try {
        // å°è¯•éæ³•æ“ä½œï¼ˆç¤ºä¾‹ï¼‰
        tree<int, int> tree1, tree2;
        
        // æ’å…¥é‡å çš„èŒƒå›´
        for (int i = 0; i < 10; ++i) {
            tree1.insert({i, i * 2});
            tree2.insert({i + 5, (i + 5) * 2});  // é‡å èŒƒå›´
        }
        
        // å°è¯•åˆå¹¶æœ‰é‡å èŒƒå›´çš„æ ‘ï¼ˆä¼šæŠ›å‡º join_errorï¼‰
        // tree1.join(tree2);  // è¿™è¡Œä¼šæŠ›å‡ºå¼‚å¸¸
        
        std::println("æ— å¼‚å¸¸å‘ç”Ÿ");
    } catch (const __gnu_pbds::join_error& e) {
        std::println("æ•è·åˆ° join_error: {}", e.what());
    } catch (const __gnu_pbds::container_error& e) {
        std::println("æ•è·åˆ° container_error: {}", e.what());
    }
    
    return 0;
}
```

## å››ã€é«˜çº§ç­–ç•¥ç»„åˆç¤ºä¾‹

```cpp
#include <print>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/trie_policy.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;

// é«˜çº§ç¤ºä¾‹ï¼šè‡ªåŠ¨è¡¥å…¨ç³»ç»Ÿ
class AutocompleteSystem {
private:
    // ä½¿ç”¨å‰ç¼€æœç´¢å’Œé¡ºåºç»Ÿè®¡çš„å­—å…¸æ ‘
    typedef trie<std::string,
                 int,  // ä½¿ç”¨é¢‘ç‡
                 trie_string_access_traits<>,
                 pat_trie_tag,
                 trie_prefix_search_node_update> TrieType;
    
    TrieType dictionary;
    
public:
    // æ·»åŠ å•è¯åŠå…¶é¢‘ç‡
    void add_word(const std::string& word, int frequency = 1) {
        if (dictionary.find(word) != dictionary.end()) {
            // å¦‚æœå•è¯å·²å­˜åœ¨ï¼Œå¢åŠ é¢‘ç‡
            dictionary[word] += frequency;
        } else {
            dictionary[word] = frequency;
        }
    }
    
    // è·å–è¡¥å…¨å»ºè®®
    std::vector<std::string> get_completions(const std::string& prefix, 
                                             size_t max_results = 5) {
        std::vector<std::string> completions;
        
        // ä½¿ç”¨å‰ç¼€æœç´¢åŠŸèƒ½
        auto range = dictionary.prefix_range(prefix);
        
        // æ”¶é›†æ‰€æœ‰åŒ¹é…çš„å•è¯
        for (auto it = range.first; it != range.second && completions.size() < max_results; ++it) {
            completions.push_back(it->first);
        }
        
        return completions;
    }
    
    // è·å–çƒ­è¯è¡¥å…¨ï¼ˆæŒ‰é¢‘ç‡æ’åºï¼‰
    std::vector<std::pair<std::string, int>> get_hot_completions(
        const std::string& prefix, 
        size_t max_results = 5) {
        
        std::vector<std::pair<std::string, int>> completions;
        
        // è·å–æ‰€æœ‰åŒ¹é…çš„å•è¯
        auto range = dictionary.prefix_range(prefix);
        
        for (auto it = range.first; it != range.second; ++it) {
            completions.emplace_back(it->first, it->second);
        }
        
        // æŒ‰é¢‘ç‡æ’åºï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯ä»¥ä½¿ç”¨æ›´é«˜æ•ˆçš„æ–¹æ³•ï¼‰
        std::sort(completions.begin(), completions.end(),
                  [](const auto& a, const auto& b) {
                      return a.second > b.second;  // é™åº
                  });
        
        if (completions.size() > max_results) {
            completions.resize(max_results);
        }
        
        return completions;
    }
    
    // æ˜¾ç¤ºå­—å…¸æ ‘ç»Ÿè®¡ä¿¡æ¯
    void show_statistics() const {
        std::println("å­—å…¸æ ‘ç»Ÿè®¡:");
        std::println("  å•è¯æ€»æ•°: {}", dictionary.size());
        
        // ç»Ÿè®¡ä¸åŒé•¿åº¦çš„å•è¯æ•°é‡
        std::map<size_t, size_t> length_dist;
        for (const auto& entry : dictionary) {
            length_dist[entry.first.size()]++;
        }
        
        std::println("  å•è¯é•¿åº¦åˆ†å¸ƒ:");
        for (const auto& [length, count] : length_dist) {
            std::println("    é•¿åº¦ {}: {} ä¸ªå•è¯", length, count);
        }
    }
};

// é«˜çº§ç¤ºä¾‹ï¼šæ’è¡Œæ¦œç³»ç»Ÿ
class Leaderboard {
private:
    // ä½¿ç”¨é¡ºåºç»Ÿè®¡çš„å¹³è¡¡æ ‘
    typedef tree<int,  // åˆ†æ•°
                 std::string,  // ç©å®¶å
                 std::greater<int>,  // é™åºæ’åˆ—ï¼ˆåˆ†æ•°é«˜çš„åœ¨å‰ï¼‰
                 rb_tree_tag,
                 tree_order_statistics_node_update> ScoreTree;
    
    ScoreTree scores;
    std::map<std::string, ScoreTree::iterator> player_iterators;
    
public:
    // æ·»åŠ æˆ–æ›´æ–°ç©å®¶åˆ†æ•°
    void add_score(const std::string& player, int score) {
        // å¦‚æœç©å®¶å·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤æ—§è®°å½•
        auto it = player_iterators.find(player);
        if (it != player_iterators.end()) {
            scores.erase(it->second);
        }
        
        // æ’å…¥æ–°è®°å½•
        auto new_it = scores.insert({score, player}).first;
        player_iterators[player] = new_it;
    }
    
    // è·å–ç©å®¶æ’åï¼ˆ0-basedï¼‰
    size_t get_rank(const std::string& player) const {
        auto it = player_iterators.find(player);
        if (it == player_iterators.end()) {
            throw std::runtime_error("ç©å®¶ä¸å­˜åœ¨");
        }
        
        // ä½¿ç”¨ order_of_key è·å–æ’å
        return scores.order_of_key(it->second->first);
    }
    
    // è·å–å‰ N åç©å®¶
    std::vector<std::pair<std::string, int>> get_top_n(size_t n) const {
        std::vector<std::pair<std::string, int>> top_players;
        
        size_t count = std::min(n, scores.size());
        for (size_t i = 0; i < count; ++i) {
            auto it = scores.find_by_order(i);
            if (it != scores.end()) {
                top_players.emplace_back(it->second, it->first);
            }
        }
        
        return top_players;
    }
    
    // è·å–ç©å®¶åœ¨æŸä¸ªç™¾åˆ†æ¯”åŒºé—´çš„æ’å
    std::string get_percentile_rank(const std::string& player) const {
        size_t rank = get_rank(player);
        double percentile = 100.0 * (1.0 - static_cast<double>(rank) / scores.size());
        
        return std::format("å‰ {:.1f}%", percentile);
    }
    
    // æ˜¾ç¤ºæ’è¡Œæ¦œ
    void show_leaderboard(size_t limit = 10) const {
        std::println("æ’è¡Œæ¦œï¼ˆå‰ {} åï¼‰:", std::min(limit, scores.size()));
        
        auto top_players = get_top_n(limit);
        for (size_t i = 0; i < top_players.size(); ++i) {
            std::println("  {}. {} - {} åˆ†", 
                        i + 1, top_players[i].first, top_players[i].second);
        }
    }
};

int main() {
    std::println("=== é«˜çº§ç­–ç•¥ç»„åˆç¤ºä¾‹ ===");
    
    // ç¤ºä¾‹1ï¼šè‡ªåŠ¨è¡¥å…¨ç³»ç»Ÿ
    std::println("\n1. è‡ªåŠ¨è¡¥å…¨ç³»ç»Ÿç¤ºä¾‹");
    
    AutocompleteSystem autocomplete;
    
    // æ·»åŠ ä¸€äº›å•è¯å’Œé¢‘ç‡
    autocomplete.add_word("apple", 50);
    autocomplete.add_word("application", 30);
    autocomplete.add_word("app", 100);
    autocomplete.add_word("approve", 20);
    autocomplete.add_word("banana", 40);
    autocomplete.add_word("band", 25);
    autocomplete.add_word("bandage", 10);
    
    // æµ‹è¯•è¡¥å…¨
    std::string prefix = "app";
    std::println("è¾“å…¥ '{}' çš„è¡¥å…¨å»ºè®®:", prefix);
    
    auto completions = autocomplete.get_completions(prefix);
    for (const auto& word : completions) {
        std::println("  - {}", word);
    }
    
    // è·å–çƒ­è¯è¡¥å…¨
    std::println("\nè¾“å…¥ '{}' çš„çƒ­è¯è¡¥å…¨ï¼ˆæŒ‰é¢‘ç‡ï¼‰:", prefix);
    auto hot_completions = autocomplete.get_hot_completions(prefix);
    for (const auto& [word, freq] : hot_completions) {
        std::println("  - {} (é¢‘ç‡: {})", word, freq);
    }
    
    autocomplete.show_statistics();
    
    // ç¤ºä¾‹2ï¼šæ’è¡Œæ¦œç³»ç»Ÿ
    std::println("\n2. æ’è¡Œæ¦œç³»ç»Ÿç¤ºä¾‹");
    
    Leaderboard leaderboard;
    
    // æ·»åŠ ç©å®¶åˆ†æ•°
    leaderboard.add_score("Alice", 1500);
    leaderboard.add_score("Bob", 1800);
    leaderboard.add_score("Charlie", 1200);
    leaderboard.add_score("David", 2000);
    leaderboard.add_score("Eve", 1700);
    leaderboard.add_score("Frank", 1600);
    leaderboard.add_score("Grace", 1900);
    
    // æ›´æ–°åˆ†æ•°
    leaderboard.add_score("Bob", 2100);  // Bob æé«˜äº†åˆ†æ•°
    
    // æ˜¾ç¤ºæ’è¡Œæ¦œ
    leaderboard.show_leaderboard();
    
    // è·å–ç‰¹å®šç©å®¶çš„æ’å
    std::println("\nç©å®¶æ’åä¿¡æ¯:");
    for (const auto& player : {"Alice", "Bob", "Charlie", "David"}) {
        try {
            size_t rank = leaderboard.get_rank(player);
            std::string percentile = leaderboard.get_percentile_rank(player);
            std::println("  {}: æ’åç¬¬ {}ï¼Œ{}", player, rank + 1, percentile);
        } catch (const std::exception& e) {
            std::println("  {}: {}", player, e.what());
        }
    }
    
    // ç¤ºä¾‹3ï¼šç»¼åˆåº”ç”¨ - æ–‡æœ¬åˆ†æ
    std::println("\n3. ç»¼åˆåº”ç”¨ - æ–‡æœ¬åˆ†æ");
    
    // ä½¿ç”¨ä¸åŒç­–ç•¥çš„å®¹å™¨è¿›è¡Œæ–‡æœ¬åˆ†æ
    typedef tree<std::string,
                 size_t,  // è¯é¢‘
                 std::less<std::string>,
                 rb_tree_tag,
                 tree_order_statistics_node_update> WordFrequencyTree;
    
    WordFrequencyTree word_freq;
    
    // æ¨¡æ‹Ÿæ–‡æœ¬å¤„ç†
    std::vector<std::string> document = {
        "the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog",
        "the", "quick", "brown", "fox", "is", "very", "quick"
    };
    
    // ç»Ÿè®¡è¯é¢‘
    for (const auto& word : document) {
        if (word_freq.find(word) != word_freq.end()) {
            word_freq[word]++;
        } else {
            word_freq[word] = 1;
        }
    }
    
    // æ˜¾ç¤ºè¯é¢‘ç»Ÿè®¡
    std::println("æ–‡æ¡£è¯é¢‘ç»Ÿè®¡:");
    for (const auto& [word, freq] : word_freq) {
        std::println("  {}: {}", word, freq);
    }
    
    // ä½¿ç”¨é¡ºåºç»Ÿè®¡åŠŸèƒ½
    std::println("\nè¯æ±‡è¡¨é¡ºåºç»Ÿè®¡:");
    std::println("  æ€»è¯æ±‡é‡: {}", word_freq.size());
    
    // æ‰¾åˆ°ä¸­ä½æ•°è¯æ±‡
    size_t median_pos = word_freq.size() / 2;
    auto median_it = word_freq.find_by_order(median_pos);
    if (median_it != word_freq.end()) {
        std::println("  ä¸­ä½æ•°è¯æ±‡: '{}' (é¢‘ç‡: {})", 
                    median_it->first, median_it->second);
    }
    
    // åˆ†æè¯æ±‡åˆ†å¸ƒ
    std::println("\nè¯æ±‡åˆ†å¸ƒåˆ†æ:");
    for (size_t i = 0; i < word_freq.size(); i += word_freq.size() / 4) {
        auto it = word_freq.find_by_order(i);
        if (it != word_freq.end()) {
            std::println("  ç¬¬ {} ä¸ªè¯æ±‡: '{}'", i, it->first);
        }
    }
    
    return 0;
}
```

## äº”ã€æœ€ä½³å®è·µå’Œè®¾è®¡å»ºè®®

### 1. **ç­–ç•¥é€‰æ‹©æŒ‡å—**

| éœ€æ±‚åœºæ™¯           | æ¨èç­–ç•¥                            | ç†ç”±                   |
| ------------------ | ----------------------------------- | ---------------------- |
| **éœ€è¦å‰ç¼€æœç´¢**   | `trie_prefix_search_node_update`    | ä¸“é—¨ä¸ºå‰ç¼€æœç´¢ä¼˜åŒ–     |
| **éœ€è¦é¡ºåºç»Ÿè®¡**   | `tree_order_statistics_node_update` | æ”¯æŒå¿«é€Ÿæ’åå’ŒæŸ¥æ‰¾     |
| **ç¼“å­˜ä¼˜åŒ–**       | `lu_counter_policy`                 | å¹³è¡¡ç§»åŠ¨å¼€é”€å’Œç¼“å­˜æ•ˆæœ |
| **é«˜é¢‘è®¿é—®ä¼˜åŒ–**   | `lu_move_to_front_policy`           | ç«‹å³å°†çƒ­ç‚¹æ•°æ®ç§»åˆ°å‰ç«¯ |
| **è‡ªå®šä¹‰èŠ‚ç‚¹ä¿¡æ¯** | è‡ªå®šä¹‰èŠ‚ç‚¹æ›´æ–°å™¨                    | çµæ´»ç»´æŠ¤èŠ‚ç‚¹ç‰¹å®šä¿¡æ¯   |

### 2. **æ ‡ç­¾ç³»ç»Ÿä½¿ç”¨å»ºè®®**

```cpp
// æ˜ç¡®æŒ‡å®šæ ‡ç­¾ä»¥è·å¾—æœ€ä½³æ€§èƒ½
tree<int, int, std::less<int>, rb_tree_tag> rb_tree;      // çº¢é»‘æ ‘
tree<int, int, std::less<int>, splay_tree_tag> splay_tree; // ä¼¸å±•æ ‘
trie<std::string, int, pat_trie_tag> pat_trie;            // PATRICIAå­—å…¸æ ‘
```

### 3. **å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ**

```cpp
try {
    // PBDS å®¹å™¨æ“ä½œ
    tree1.join(tree2);
} catch (const __gnu_pbds::join_error& e) {
    // å¤„ç†åˆå¹¶é”™è¯¯ï¼ˆå¦‚èŒƒå›´é‡å ï¼‰
    std::println("åˆå¹¶å¤±è´¥: {}", e.what());
} catch (const __gnu_pbds::insert_error& e) {
    // å¤„ç†æ’å…¥é”™è¯¯
    std::println("æ’å…¥å¤±è´¥: {}", e.what());
} catch (const std::exception& e) {
    // å¤„ç†å…¶ä»–æ ‡å‡†å¼‚å¸¸
    std::println("æ ‡å‡†å¼‚å¸¸: {}", e.what());
}
```

### 4. **æ€§èƒ½ä¼˜åŒ–æŠ€å·§**

1. **é€‰æ‹©åˆé€‚çš„æ›´æ–°å™¨**
   - ä¸éœ€è¦é¡ºåºç»Ÿè®¡æ—¶ä¸è¦ä½¿ç”¨ `order_statistics_node_update`
   - ç®€å•çš„å­—å…¸æ ‘ä¸éœ€è¦å‰ç¼€æœç´¢æ›´æ–°å™¨

2. **æ§åˆ¶å…ƒæ•°æ®å¤§å°**
   - èŠ‚ç‚¹æ›´æ–°å™¨çš„å…ƒæ•°æ®ä¼šå¢åŠ å†…å­˜å¼€é”€
   - åªåœ¨å¿…è¦æ—¶æ·»åŠ å¤æ‚çš„å…ƒæ•°æ®

3. **åˆ©ç”¨ç¼–è¯‘æ—¶ä¼˜åŒ–**
   - æ ‡ç­¾å’Œç­–ç•¥åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œæ— è¿è¡Œæ—¶å¼€é”€
   - ä½¿ç”¨ç‰¹å¾ç±»é¿å…è™šå‡½æ•°è°ƒç”¨

4. **æ‰¹é‡æ“ä½œä¼˜åŒ–**
   - æŸäº›æ“ä½œï¼ˆå¦‚åˆå¹¶ï¼‰æœ‰ä¸“é—¨çš„ä¼˜åŒ–
   - æ‰¹é‡æ’å…¥å¯èƒ½æ¯”å•æ¬¡æ’å…¥æ›´é«˜æ•ˆ

## å…­ã€æ€»ç»“

PBDS çš„ç­–ç•¥å’Œæ ‡ç­¾ç³»ç»Ÿæä¾›äº†å¼ºå¤§çš„æ‰©å±•èƒ½åŠ›ï¼Œå…¶ä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š

### æ ¸å¿ƒä¼˜åŠ¿ï¼š
1. **é«˜åº¦å¯é…ç½®æ€§**ï¼šé€šè¿‡ç­–ç•¥æ¨¡å¼å’Œæ ‡ç­¾ç³»ç»Ÿå®ç°é«˜åº¦å®šåˆ¶
2. **ç¼–è¯‘æ—¶ä¼˜åŒ–**ï¼šæ‰€æœ‰ç­–ç•¥åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œæ— è¿è¡Œæ—¶å¼€é”€
3. **æ¨¡å—åŒ–è®¾è®¡**ï¼šå„ç»„ä»¶èŒè´£æ¸…æ™°ï¼Œæ˜“äºç»„åˆå’Œæ‰©å±•
4. **æ€§èƒ½å¯¼å‘**ï¼šé’ˆå¯¹ä¸åŒåœºæ™¯æä¾›ä¸“é—¨çš„ä¼˜åŒ–ç­–ç•¥

### å…¸å‹åº”ç”¨ï¼š
1. **å­—å…¸æ ‘åº”ç”¨**ï¼šè‡ªåŠ¨è¡¥å…¨ã€æ‹¼å†™æ£€æŸ¥ã€å‰ç¼€æœç´¢
2. **å¹³è¡¡æ ‘åº”ç”¨**ï¼šæ’è¡Œæ¦œã€é¡ºåºç»Ÿè®¡ã€èŒƒå›´æŸ¥è¯¢
3. **åˆ—è¡¨æ›´æ–°åº”ç”¨**ï¼šLRUç¼“å­˜ã€è®¿é—®é¢‘ç‡ä¼˜åŒ–
4. **ç»¼åˆåº”ç”¨**ï¼šæ–‡æœ¬åˆ†æã€æ•°æ®åº“ç´¢å¼•ã€ç¼“å­˜ç³»ç»Ÿ

### æ³¨æ„äº‹é¡¹ï¼š
1. **GCC ä¸“æœ‰**ï¼šPBDS æ˜¯ GCC æ‰©å±•ï¼Œéæ ‡å‡† C++
2. **å­¦ä¹ æ›²çº¿**ï¼šç­–ç•¥å’Œæ ‡ç­¾ç³»ç»Ÿéœ€è¦ä¸€å®šçš„å­¦ä¹ æˆæœ¬
3. **è°ƒè¯•å¤æ‚åº¦**ï¼šæ¨¡æ¿å…ƒç¼–ç¨‹å¯èƒ½å¢åŠ è°ƒè¯•éš¾åº¦
4. **ç¼–è¯‘æ—¶é—´**ï¼šå¤æ‚ç­–ç•¥ç»„åˆå¯èƒ½å¢åŠ ç¼–è¯‘æ—¶é—´

é€šè¿‡åˆç†åˆ©ç”¨ PBDS çš„ç­–ç•¥å’Œæ ‡ç­¾ç³»ç»Ÿï¼Œå¯ä»¥åœ¨ä¿æŒä»£ç æ¸…æ™°çš„åŒæ—¶è·å¾—å“è¶Šçš„æ€§èƒ½è¡¨ç°ï¼Œç‰¹åˆ«é€‚åˆå¯¹æ€§èƒ½æœ‰ä¸¥æ ¼è¦æ±‚æˆ–éœ€è¦ç‰¹å®šæ•°æ®ç»“æ„çš„åº”ç”¨åœºæ™¯ã€‚
