# C++模板详解：从基础到高级特性

# 视频教程

https://www.bilibili.com/video/BV1ui4y1R78s

## 1. 模板基础

### 1.1 为什么需要模板？

在早期 C++ 中，实现通用功能需为不同类型重复编写代码（如 `max(int, int)`、`max(double, double)`）。模板通过**泛型编程**解决此问题，允许编写与类型无关的代码，提升复用性并减少冗余。

### 1.2 模板的作用

1. **类型无关的通用算法**（如 STL 容器和算法）
2. **编译期多态**（优于运行时多态的性能）
3. **元编程基础**（编译期计算）
4. **代码精简**（避免手动重复）

### 1.3 模板编译

#### 1.3.1 编译要求

> 当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。
>
> 通常，*当我们调用一个函数时，编译器只需要掌握函数的声明*。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。
>
> 模板则不同：**为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义**。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

#### 1.3.2 编译报错三阶段

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。

* 第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以**检查语法错误，例如忘记分号或者变量名拼错等**，但也就这么多了。

* 第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常**会检查实参数目是否正确。它还能检查参数类型是否匹配**。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。

* 第三个阶段是模板实例化时，**只有这个阶段才能发现类型相关的错误**。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

### 1.4 模板定义（图灵完备的宏）

#### 1.4.1 写法使用

```cpp
template <typename T, class U> // ok
template <typename T, U> // error
    
template<typename T>
class BlobPtr;//前向声明

template<typename T, class U>
using Pair = std::pair<T, U> //类型别名

template<typename T>
using PairNo = std::pair<T, unsigned> //偏特化
PairNo<std::string> books; //使用

//默认情况下，C+语言假定通过作用域运算符访问的名字不是类型。
//因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是
//我们通过使用关键字typename来实现这一点：
//用typename告知编译器T:value_type是一个类型
template <typename T>
typename T:value_type top(const T &c)
{
	return !c.empty() ? c.back() : typename T:value_type();
}
```

#### 1.4.2 函数模板

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
// 使用：max<int>(3, 5); max<double>(2.8, 3.1);
```

#### 1.4.3 类模板

类模板(class template)是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息`vector<int>`用来代替模板参数的模板实参列表。对于每个类型的实例，编译器都会生成一个对应类型的类

```cpp
template <typename T>
class Stack {
private:
    std::vector<T> elems;
public:
    void push(const T& elem);
    T pop();
};
// 使用：Stack<std::string> s;
```

#### 1.4.4 模板模板参数

##### 1.4.4.1 语法

```cpp
template <template <typename, typename> class Container>
class MyClass { /* ... */ };
```

##### 1.4.4.2 示例

```cpp
#include <iostream>
#include <vector>
#include <list>

template <template <typename, typename> class Container, typename T>
class ContainerPrinter {
public:
    void print(const Container<T, std::allocator<T>>& container) {
        for(const auto& elem : container)
            std::cout << elem << " ";
        std::cout << std::endl;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<int> lst = {10, 20, 30};

    ContainerPrinter<std::vector, int> vecPrinter;
    vecPrinter.print(vec); // 输出：1 2 3 4 5 

    ContainerPrinter<std::list, int> listPrinter;
    listPrinter.print(lst); // 输出：10 20 30 

    return 0;
}
```

### 1.5 模板匹配机制

#### 1.5.1 三个规则

模板特化的匹配规则是：当有多个模板可以匹配时，编译器会选择最特化的版本。具体顺序为：

1. **优先匹配全特化模板**：因为全特化模板是针对特定类型的具体实现，所以最特化。
2. **其次匹配偏特化模板**：偏特化模板是对部分类型或类型组合的特殊处理，其特化程度介于全特化和主模板之间。
3. **最后匹配通用的主模板**：当没有特化模板可以匹配时，使用主模板。

#### 1.5.2 匹配规则总结表

| 情况                   | 匹配顺序                 | 示例                                    |
| ---------------------- | ------------------------ | --------------------------------------- |
| **有全特化**           | 全特化 > 偏特化 > 主模板 | `TypeTrait<int>` 匹配全特化版本         |
| **无全特化，有偏特化** | 偏特化 > 主模板          | `TypeTrait<double*>` 匹配指针偏特化     |
| **只有主模板**         | 主模板                   | `TypeTrait<double>` 匹配主模板          |
| **多个偏特化匹配**     | 选择"最特化"的偏特化     | `Printer<T***>` 比 `Printer<T*>` 更特化 |
| **模糊匹配**           | 编译错误（二义性）       | 见下例                                  |

##### 1.5.2.1 模糊匹配示例（编译错误）

```cpp
template <typename T>
struct Ambiguous {};

// 两个可能匹配的偏特化
template <typename T>
struct Ambiguous<T*> {};

template <typename T>
struct Ambiguous<T[]> {};

// 使用时可能产生二义性
// Ambiguous<int*[]> var; // 错误：两个偏特化都匹配
```

1.5.3 

#### 1.5.3 示例代码与详细说明

```cpp
#include <iostream>
#include <type_traits>

// 1. 主模板（最通用）
template <typename T>
struct TypeTrait {
    static const char* name() { 
        return "Generic type"; 
    }
};

// 2. 偏特化：指针类型
template <typename T>
struct TypeTrait<T*> {
    static const char* name() { 
        return "Pointer to something"; 
    }
};

// 3. 偏特化：所有容器类型（使用模板模板参数）
template <template <typename> class Container, typename T>
struct TypeTrait<Container<T>> {
    static const char* name() { 
        return "Container"; 
    }
};

// 4. 全特化：int类型
template <>
struct TypeTrait<int> {
    static const char* name() { 
        return "int"; 
    }
};

// 5. 全特化：int*类型
template <>
struct TypeTrait<int*> {
    static const char* name() { 
        return "Pointer to int (fully specialized)"; 
    }
};

// 6. 全特化：std::vector<int>类型
template <>
struct TypeTrait<std::vector<int>> {
    static const char* name() { 
        return "Vector of int (fully specialized)"; 
    }
};

// 测试用的简单容器
template <typename T>
struct MyContainer {
    T data;
};

int main() {
    // 测试不同类型的匹配
    std::cout << "TypeTrait<double>::name(): " 
              << TypeTrait<double>::name() << std::endl;
    // 输出: Generic type (匹配主模板)
    
    std::cout << "TypeTrait<int>::name(): " 
              << TypeTrait<int>::name() << std::endl;
    // 输出: int (匹配全特化，而不是主模板)
    
    std::cout << "TypeTrait<int*>::name(): " 
              << TypeTrait<int*>::name() << std::endl;
    // 输出: Pointer to int (fully specialized)
    // 注意：虽然有指针偏特化，但int*有更具体的全特化版本
    
    std::cout << "TypeTrait<double*>::name(): " 
              << TypeTrait<double*>::name() << std::endl;
    // 输出: Pointer to something (匹配指针偏特化)
    
    std::cout << "TypeTrait<std::vector<double>>::name(): " 
              << TypeTrait<std::vector<double>>::name() << std::endl;
    // 输出: Container (匹配容器偏特化)
    
    std::cout << "TypeTrait<std::vector<int>>::name(): " 
              << TypeTrait<std::vector<int>>::name() << std::endl;
    // 输出: Vector of int (fully specialized)
    // 注意：虽然有容器偏特化，但vector<int>有更具体的全特化版本
    
    std::cout << "TypeTrait<MyContainer<double>>::name(): " 
              << TypeTrait<MyContainer<double>>::name() << std::endl;
    // 输出: Container (匹配容器偏特化)
    
    return 0;
}
```

匹配过程解析

1. `TypeTrait<double>` 的匹配过程

1. 检查是否有 `TypeTrait<double>` 的全特化 → 无
2. 检查是否有匹配的偏特化（`double` 不是指针，也不是容器）→ 无
3. 匹配主模板 → ✅

2. `TypeTrait<int>` 的匹配过程

1. 检查是否有 `TypeTrait<int>` 的全特化 → ✅ 有！直接使用全特化版本
2. 不会继续检查偏特化或主模板

3. `TypeTrait<int*>` 的匹配过程

1. 检查是否有 `TypeTrait<int*>` 的全特化 → ✅ 有！直接使用全特化版本
2. 虽然有 `TypeTrait<T*>` 偏特化，但全特化更具体

4. `TypeTrait<double*>` 的匹配过程

1. 检查是否有 `TypeTrait<double*>` 的全特化 → 无
2. 检查偏特化 `TypeTrait<T*>` → ✅ 匹配！
3. 不会使用主模板



## 2. 进阶模板编程

### 2.1 模板特化与偏特化

#### 2.1.1 为什么需要特化？

模板提供通用实现，但特定类型可能需要：

1. **性能优化**（如指针类型的特殊处理）
2. **特殊行为**（如C字符串的格式化）
3. **边界情况处理**（如空指针处理）
4. **类型适配**（如自定义类型的格式化）

#### 2.1.2 模板特化（Template Specialization）

模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持**全特化（Full Specialization）**********和************偏特化（Partial Specialization）**，但需要注意的是，**函数模板不支持偏特化**，只能进行全特化。

##### 2.1.2.1 全特化（Full Specialization）

为特定类型提供完全不同的实现

```cpp
#include <format>
#include <iostream>
#include <vector>

// 主模板
template <typename T>
struct Formatter {
    static std::string format(const T& value) {
        return std::format("Value: {}", value);
    }
};

// 全特化：int类型
template <>
struct Formatter<int> {
    static std::string format(int value) {
        return std::format("INT: {0} (hex: {0:#x})", value);
    }
};

// 全特化：vector类型
template <typename T>
struct Formatter<std::vector<T>> {
    static std::string format(const std::vector<T>& vec) {
        std::string result = "Vector[";
        for (const auto& item : vec) {
            result += Formatter<T>::format(item) + ", ";
        }
        if (!vec.empty()) result.erase(result.end()-2, result.end());
        return result + "]";
    }
};
```

使用示例：

```cpp
int main() {
    std::cout << Formatter<double>::format(3.14) << "\n"; 
    // 输出: Value: 3.14
    
    std::cout << Formatter<int>::format(42) << "\n";      
    // 输出: INT: 42 (hex: 0x2a)
    
    std::vector<int> vec = {1, 2, 3};
    std::cout << Formatter<decltype(vec)>::format(vec) << "\n";
    // 输出: Vector[INT: 1 (hex: 0x1), INT: 2 (hex: 0x2), INT: 3 (hex: 0x3)]
}
```

##### 2.1.2.2 偏特化（Partial Specialization）

（**类模板特有，函数模板需用重载替代**），对模板参数的部分限制进行特化

```cpp
// 主模板：指针类型
template <typename T>
struct Formatter<T*> {
    static std::string format(T* ptr) {
        if (!ptr) return "Null pointer";
        return std::format("Pointer to: {}", Formatter<T>::format(*ptr));
    }
};

// 偏特化：对指针的指针
template <typename T>
struct Formatter<T**> {
    static std::string format(T** ptr) {
        if (!ptr || !*ptr) return "Null double pointer";
        return std::format("Double pointer to: {}", Formatter<T>::format(**ptr));
    }
};

// 偏特化：所有智能指针类型
template <template <typename> typename SmartPtr, typename T>
struct Formatter<SmartPtr<T>> {
    static std::string format(const SmartPtr<T>& ptr) {
        if (!ptr) return "Empty smart pointer";
        return std::format("SmartPtr: {}", Formatter<T>::format(*ptr));
    }
};
```

使用示例：

```cpp
#include <memory>

int main() {
    int x = 10;
    int* px = &x;
    int** ppx = &px;
    
    std::cout << Formatter<decltype(px)>::format(px) << "\n";
    // 输出: Pointer to: INT: 10 (hex: 0xa)
    
    std::cout << Formatter<decltype(ppx)>::format(ppx) << "\n";
    // 输出: Double pointer to: INT: 10 (hex: 0xa)
    
    auto sp = std::make_shared<double>(3.14);
    std::cout << Formatter<decltype(sp)>::format(sp) << "\n";
    // 输出: SmartPtr: Value: 3.14
}
```

#### 2.1.3 函数模板特化替代方案

##### 2.1.3.1 使用重载 + 约束（C++20）

```cpp
// 主模板
template <typename T>
std::string format_value(const T& value) {
    return std::format("Value: {}", value);
}

// 重载版本：C风格字符串
std::string format_value(const char* str) {
    return std::format("C-string: \"{}\"", str);
}

// 使用C++20约束的重载
template <typename T>
requires std::is_pointer_v<T>
std::string format_value(T ptr) {
    if (!ptr) return "Null pointer";
    return std::format("Pointer: {}", format_value(*ptr));
}
```

#### 2.1.4 特化机制解析

| 类型       | 特点                               | 适用场景                            |
| ---------- | ---------------------------------- | ----------------------------------- |
| **全特化** | 完全指定所有模板参数               | 特定类型的完全重写（如`vector<T>`） |
| **偏特化** | 部分指定模板参数（仅类模板）       | 类型类别处理（如所有指针类型）      |
| **重载**   | 函数模板替代方案（结合约束更强大） | 函数模板的特殊版本                  |

#### 2.1.5 总结

- **全特化**适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。
- **偏特化**仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。
- **函数模板**仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。
- **特化模板**提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。

### 2.2 变参模板

变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 `std::tuple`、`std::variant` 等模板库组件的基础。

#### 2.2.1 定义与语法

变参模板使用 **参数包（Parameter Pack）**，通过 `...` 语法来表示。

```cpp
template <typename... Args>
class MyClass { /* ... */ };

template <typename T, typename... Args>
void myFunction(T first, Args... args) { /* ... */ }
```

#### 2.2.2 递归与展开（Recursion and Expansion）

变参模板通常与递归相结合，通过递归地处理参数包，或者使用 **折叠表达式（Fold Expressions）** 来展开发参数包。

##### 2.2.2.1 递归

```cpp
#include <iostream>

// 基础情况：无参数
void printAll() {
    std::cout << std::endl;
}

// 递归情况：至少一个参数
template <typename T, typename... Args>
void printAll(const T& first, const Args&... args) {
    std::cout << first << " ";
    printAll(args...);
}

int main() {
    printAll(1, 2.5, "Hello", 'A'); // 输出：1 2.5 Hello A 
    return 0;
}
```

##### 2.2.2.2 折叠表达式版本

```cpp
#include <iostream>

// 使用折叠表达式的printAll
template <typename... Args>
void printAll(const Args&... args) {
    // 使用左折叠展开参数包，并在每个参数之后输出一个空格
    ((std::cout << args << " "), ...);
    std::cout << std::endl;
}

int main() {
    printAll(1, 2.5, "Hello", 'A'); // 输出：1 2.5 Hello A 
    return 0;
}
```

##### 2.2.2.3 折叠表达式示例：计算总和

```cpp
#include <iostream>

template <typename... Args>
auto sum(Args... args) -> decltype((args + ...)) {
    return (args + ...); 
}

int main() {
    std::cout << sum(1, 2, 3, 4) << std::endl; // 输出：10
    std::cout << sum(1.5, 2.5, 3.0) << std::endl; // 输出：7
    return 0;
}
```

##### 2.2.2.4 示例：日志记录器

```cpp
#include <iostream>
#include <string>

// 基础情况：无参数
void log(const std::string& msg) {
    std::cout << msg << std::endl;
}

// 递归情况：至少一个参数
template <typename T, typename... Args>
void log(const std::string& msg, const T& first, const Args&... args) {
    std::cout << msg << ": " << first << " ";
    log("", args...); // 递归调用，省略消息前缀
}

int main() {
    log("Error", 404, "Not Found");
    // 输出: Error: 404 Not Found 

    log("Sum", 10, 20, 30);
    // 输出: Sum: 10 20 30 
    return 0;
}
```

### 2.3 模板折叠（Fold Expressions）

#### 2.3.1 折叠表达式的概念与背景

在C++中，**可变参数模板**允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。

**折叠表达式**的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。

**折叠表达式**可分为：

- **一元折叠表达式（Unary Fold）**：对参数包中的每个参数应用一个一元操作符。
- **二元折叠表达式（Binary Fold）**：对参数包中的每个参数应用一个二元操作符。

此外，**二元折叠表达式**可进一步细分为**左折叠（Left Fold）**********和************右折叠（Right Fold）**，取决于操作符的结合方向。

#### 2.3.2 一元折叠表达式（Unary Fold）

**一元折叠表达式**用于在参数包的每个参数前或后应用一元操作符。语法形式如下：

**前置一元折叠（Unary Prefix Fold）**`(... + args)`（一元左折叠）

(op ... pack) 

对于调用 `unary_left_fold(1, 2, 3, 4)`，展开过程为：

```
((1 + 2) + 3) + 4
```

**后置一元折叠（Unary Postfix Fold）**`(args + ...)`（一元右折叠）

(pack ... op)

对于调用 `unary_right_fold(1, 2, 3, 4)`，展开过程为：

```
1 + (2 + (3 + 4))
```

其中，`op` 是一元操作符，如`!`（逻辑非）、`~`（按位取反）等。

**示例1：逻辑非操作**

```cpp
#include <iostream>

//对每个参数非操作，然后再将这些操作&&
//(!args && ...) 相当于 !a && !b && ...
template<typename... Args>
bool allNot(const Args&... args){
    return (!args && ...);
}
```

#### 2.3.3 二元折叠表达式（Binary Fold）

**二元折叠表达式**用于在参数包的每个参数之间应用一个二元操作符。它们可以分为**二元左折叠（Binary Left Fold）**********和************二元右折叠（Binary Right Fold）**，取决于操作符的结合方向。

**二元折叠表达式语法**

**二元左折叠（Left Fold） `(init + ... + args)`**：

- (init op ... op pack)

或者简化为：

- (pack1 op ... op packN)

对于调用 `binary_left_fold(10, 1, 2, 3, 4)`，展开过程为：

```
(((10 + 1) + 2) + 3) + 4
```



**二元右折叠（Right Fold）**`(args + ... + init)`：

- (pack1 op ... op init op ...)

或者简化为：

- (pack1 op ... op packN)

对于调用 `binary_right_fold(10, 1, 2, 3, 4)`，展开过程为：

```
1 + (2 + (3 + (4 + 10)))
```



其中，`op` 是二元操作符，如`+`、`*`、`&&`、`||`、`<<` 等。

**左折叠与右折叠的区别**

- **二元左折叠（Binary Left Fold）**：操作符从左至右结合，等价于 `(((a op b) op c) op d)`。
- **二元右折叠（Binary Right Fold）**：操作符从右至左结合，等价于 `(a op (b op (c op d)))`。

**示例1：求和（Binary Left Fold）**

```cpp
#include <iostream>

// 二元左折叠：((arg1 + arg2) + arg3) + ... + argN
template<typename... Args>
auto sumLeftFold(const Args&... args) {
    return (args + ...); // 左折叠
}

int main() {
    std::cout << sumLeftFold(1, 2, 3, 4) << std::endl; // 输出：10
    return 0;
}
```

**解释**：

- `**(args + ...)**` 是一个二元左折叠表达式。
- 它将`+`操作符逐个应用于参数，按照左折叠顺序。
- 即，`((1 + 2) + 3) + 4 = 10`。

**示例2：乘积（Binary Right Fold）**

```cpp
#include <iostream>

// 二元右折叠：arg1 * (arg2 * (arg3 * ... * argN))
template<typename... Args>
auto productRightFold(const Args&... args) {
    return (... * args); // 右折叠
}

int main() {
    std::cout << productRightFold(2, 3, 4) << std::endl; // 输出：24
    return 0;
}
```

**解释**：

- `**(... \* args)**` 是一个二元右折叠表达式。
- 它将`*`操作符逐个应用于参数，按照右折叠顺序。
- 即，`2 * (3 * 4) = 2 * 12 = 24`。

**示例3：逻辑与（Binary Left Fold）**

```cpp
#include <iostream>

template<typename... Args>
bool allTrue(const Args&... args) {
    return (args && ...); // 左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << allTrue(true, true, false) << std::endl; // 输出：false
    std::cout << allTrue(true, true, true) << std::endl;  // 输出：true
    return 0;
}
```

**解释**：

- `**(args && ...)**` 是一个二元左折叠表达式。
- 用于检查所有参数是否为`true`。
- 类似于链式的逻辑与运算。

#### 2.3.4 左折叠与右折叠（Left and Right Folds）

了解**左折叠**和**右折叠**的区别，对于正确选择折叠表达式的形式至关重要。

**二元左折叠（Binary Left Fold）**

**语法**：

- (args op ...)

**展开方式**：

- ((arg1 op arg2) op arg3) op ... op argN
- **适用场景**：

- - 当操作符是结合性的且从左侧开始累积操作时（如`+`、`*`）。
  - 需要严格的顺序执行时，确保从左到右依次处理参数。

**示例**：

- (args + ...) // 左折叠求和

**二元右折叠（Binary Right Fold）**

**语法**：

- (... op args)

**展开方式**：

- arg1 op (arg2 op (arg3 op ... op argN))
- **适用场景**：

- - 当操作符是右结合的，或当需要从右侧开始累积操作时。
  - 某些特定的逻辑和数据结构可能需要右侧先处理。

**示例**：

- (... + args) // 右折叠求和

**嵌套折叠表达式**

在某些复杂场景下，可能需要嵌套使用左折叠和右折叠，以达到特定的操作顺序。例如，结合多个不同的操作符。

```cpp
#include <iostream>

template<typename... Args>
auto complexFold(const Args&... args) {
    // 先左折叠求和，然后右折叠求乘积
    return (args + ...) * (... + args);
}

int main() {
    std::cout << complexFold(1, 2, 3) << std::endl; // (1+2+3) * (1+2+3) = 6 * 6 = 36
    return 0;
}
```

**解释**：

- 在此示例中，我们首先对参数进行左折叠求和，然后对参数进行右折叠求和，最后将两者相乘。
- 这种嵌套用途展示了折叠表达式的灵活性。

#### 2.3.5 `op` 在折叠表达式中的作用

在折叠表达式中，`op` 代表**二元操作符**，用于定义如何将参数包中的各个参数相互结合。`op` 可以是任何合法的二元操作符，包括但不限于：

- **算术操作符**：`+`、`-`、`*`、`/`、`%` 等。
- **逻辑操作符**：`&&`、`||` 等。
- **按位操作符**：`&`、`|`、`^`、`<<`、`>>` 等。
- **比较操作符**：`==`、`!=`、`<`、`>`、`<=`、`>=` 等。
- **自定义操作符**：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。

`**op**` **的选择直接影响折叠表达式的行为和结果**。选择适当的操作符是实现特定功能的关键。

**示例1：使用加法操作符**

```cpp
#include <iostream>

template<typename... Args>
auto addAll(const Args&... args) {
    return (args + ...); // 使用 '+' 进行左折叠
}

int main() {
    std::cout << addAll(1, 2, 3, 4) << std::endl; // 输出：10
    return 0;
}
```

**示例2：使用逻辑与操作符**

```cpp
#include <iostream>

template<typename... Args>
bool allTrue(const Args&... args) {
    return (args && ...); // 使用 '&&' 进行左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << allTrue(true, true, false) << std::endl; // 输出：false
    std::cout << allTrue(true, true, true) << std::endl;  // 输出：true
    return 0;
}
```

**示例3：使用左移操作符（流插入）**

```cpp
#include <iostream>

template<typename... Args>
void printAll(const Args&... args) {
    (std::cout << ... << args) << std::endl; // 使用 '<<' 进行左折叠
}

int main() {
    printAll("Hello, ", "world", "!", 123); // 输出：Hello, world!123
    return 0;
}
```

**解释**：

- 在上述示例中，`op` 分别为 `+`、`&&`、`<<`。
- 每个操作符定义了如何将参数包中的元素相互结合。

**示例4：使用自定义操作符**

假设有一个自定义类型`Point`，并重载了`+`操作符以支持点的相加。

```cpp
#include <iostream>

struct Point {
int x, y;

// 重载 '+' 操作符
Point operator+(const Point& other) const {
    return Point{ x + other.x, y + other.y };
}
};

// 二元左折叠：((p1 + p2) + p3) + ... + pN
template<typename... Args>
Point sumPoints(const Args&... args) {
    return (args + ...); // 使用 '+' 进行左折叠
}

int main() {
    Point p1{1, 2}, p2{3, 4}, p3{5, 6};
    Point result = sumPoints(p1, p2, p3);
    std::cout << "Sum of Points: (" << result.x << ", " << result.y << ")\n"; // 输出：(9, 12)
    return 0;
}
```

**解释**：

- 通过重载`+`操作符，`sumPoints`函数能够将多个`Point`对象相加，得到累积的结果。

#### 2.3.6 逗号运算符在参数包展开中的详细解析

## 2.3 模板折叠（Fold Expressions）

#### 2.3.6 逗号运算符在参数包展开中的详细解析

在C++模板编程中，逗号运算符在参数包展开中扮演着重要角色，特别是在C++11/14中处理可变参数模板时。本节将详细解析逗号运算符的工作原理、应用场景以及现代C++中的优化方案。

##### 2.3.6.1 逗号运算符的基本行为

在C++中，逗号运算符`,`具有以下特性：

1. **按从左到右的顺序计算每个操作数**
2. **返回最右侧操作数的值**
3. **整个表达式的类型是最右侧操作数的类型**

例如：`int x = (1, 2, 3);` 中，`x` 的值是 3。

##### 2.3.6.2 参数包展开中的逗号运算符

在C++11/14中，逗号运算符常用于参数包展开，特别是在初始化列表中。

###### 2.3.6.2.1 原始代码分析

```cpp
template<typename Func, typename... Args>
auto all_of(Func f, Args...args) {
    int _[] = { (0, f(args))... };
    return sizeof...(args) == std::accumulate(std::begin(_), std::end(_), 0);
}
```

###### 2.3.6.2.2 执行逻辑顺序

对于调用 `all_of([](int v) -> bool { return v % 2 == 0; }, 1, 2, 3, 4)`：

1. 参数包展开：

   ```cpp
   int _[] = {
       (0, f(1)),  // 第一步：计算0（无效果）
                   // 第二步：计算f(1)→返回false(0)
                   // 第三步：返回f(1)的结果→0
       (0, f(2)),  // 第一步：计算0（无效果）
                   // 第二步：计算f(2)→返回true(1)
                   // 第三步：返回f(2)的结果→1
       (0, f(3)),  // 返回f(3)的结果→0
       (0, f(4))   // 返回f(4)的结果→1
   };
   ```

2. 数组初始化：

   ```cpp
   int _[] = {0, 1, 0, 1};
   ```

3. 累加计算：

   ```cpp
   std::accumulate(std::begin(_), std::end(_), 0) → 0 + 1 + 0 + 1 = 2
   ```

4. 比较结果：

   ```cpp
   return 4 == 2; // 返回false
   ```

###### 2.3.6.2.3 为什么需要添加0？

1. **确保类型一致性**：
   - 如果函数`f`返回`void`，直接使用`f(args)...`会导致编译错误
   - `(0, f(args))`确保表达式始终有一个非void的返回值

2. **处理边界情况**：
   - 避免某些运算符优先级问题
   - 提供一种通用的参数包展开模式

3. **历史原因**：
   - 在C++11/14中，这是处理参数包展开的常见习惯用法

###### 2.3.6.2.4 顺序调整的影响

如果改为`(f(args), 0)...`：

```cpp
int _[] = { (f(args), 0)... };
```

执行逻辑变为：

1. 先计算`f(args)`（调用函数）
2. 然后计算`0`
3. 返回`0`的值

因此数组会被初始化为全0：`{0, 0, 0, 0}`，完全丢失了函数调用的结果。

##### 2.3.6.3 使用`std::index_sequence`编译时整数序列（C++14）和逗号运算符

在C++14中，类模板 `std::integer_sequence` 表示一个编译时整数序列。在此基础上有一些辅助工具：

- `std::make_integer_sequence<T, N>` - 创建一个类型为 `T` 的 `0, ..., N - 1` 序列。
- `std::index_sequence_for<T...>` - 将模板参数包转换为整数序列。

`std::index_sequence`与逗号运算符结合使用，可以创建编译时整数序列并用于参数包展开。

###### 2.3.6.3.1 创建重复值的数组

```cpp
#include <array>
#include <utility>

template <typename T, std::size_t N, std::size_t... Is>
constexpr auto make_array_impl(T&& value, std::index_sequence<Is...>) {
    // remove cvref from T
    // 逗号运算符：返回最后一个表达式的结果（std::forward<T>(value)）
    return std::array<std::decay_t<T>, N>{ (static_cast<void>(Is), std::forward<T>(value))... };
    /*
     return std::array<std::decay_t<T>, N>{ 
        (void)Is...,  // 展开并丢弃所有Is
        std::forward<T>(value)  // 最后一个值用作初始化
    };
    // like this:
    return std::array<int, 3>{
        (static_cast<void>(0), std::forward<T>(value)), // 类似宏的"挤兑"
        (static_cast<void>(1), std::forward<T>(value)),
        (static_cast<void>(2), std::forward<T>(value))
    };
    */
}

template <typename T, std::size_t N>
[[nodiscard]] constexpr auto make_array(T&& value) {
    return make_array_impl<T, N>(std::forward<T>(value), std::make_index_sequence<N>());
}

int main() {
    auto arr = make_array<int, 5>(42);
    // arr 包含 {42, 42, 42, 42, 42}
}
```

##### 2.3.6.4 C++17折叠表达式优化

C++17引入的折叠表达式可以大大简化这类代码，使得逗号运算符的技巧在许多场景下不再必要。

###### 2.3.6.4.1 使用逻辑与折叠表达式

```cpp
template<typename Func, typename... Args>
bool all_of(Func f, Args... args) {
    return (f(args) && ...);
}
```

###### 2.3.6.4.2 执行过程

对于相同的调用：

```cpp
all_of([](int v) -> bool { return v % 2 == 0; }, 1, 2, 3, 4)
```

折叠表达式展开为：

```cpp
return f(1) && f(2) && f(3) && f(4);
```

执行流程：

1. 计算`f(1)`→返回`false`
2. 由于逻辑与的短路特性，直接返回`false`，不再计算后续表达式

优势

1. **代码简洁**：一行代码替代了原来的多行实现
2. **性能优化**：利用短路求值，遇到第一个`false`就立即返回
3. **类型安全**：不需要中间数组，直接处理布尔结果
4. **可读性高**：意图更加明确，易于理解

##### 2.3.6.5 其他折叠表达式应用

###### 2.3.6.5.1 使用逗号运算符折叠

```cpp
template<typename Func, typename... Args>
void for_each(Func f, Args... args) {
    (f(args), ...);
}
```

这个实现会对每个参数调用函数`f`，忽略返回值，类似于原始代码但更加简洁。

###### 2.3.6.5.2 复杂条件检查

```cpp
template<typename... Conditions>
bool complex_condition(Conditions... conds) {
    return (conds() && ...);
}
```

可以用于检查多个复杂条件，每个条件通过函数调用获取。

#### 2.3.7 示例代码与应用

为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。

##### **示例1：字符串拼接**

```cpp
#include <iostream>
#include <string>

template<typename... Args>
std::string concatenate(const Args&... args) {
    return (std::string{} + ... + args); // 左折叠
    //左折叠展开为((std::string{} + "A") + "B") + "C"
    //return (args + ... + std::string{});右折叠
    //右折叠展开为"A" + ("B" + ("C" + std::string{}))
    // 两种写法输出一样，过程不一样
}

int main() {
    std::string result = concatenate("Hello, ", "world", "!", " Have a nice day.");
    std::cout << result << std::endl; // 输出：Hello, world! Have a nice day.
    return 0;
}
```

##### **示例2：计算逻辑与**

```cpp
#include <iostream>

template<typename... Args>
bool areAllTrue(const Args&... args) {
    return (args && ...); // 左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << areAllTrue(true, true, true) << std::endl;   // 输出：true
    std::cout << areAllTrue(true, false, true) << std::endl;  // 输出：false
    return 0;
}
```

##### **示例3：计算最大值**

```cpp
#include <iostream>
#include <algorithm>

template<typename T, typename... Args>
T maxAll(T first, Args... args) {
    return (std::max)(first, ... , args); // 左折叠
}

int main() {
    std::cout << maxAll(1, 5, 3, 9, 2) << std::endl; // 输出：9
    return 0;
}
```

**注意**：上述示例中的`(std::max)(first, ... , args)`是一个非标准用法，需要根据具体情况调整。通常，`std::max`不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用`std::initializer_list`或其他方法实现多参数的最大值计算。

##### **示例4：筛选逻辑**

假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作：

```cpp
#include <iostream>

template<typename... Args>
bool anyTrue(const Args&... args) {
    return (args || ...); // 左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << anyTrue(false, false, true) << std::endl; // 输出：true
    std::cout << anyTrue(false, false, false) << std::endl; // 输出：false
    return 0;
}
```

##### 示例5：值捕获参数包

```cpp
#include <iostream>
#include <functional>

template<typename Func, typename... Args>
auto delay_invoke(Func f, Args... args) {
    // 值捕获所有参数
    return [f, args...]() -> decltype(auto) {
        return std::invoke(f, args...);
    };
}

int main() {
    auto add = [](int a, int b) { return a + b; };
    auto delayed_add = delay_invoke(add, 10, 20);
    std::cout << delayed_add() << std::endl; // 输出: 30
    return 0;
}
```

##### 示例6：使用移动语义和元组

```cpp
#include <iostream>
#include <tuple>
#include <functional>

template<typename Func, typename... Args>
auto delay_invoke(Func f, Args... args) {
    // 使用移动语义，将参数存储在元组中
    return [f = std::move(f), tup = std::make_tuple(std::move(args)...)]() -> decltype(auto) {
        return std::apply(f, tup);
    };
}

int main() {
    auto concat = [](std::string a, std::string b, std::string c) {
        return a + b + c;
    };
    
    std::string s1 = "Hello, ";
    std::string s2 = "world";
    std::string s3 = "!";
    
    auto delayed_concat = delay_invoke(concat, s1, s2, s3);
    std::cout << delayed_concat() << std::endl; // 输出: Hello, world!
    
    // 原始字符串已移动，不能再使用
    // std::cout << s1 << std::endl; // 可能为空
    return 0;
}
```

##### 示例7：C++20简化写法（包展开捕获）

```cpp
#include <iostream>
#include <functional>

template<typename Func, typename... Args>
auto delay_invoke(Func f, Args... args) {
    // C++20起支持包展开捕获
    return [f = std::move(f), ...args = std::move(args)]() -> decltype(auto) {
        return std::invoke(f, args...);
    };
}

int main() {
    auto multiply = [](double a, double b, double c) { return a * b * c; };
    auto delayed_multiply = delay_invoke(multiply, 2.5, 3.0, 4.0);
    std::cout << delayed_multiply() << std::endl; // 输出: 30
    return 0;
}
```

##### 示例8：将数组转换为元组（`index_sequence`）

```cpp
#include <array>
#include <tuple>
#include <utility>

template<typename Array, std::size_t... I>
decltype(auto) a2t_impl(const Array& a, std::index_sequence<I...>) {
    // 使用索引序列展开数组元素
    return std::make_tuple(a[I]...);
}

template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
decltype(auto) a2t(const std::array<T, N>& a) {
    return a2t_impl(a, Indices());
}

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    auto tup = a2t(arr);
    
    // 验证元组内容
    static_assert(std::tuple_size<decltype(tup)>::value == 5);
    std::cout << std::get<0>(tup) << std::endl; // 输出: 1
    std::cout << std::get<4>(tup) << std::endl; // 输出: 5
    
    return 0;
}
```

##### 示例9：多种打印函数的实现

```cpp
#include <iostream>
#include <tuple>
#include <utility>
#include <format>
#include <string_view>
#include <numbers>

// 方法1: 使用折叠表达式（C++17）
auto print1 = []<typename...Args>(Args&&...args1) -> void {
    // 捕获引用，使用折叠表达式打印
    [&/*可以写成 "&...args2 = std::forward<Args>(args1)"*/]() {
        (std::cout << ... << args1) << " ";
    }();
    std::cout << std::endl;
};

// 方法2: 使用索引序列
auto print2 = [](auto&&...args) -> void {
    // 使用lambda模板和索引序列
    [&] <std::size_t...idx>(std::index_sequence<idx...>) {
        // 使用折叠表达式和std::get
        (..., (std::cout << std::get<idx>(std::forward_as_tuple(args...)) << " "));
    }(std::make_index_sequence<sizeof...(args)>{});
    std::cout << std::endl;
};

// 方法3: 使用初始化列表（要求所有参数类型一致）
auto print3 = [] <typename... Args>(Args&&... args) {
    // 创建初始化列表，要求所有元素类型相同
    for (auto arg : { args... }) {
        std::cout << arg << " ";
    }
    std::cout << std::endl;
};

// 方法4: 打印元组（已知类型）
auto print4 = []<typename... Args>(const std::tuple<Args...>& _Tuple) {
    constexpr std::size_t N = sizeof...(Args);
    // 使用索引序列遍历元组
    [&] <size_t... I>(std::index_sequence<I...>) {
        // 使用折叠表达式，最后一个元素不加空格
        (..., (std::cout << std::get<I>(_Tuple) << (I != N - 1 ? " " : "")));
    }(std::make_index_sequence<N>());
    std::cout << std::endl;
};

// 方法5: 打印任意元组
auto print5 = [](const auto& _Tuple) {
    // 移除CV引用限定符，计算元组大小
    constexpr std::size_t N = std::tuple_size_v<std::remove_cvref_t<decltype(_Tuple)>>;
    [&] <size_t... I>(std::index_sequence<I...>) {
        (..., (std::cout << std::get<I>(_Tuple) << (I != N - 1 ? " " : "")));
    }(std::make_index_sequence<N>());
    std::cout << std::endl;
};

// 方法6: 使用C++20 format
auto print6 = []<typename...Args>(const std::string_view fmt_str, Args&&... args) {
    auto fmt_args{ std::make_format_args(std::forward<Args>(args)...) };
    std::string outstr{ std::vformat(fmt_str, fmt_args) };
    std::cout << outstr;
};

int main() {
    print1("1", "2", 3);                    // 输出: 1 2 3
    print2("1", "2", 3);                    // 输出: 1 2 3
    print3("1", "2", "3");                  // 输出: 1 2 3 (类型必须一致)
    print4(std::make_tuple("1", "2", 3));   // 输出: 1 2 3
    print5(std::tuple{ "1", "2", 3 });      // 输出: 1 2 3
    print6("PI: {:.6f}\n", std::numbers::pi); // 输出: PI: 3.141593
    return 0;
}
```

##### 示例10：初始化列表求和

```cpp
#include <iostream>
#include <numeric>
#include <type_traits>

// 求和函数1: 对多个初始化列表求和
auto sum_n1 = []<typename std::size_t...Ns, typename T>(T(&&... values)[Ns]) {
    // 将多个初始化列表整合为一个，计算每个列表的和
    auto _ = { std::accumulate(std::begin(values), std::end(values), 0)... };
    // 对所有列表的和再求和
    return std::accumulate(_.begin(), _.end(), 0);
};

// 求和函数2: 对多个参数求和（consteval编译时计算）
auto sum_n2 = []<typename...Args>(Args&&...args) consteval {
    // 找到所有参数的公共类型
    using T = std::common_type_t<Args...>;
    // 创建初始化列表，统一类型
    auto _ = { static_cast<T>(args)... };
    // 计算总和
    return std::accumulate(std::begin(_), std::end(_), T{});
};

int main() {
    // 测试sum_n1
    int result1 = sum_n1({1, 2, 3}, {5, 6});
    std::cout << "sum_n1({1,2,3}, {5,6}) = " << result1 << std::endl; // 输出: 17
    
    // 测试sum_n2（编译时计算）
    constexpr auto result2 = sum_n2(1, 2, 3.5f, 5, 6);
    static_assert(std::is_same_v<decltype(result2), const float>);
    std::cout << "sum_n2(1, 2, 3.5, 5, 6) = " << result2 << std::endl; // 输出: 17.5
    
    return 0;
}
```



#### 2.3.8 注意事项与最佳实践

> 1. **结合律与折叠方向**：
>    - 对于满足结合律的运算符（如加法、乘法），一元左折叠和一元右折叠的结果相同
>    - 对于不满足结合律的运算符（如减法、除法），不同折叠方式会产生不同结果
>
> 2. **空参数包的处理**：
>    - 一元折叠要求参数包至少包含一个参数（空参数包会导致编译错误）
>    - 二元折叠可以处理空参数包，此时表达式的结果就是初始值
>
> 3. **类型一致性**：
>    - 使用初始化列表时，所有元素必须具有相同类型或可转换为相同类型
>    - 对于混合类型，使用`std::common_type_t`获取公共类型
>
> 4. **性能考虑**：
>    - 折叠表达式在编译时展开，运行时无额外开销
>    - 初始化列表可能涉及拷贝，对于大对象需谨慎使用
>
> 5. **现代C++特性**：
>    - C++17折叠表达式大大简化了参数包处理
>    - C++20概念和约束提供了更好的类型安全
>    - C++20包展开捕获简化了lambda表达式的参数捕获

**1. 操作符的选择**

选择合适的操作符（`op`）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。

**2. 操作符的结合性**

不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。

**3. 参数包的初始化**

在二元折叠表达式中，有时需要一个初始值（`init`）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。

**示例**：

```cpp
#include <iostream>
#include <numeric>

template<typename... Args>
auto sumWithInit(int init, Args... args) {
    return (init + ... + args); // 左折叠
}

int main() {
    std::cout << sumWithInit(10, 1, 2, 3) << std::endl; // 输出：16 (10 + 1 + 2 + 3)
    return 0;
}
```

**4. 参数包为空的情况**

如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。

**示例**：

```cpp
#include <iostream>

// 求和函数，如果参数包为空返回0
template<typename... Args>
auto sum(Args... args) {
    return (0 + ... + args); // 左折叠，初始值为0
}

int main() {
    std::cout << sum(1, 2, 3) << std::endl; // 输出：6
    std::cout << sum() << std::endl;        // 输出：0
    return 0;
}
```

**5. 与递归模板的比较**

折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。

**6. 编译器支持**

确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括：

- **GCC**：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。
- **Clang**：从版本5开始支持C++17。
- **MSVC（Visual Studio）**：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。

**7. 性能考虑**

折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。

#### 2.3.9 总结示例使用代码

```c++
#include <iostream>
#include <string>
#include <vector>

// 一元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename... Args>
auto unary_left_fold(Args... args) {
    return (... + args); // 展开为 ((arg1 + arg2) + ...) + argN
}

// 一元右折叠：(arg1 op (arg2 op (... op argN)))
template<typename... Args>
auto unary_right_fold(Args... args) {
    return (args + ...); // 展开为 arg1 + (arg2 + (... + argN))
}

// 二元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename Init, typename... Args>
auto binary_left_fold(Init init, Args... args) {
    return (init + ... + args); // 展开为 (((init + arg1) + arg2) + ...) + argN
}

// 二元右折叠：(arg1 op (arg2 op (... op (argN op init))))
template<typename Init, typename... Args>
auto binary_right_fold(Init init, Args... args) {
    return (args + ... + init); // 展开为 arg1 + (arg2 + (... + (argN + init)))
}

// 打印参数包内容的辅助函数
template<typename T>
void print_arg(T arg) {
    std::cout << arg << " ";
}

template<typename... Args>
void print_all(Args... args) {
    (print_arg(args), ...); // 使用逗号运算符的一元右折叠
    std::cout << std::endl;
}

int main() {
    std::cout << "=== 折叠表达式示例 ===" << std::endl;
    
    // 一元左折叠
    std::cout << "一元左折叠 (1+2+3+4): " << unary_left_fold(1, 2, 3, 4) << std::endl;
    
    // 一元右折叠
    std::cout << "一元右折叠 (1+2+3+4): " << unary_right_fold(1, 2, 3, 4) << std::endl;
    
    // 二元左折叠
    std::cout << "二元左折叠 (10+1+2+3+4): " << binary_left_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 二元右折叠
    std::cout << "二元右折叠 (1+2+3+4+10): " << binary_right_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 使用折叠表达式打印所有参数
    std::cout << "打印所有参数: ";
    print_all(1, 2.5, "Hello", 'A');
    
    // 对于加法，左右折叠结果相同（加法满足结合律）
    std::cout << "\n=== 减法示例（展示结合顺序的区别）===" << std::endl;
    
    // 一元左折叠减法：(((10-1)-2)-3)
    auto left_sub = [](auto... args) { return (args - ...); };
    std::cout << "一元左折叠减法 (10-1-2-3): " << left_sub(10, 1, 2, 3) << std::endl;
    
    // 一元右折叠减法：(10-(1-(2-3)))
    auto right_sub = [](auto... args) { return (... - args); };
    std::cout << "一元右折叠减法 (10-1-2-3): " << right_sub(10, 1, 2, 3) << std::endl;
    
    // 二元左折叠减法：((((100-10)-1)-2)-3)
    std::cout << "二元左折叠减法 (100-10-1-2-3): " << binary_left_fold(100, 10, 1, 2, 3) << std::endl;
    
    // 二元右折叠减法：(10-(1-(2-(3-100))))
    std::cout << "二元右折叠减法 (10-1-2-3-100): " << binary_right_fold(100, 10, 1, 2, 3) << std::endl;
    
    return 0;
}
```



## 3. SFINAE（Substitution Failure Is Not An Error）

### 3.1 什么是SFINAE？

**SFINAE** 是 "Substitution Failure Is Not An Error"（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。

### 3.2 SFINAE的工作原理

在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。

### 3.3 SFINAE的应用场景

1. **函数重载选择**：根据参数类型的不同选择不同的函数实现。
2. **类型特性检测**：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。
3. **条件编译**：根据模板参数的特性决定是否编译某些代码段。

### 3.4 SFINAE的基本用法

SFINAE通常与`std::enable_if`、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。

#### 3.4.1 示例一：通过`std::enable_if`实现函数重载

```cpp
#include <type_traits>
#include <iostream>

// 适用于整数类型
template <typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print_type(T value) {
    std::cout << "Integral type: " << value << std::endl;
}

// 适用于浮点类型
template <typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type
print_type(T value) {
    std::cout << "Floating point type: " << value << std::endl;
}

int main() {
    print_type(10);      // 输出: Integral type: 10
    print_type(3.14);    // 输出: Floating point type: 3.14
    // print_type("Hello"); // 编译错误，没有匹配的函数
    return 0;
}
```

**解释**：

- `std::enable_if` 根据条件 `std::is_integral<T>::value` 或 `std::is_floating_point<T>::value` 决定是否启用对应的函数模板。
- 当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。

#### 3.4.2 示例二：检测类型是否具有特定成员

假设我们需要实现一个函数，仅当类型 `T` 具有成员函数 `foo` 时才启用该函数。

```cpp
#include <type_traits>
#include <iostream>

// 辅助类型，检测是否存在成员函数 foo
template <typename T>
class has_foo {
private:
typedef char yes[1];
typedef char no[2];

template <typename U, void (U::*)()>
struct SFINAE {};

template <typename U>
static yes& test(SFINAE<U, &U::foo>*);

template <typename U>
static no& test(...);

public:
static constexpr bool value = sizeof(test<T>(0)) == sizeof(yes);
};

// 函数仅在 T 有 foo() 成员时启用
template <typename T>
typename std::enable_if<has_foo<T>::value, void>::type
call_foo(T& obj) {
    obj.foo();
    std::cout << "foo() called." << std::endl;
}

class WithFoo {
public:
void foo() { std::cout << "WithFoo::foo()" << std::endl; }
};

class WithoutFoo {};

int main() {
    WithFoo wf;
    call_foo(wf); // 输出: WithFoo::foo() \n foo() called.

    // WithoutFoo wf2;
    // call_foo(wf2); // 编译错误，没有匹配的函数
    return 0;
}
```

**解释**：

- `has_foo` 是一个类型萃取类，用于检测类型 `T` 是否具有成员函数 `foo`。
- `call_foo` 函数模板仅在 `T` 具有 `foo` 成员时启用。
- 对于不具有 `foo` 成员的类型，编译器会忽略 `call_foo`，从而避免编译错误。

#### 3.4.3 示例三：通过模板特化实现不同的行为

以下是完整的、正确实现 `TypePrinter` 的代码示例：

```cpp
#include <type_traits>
#include <iostream>

// 1. 定义一个 Trait 用于检测 T 是否有非 void 的 `value_type`
template <typename T, typename = void>
struct has_non_void_value_type : std::false_type {};

// 仅当 T 有 `value_type` 且 `value_type` 不是 void 时，特化为 std::true_type
template <typename T>
struct has_non_void_value_type<T, std::enable_if_t<!std::is_void_v<typename T::value_type>>> : std::true_type {};

// 2. 定义 TypePrinter 主模板，使用一个布尔参数控制特化
template <typename T, bool HasValueType = has_non_void_value_type<T>::value>
struct TypePrinter;

// 3. 特化：当 HasValueType 为 true 时，表示 T 有非 void 的 `value_type`
template <typename T>
struct TypePrinter<T, true> {
    static void print(){
        std::cout << "T has a member type 'value_type'." << std::endl;
    }
};

// 特化：当 HasValueType 为 false 时，表示 T 没有 `value_type` 或 `value_type` 是 void
template <typename T>
struct TypePrinter<T, false> {
    static void print(){
        std::cout << "hello world! T does not have a member type 'value_type'." << std::endl;
    }
};

// 测试结构体
struct WithValueType{
    using value_type = int;
};

struct WithoutValueType{};

struct WithVoidValueType{
    using value_type = void;
};

int main() {
    TypePrinter<WithValueType>::print();        // 输出: T has a member type 'value_type'.
    TypePrinter<WithoutValueType>::print();     // 输出: hello world! T does not have a member type 'value_type'.
    TypePrinter<WithVoidValueType>::print();    // 输出: hello world! T does not have a member type 'value_type'.
    return 0;
}
```

**代码解释**

1. **Trait** `has_non_void_value_type`:
   - **主模板**：默认情况下，`has_non_void_value_type<T>` 继承自 `std::false_type`，表示 `T` 没有 `value_type` 或 `value_type` 是 `void`。
   - **特化模板**：仅当 `T` 有 `value_type` 且 `value_type` 不是 `void` 时，`has_non_void_value_type<T>` 继承自 `std::true_type`。

2. `TypePrinter` **模板**:
   - **主模板**：接受一个类型 `T` 和一个布尔模板参数 `HasValueType`，默认为 `has_non_void_value_type<T>::value`。
   - **特化版本** `TypePrinter<T, true>`：当 `HasValueType` 为 `true` 时，表示 `T` 有非 `void` 的 `value_type`，提供相应的 `print` 实现。
   - **特化版本** `TypePrinter<T, false>`：当 `HasValueType` 为 `false` 时，表示 `T` 没有 `value_type` 或 `value_type` 是 `void`，提供默认的 `print` 实现。

3. **测试结构体**：
   - `WithValueType`：有一个非 `void` 的 `value_type`。
   - `WithoutValueType`：没有 `value_type`。
   - `WithVoidValueType`：有一个 `value_type`，但它是 `void`。

4. `main` **函数**：
   - 分别测试了三种情况，验证 `TypePrinter` 的行为是否符合预期。

### 3.5 SFINAE的两种常见写法

在SFINAE实践中，有两种常见的写法：`typename = std::enable_if_t<...>`和`std::enable_if_t<..., int> = 0`。这两种写法都是使用SFINAE的常见方式，但它们有一些关键区别。

#### 3.5.1 语法区别

##### 3.5.1.1 第一种：使用类型参数默认值

```cpp
template <typename U, typename = std::enable_if_t<is_compatible_v<U>>>
```

- 第二个参数是类型参数
- 给它一个默认类型（`std::enable_if_t<...>`）
- 当条件为`false`时，`std::enable_if_t`没有`type`成员，导致替换失败
- 参数名通常省略，因为它只是用于SFINAE

##### 3.5.1.2 第二种：使用非类型参数

```cpp
template <typename U, std::enable_if_t<is_compatible_v<U>> = 0>
```

- 第二个参数是非类型参数
- 类型是`std::enable_if_t<...>`
- 默认值是`0`
- 当条件为`false`时，替换失败

#### 3.5.2 为什么可以这样写？

##### 3.5.2.1 `typename = std::enable_if_t<...>`

- `typename`声明一个类型模板参数
- `=`给这个参数提供默认值
- 当`std::enable_if_t<condition>`有效时，它产生一个类型（默认是`void`）
- 示例：

```cpp
// 当 is_compatible_v<U> 为 true 时
template <typename U, typename = void>
// 当为 false 时，std::enable_if_t 无效，触发 SFINAE
```

##### 3.5.2.2 `std::enable_if_t<...> = 0`

- 这里定义了一个非类型模板参数
- 参数类型是`std::enable_if_t<condition>`
- `= 0`给这个参数默认值
- **关键**：`std::enable_if_t<true>`产生`void`，但`void = 0`是无效的！
- 实际上，这通常写成：

```cpp
template <typename U, std::enable_if_t<is_compatible_v<U>, int> = 0>
// 或者
template <typename U, std::enable_if_t<is_compatible_v<U>, bool> = true>
```

#### 3.5.3 为什么赋值`0`？

赋值`0`（或其他值）的原因：

- 非类型模板参数必须有默认值（如果你希望它是可选的）
- 对于整数类型（如`int`、`std::size_t`），`0`是常见的默认值
- 对于布尔类型，常用`true`或`false`

#### 3.5.4 正确用法示例

```cpp
// 使用 int 作为非类型参数类型
template <typename U, 
          std::enable_if_t<is_compatible_v<U>, int> = 0>
void func(U u) { /* ... */ }

// 使用 bool
template <typename U,
          std::enable_if_t<is_compatible_v<U>, bool> = true>
void func(U u) { /* ... */ }
```

#### 3.5.5 实际使用中的问题

##### 3.5.5.1 第一种写法的问题

```cpp
template <typename U, typename = std::enable_if_t<is_compatible_v<U>>>
void func(U u) { /* ... */ }
```

- 不同SFINAE条件会产生相同的函数签名
- 可能导致重定义错误
- 示例：

```cpp
template <typename U, typename = std::enable_if_t<is_compatible_v<U>>>
void func(U u) {}

template <typename U, typename = std::enable_if_t<is_other_v<U>>>
void func(U u) {}  // 错误：重定义，签名相同
```

##### 3.5.5.2 第二种写法更好

```cpp
template <typename U, 
          std::enable_if_t<is_compatible_v<U>, int> = 0>
void func(U u) {}

template <typename U,
          std::enable_if_t<is_other_v<U>, int> = 0>
void func(U u) {}  // OK：不同的非类型参数类型
```

#### 3.5.6 现代C++的替代方案

C++17/20提供了更好的方式：

##### 3.5.6.1 C++17: `if constexpr`

```cpp
template <typename U>
void func(U u) {
    if constexpr (is_compatible_v<U>) {
        // 兼容的代码
    } else {
        // 或不处理
    }
}
```

##### 3.5.6.2 C++20: Concepts

```cpp
template <typename U>
requires is_compatible_v<U>
void func(U u) { /* ... */ }

// 或者
template <is_compatible U>
void func(U u) { /* ... */ }
```

#### 3.5.7 总结

| 特性     | `typename = enable_if_t<...>` | `enable_if_t<..., int> = 0` |
| -------- | ----------------------------- | --------------------------- |
| 参数类型 | 类型参数                      | 非类型参数                  |
| 默认值   | 类型默认值                    | 值默认值                    |
| 重载区分 | 不好区分                      | 可以区分                    |
| 常见问题 | 容易导致重定义                | 需要指定具体类型            |

**建议**：使用第二种形式，并明确指定类型（如`int`或`bool`），以避免重载冲突问题。

### 3.6 SFINAE的优缺点

#### 3.6.1 优点

1. **灵活性高**：能够根据类型特性选择不同的实现，提升代码的泛化能力。
2. **类型安全**：通过编译期检测，避免了运行时错误。
3. **无需额外的运行时开销**：所有的类型筛选都在编译期完成。

#### 3.6.2 缺点

1. **复杂性高**：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。
2. **编译器错误信息难以理解**：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。
3. **模板实例化深度限制**：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。

### 3.7 现代C++中的替代方案

随着C++11及后续标准的发展，引入了诸如`decltype`、`constexpr`、`if constexpr`、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的**概念（Concepts）**提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。

#### 3.7.1 示例：使用概念替代SFINAE

```cpp
#include <concepts>
#include <iostream>

// 定义一个概念，要求类型 T 是整数类型
template <typename T>
concept Integral = std::is_integral_v<T>;

// 仅当 T 满足 Integral 概念时启用
template <Integral T>
void print_type(T value) {
    std::cout << "Integral type: " << value << std::endl;
}

int main() {
    print_type(42);        // 输出: Integral type: 42
    // print_type(3.14);   // 编译错误，不满足 Integral 概念
    return 0;
}
```

#### 3.7.2 示例：使用`std::void_t`简化`has_foo`

```cpp
#include <type_traits>
#include <iostream>

// 使用 std::void_t 简化 has_foo
template <typename, typename = std::void_t<>>
struct has_foo : std::false_type {};

template <typename T>
struct has_foo<T, std::void_t<decltype(std::declval<T>().foo())>> : std::true_type {};

// 函数仅在 T 有 foo() 成员时启用
template <typename T>
std::enable_if_t<has_foo<T>::value, void>
call_foo(T& obj) {
    obj.foo();
    std::cout << "foo() called." << std::endl;
}

class WithFoo {
public:
    void foo() { std::cout << "WithFoo::foo()" << std::endl; }
};

class WithoutFoo {};

int main() {
    WithFoo wf;
    call_foo(wf); // 输出: WithFoo::foo()
                   //      foo() called.

    // WithoutFoo wf2;
    // call_foo(wf2); // 编译错误，没有匹配的函数
    return 0;
}
```

#### 3.7.3 使用C++20概念

如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// 定义一个概念，要求类型 T 具有 void foo()
template <typename T>
concept HasFoo = requires(T t) {
    { t.foo() } -> std::same_as<void>;
};

// 仅当 T 满足 HasFoo 概念时启用
template <HasFoo T>
void call_foo(T& obj) {
    obj.foo();
    std::cout << "foo() called." << std::endl;
}

class WithFoo {
public:
    void foo() { std::cout << "WithFoo::foo()" << std::endl; }
};

class WithoutFoo {};

int main() {
    WithFoo wf;
    call_foo(wf); // 输出: WithFoo::foo()
                   //      foo() called.

    // WithoutFoo wf2;
    // call_foo(wf2); // 编译错误，不满足 HasFoo 概念
    return 0;
}
```

### 3.8 总结

SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。

对于SFINAE的两种常见写法，建议使用`std::enable_if_t<..., int> = 0`这种形式，并明确指定类型（如`int`或`bool`），以避免重载冲突问题。同时，随着C++20的普及，更推荐使用Concepts来替代SFINAE，以获得更好的可读性和维护性。

## 4. 高级模板特性

### 4.1 C++20 Concepts

C++20 引入了 **Concepts**，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。

#### 4.1.1 定义与使用

**定义一个 Concept**

Concepts 使用 `concept` 关键字定义，并作为函数或类模板的约束。

```cpp
#include <concepts>
#include <iostream>

// 定义一个 Concept：要求类型必须是可输出到 std::ostream
template <typename T>
concept Printable = requires(T a) {
{ std::cout << a } -> std::same_as<std::ostream&>;
};

// 使用 Concepts 约束函数模板
template <Printable T>
void print(const T& value) {
    std::cout << value << std::endl;
}

int main() {
    print(42);          // 正常调用
    print("Hello");     // 正常调用
    // print(std::vector<int>{1, 2, 3}); // 编译错误，std::vector<int> 不满足 Printable
    return 0;
}
```

#### 4.1.2 限制与约束

Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。

**示例：排序函数中的 Concepts**

```cpp
#include <concepts>
#include <vector>
#include <iostream>
#include <algorithm>

// 定义一个可比较的概念
template <typename T>
concept Comparable = requires(T a, T b) {
{ a < b } -> std::convertible_to<bool>;
};

// 排序函数，约束类型必须可比较
template <Comparable T>
void sortVector(std::vector<T>& vec) {
    std::sort(vec.begin(), vec.end());
}

int main() {
    std::vector<int> nums = {4, 2, 3, 1};
    sortVector(nums);
    for(auto num : nums)
        std::cout << num << " "; // 输出：1 2 3 4 
    std::cout << std::endl;

    // std::vector<std::vector<int>> vecs;
    // sortVector(vecs); // 编译错误，std::vector<int> 不满足 Comparable
    return 0;
}
```

### 4.2 高级模板元编程技巧

#### 4.2.1 类型列表和元素访问

```cpp
// 定义类型列表
template <typename... Ts>
struct TypeList {};

// 获取类型列表中第N个类型
template <typename List, std::size_t N>
struct TypeAt;

template <typename Head, typename... Tail>
struct TypeAt<TypeList<Head, Tail...>, 0> {
using type = Head;
};

template <typename Head, typename... Tail, std::size_t N>
struct TypeAt<TypeList<Head, Tail...>, N> {
using type = typename TypeAt<TypeList<Tail...>, N - 1>::type;
};

// 使用
using list = TypeList<int, double, char>;
using third_type = TypeAt<list, 2>::type; // char
```

**讲解：**

1. `**TypeList**`：定义一个包含多个类型的类型列表。
2. `TypeAt`：通过递归模板，从`TypeList`中获取第N个类型。

- - 当N为0时，类型为`Head`。
  - 否则，递归获取`Tail...`中第N-1个类型。

1. **使用**：定义`list`为`TypeList<int, double, char>`，`third_type`为第2个类型，即`char`。

### 4.3 其他高级模板特性

#### 4.3.1 SFINAE (Substitution Failure Is Not An Error)

当模板参数匹配失败时，编译器会跳过该候选而非报错，常用于条件编译。

```cpp
#include <type_traits>

// 仅对整数类型生效
template <typename T>
auto add(T a, T b) -> std::enable_if_t<std::is_integral_v<T>, T> {
    return a + b;
}

add(3, 5);     // 编译通过
add(3.2, 5.1); // 编译错误：无匹配函数
```

#### 4.3.2 C++20 约束与概念 (Concepts)

简化 SFINAE，通过 `concept` 声明类型约束。

```cpp
template <typename T>
concept Integral = std::is_integral_v<T>;

template <Integral T> // 约束 T 必须是整数类型
T multiply(T a, T b) {
    return a * b;
}

multiply(4, 2);     // OK
// multiply(1.5, 2.0); // 错误：不满足约束
```

#### 4.3.3 参数包与完美转发

- **参数包 (Variadic Templates)**：处理任意数量参数
- **完美转发**：保持参数的值类别（左值/右值）

```cpp
// 递归展开参数包
void print() {} // 终止递归

template <typename First, typename... Rest>
void print(First&& first, Rest&&... rest) {
    std::cout << std::forward<First>(first) << " ";
    print(std::forward<Rest>(rest)...);
}

print("Hello", 42, 3.14); // 输出：Hello 42 3.14
```

#### 4.3.4 Lambda 定义匿名模板方法 (C++14+)

Lambda 支持泛型参数（`auto`），实现匿名模板函数。

```cpp
// 泛型 Lambda（C++14）
auto make_adder = [](auto x) {
    return [x](auto y) { return x + y; };
};

auto add5 = make_adder(5);
std::cout << add5(3);     // 输出 8 (int)
std::cout << add5(2.3);   // 输出 7.3 (double)
```

### 4.4 inline定义

**不使用** `**inline**`**（需要类外定义）**

```cpp
#include <utility>

// 编译期字符串
template <char... Cs>
struct String {
static constexpr char value[sizeof...(Cs) + 1] = { Cs..., '\0' };
};

// 外部定义
template <char... Cs>
constexpr char String<Cs...>::value[sizeof...(Cs) + 1];

// 使用
using hello = String<'H','e','l','l','o'>;

int main() {
    // 访问 value
    // std::cout << hello::value;
}
```

**使用** `**inline**`**（无需类外定义，C++17 起）**

```cpp
#include <utility>

// 编译期字符串
template <char... Cs>
struct String {
inline static constexpr char value[sizeof...(Cs) + 1] = { Cs..., '\0' };
};

// 使用
using hello = String<'H','e','l','l','o'>;

int main() {
    // 访问 value
    // std::cout << hello::value;
}
```

## 5. 关键特性对比与总结

### 5.1 关键特性对比

| 特性         | 用途              | 示例                           |
| ------------ | ----------------- | ------------------------------ |
| **函数模板** | 通用算法          | `sort(vec.begin(), vec.end())` |
| **SFINAE**   | 条件编译          | `std::enable_if`               |
| **Concepts** | 类型约束（C++20） | `requires std::integral<T>`    |
| **参数包**   | 处理不定参数      | `std::make_shared<T>(args...)` |
| **完美转发** | 保持值类别        | `std::forward<T>(arg)`         |

### 5.2 参考书籍

1. **《C++ Primer》第5版**
2. **《Effective Modern C++》**
3. **《C++ Templates: The Complete Guide》**

## 6. 杂

### 6.1 元组 参数包 解包 存储形参（`std::thread`的实现）

> [std::thread](./并发支持库.md)
>
> [std::tuple](./通用工具库.md)	
>
> [std::invoke](./通用工具库.md)	
>
> [std::invocable](./概念库.md)	

```c
#include <tuple>
#include <iostream>
template <typename _Func, typename... _Args>
requires std::invocable<_Func, _Args...>
struct Input {
    using R = std::invoke_result_t<_Func, _Args...>;
    _Func _func;
    std::tuple<_Args...> _values;

    Input(_Func&& func, _Args&&... args) : _func(std::forward<_Func>(func)), _values(std::forward<_Args>(args)...) {}
    constexpr R operator()() const noexcept {
        return std::apply([&](auto&&... args) { return _func(args...); }, _values);
    }
};
int main() {
    Input input([](int a, int b) { return a + b; }, 1, 2);
    input();
    std::cout << std::get<0>(input._values) << std::endl;
    return 0;
}
```

### 6.2 弃置函数禁用隐式转换

利用模板匹配有限的特性

```CPP
void f(int){}

struct X{
    operator int()const { return 0; }
};
struct Y {
    operator double()const { return 0.; }
};

template<typename T>
void f(T) = delete;	//使用弃置函数禁止隐式转换

// void f(auto) = delete; // C++20 起 模板简化
// void f(std::same_as<int> auto) // C++20 起 概念

int main(){
    f(1);               // int
    f(1u);              // unsigned int
    f(1l);              // long
    f(1ll);             // long long
    f(1lu);             // unsigned long
    f(1llu);            // unsigned long long
    f(1.);              // double
    f(1.f);             // float
    f('c');             // char
    f(std::uint8_t{});  // unsigned char
    f(std::int8_t{});   // signed char
    f(X{});             // X
    f(Y{});             // Y
}
```

