# C++模板详解：从基础到高级特性

模板是图灵完备的宏，想象模板是编译期间的方法，传入的参数是类型，而普通的方法是运行期间的传入的参数是变量

模板编译期计算的核心原理：

1. 模板实例化发生在编译期，因此我们可以通过递归模板或者参数包展开或者`constexpr`编译期间求值实例化来展开递归计算。
2. 模板元编程是图灵完备的，这意味着理论上任何可以在运行期完成的计算都可以在编译期用模板元编程完成。
3. 图灵完备性来自于：
   1. **递归模板实例化**：
      - 模板可以递归实例化自身，类似于递归函数调用
      - 通过递归深度控制计算过程
   2. **模板特化作为终止条件**：
      - 模板特化提供了递归终止机制
      - 类似于递归函数的基准情况
   3. **类型和值作为参数**：
      - 模板参数可以是类型和非类型（值）
      - 非类型模板参数（如整数）可以作为计算的状态
   4. **模式匹配**：
      - 编译器通过模式匹配选择正确的模板特化
      - 类似于函数重载解析

# 视频教程

https://www.bilibili.com/video/BV1ui4y1R78s

## 1. 模板基础

### 1.1 为什么需要模板？

在早期 C++ 中，实现通用功能需为不同类型重复编写代码（如 `max(int, int)`、`max(double, double)`）。模板通过**泛型编程**解决此问题，允许编写与类型无关的代码，提升复用性并减少冗余。

### 1.2 模板的作用

1. **类型无关的通用算法**（如 STL 容器和算法）
2. **编译期多态**（优于运行时多态的性能）
3. **元编程基础**（编译期计算）
4. **代码精简**（避免手动重复）

### 1.3 模板编译

#### 1.3.1 编译要求

> 当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。
>
> 通常，*当我们调用一个函数时，编译器只需要掌握函数的声明*。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。
>
> 模板则不同：**为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义**。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

#### 1.3.2 编译报错三阶段

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。

* 第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以**检查语法错误，例如忘记分号或者变量名拼错等**，但也就这么多了。

* 第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常**会检查实参数目是否正确。它还能检查参数类型是否匹配**。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。

* 第三个阶段是模板实例化时，**只有这个阶段才能发现类型相关的错误**。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

### 1.4 模板定义（图灵完备的宏）

#### 1.4.1 写法使用

```cpp
template <typename T, class U> // ok
template <typename T, U> // error
    
template<typename T>
class BlobPtr;//前向声明

template<typename T, class U>
using Pair = std::pair<T, U> //类型别名

template<typename T>
using PairNo = std::pair<T, unsigned> //偏特化
PairNo<std::string> books; //使用

//默认情况下，C+语言假定通过作用域运算符访问的名字不是类型。
//因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是
//我们通过使用关键字typename来实现这一点：
//用typename告知编译器T:value_type是一个类型
template <typename T>
typename T:value_type top(const T &c)
{
	return !c.empty() ? c.back() : typename T:value_type();
}
```

#### 1.4.2 函数模板

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
// 使用：max<int>(3, 5); max<double>(2.8, 3.1);
```

#### 1.4.3 类模板

类模板(class template)是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息`vector<int>`用来代替模板参数的模板实参列表。对于每个类型的实例，编译器都会生成一个对应类型的类

```cpp
template <typename T>
class Stack {
private:
    std::vector<T> elems;
public:
    void push(const T& elem);
    T pop();
};
// 使用：Stack<std::string> s;
```

#### 1.4.4 模板模板参数

##### 1.4.4.1 语法

```cpp
template <template <typename, typename> class Container>
class MyClass { /* ... */ };
```

##### 1.4.4.2 示例

```cpp
#include <iostream>
#include <vector>
#include <list>

template <template <typename, typename> class Container, typename T>
class ContainerPrinter {
public:
    void print(const Container<T, std::allocator<T>>& container) {
        for(const auto& elem : container)
            std::cout << elem << " ";
        std::cout << std::endl;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<int> lst = {10, 20, 30};

    ContainerPrinter<std::vector, int> vecPrinter;
    vecPrinter.print(vec); // 输出：1 2 3 4 5 

    ContainerPrinter<std::list, int> listPrinter;
    listPrinter.print(lst); // 输出：10 20 30 

    return 0;
}
```

### 1.5 模板匹配机制

#### 1.5.1 三个规则

模板特化的匹配规则是：当有多个模板可以匹配时，编译器会选择最特化的版本。具体顺序为：

1. **优先匹配全特化模板**：因为全特化模板是针对特定类型的具体实现，所以最特化。
2. **其次匹配偏特化模板**：偏特化模板是对部分类型或类型组合的特殊处理，其特化程度介于全特化和主模板之间。
3. **最后匹配通用的主模板**：当没有特化模板可以匹配时，使用主模板。

#### 1.5.2 匹配规则总结表

| 情况                   | 匹配顺序                 | 示例                                    |
| ---------------------- | ------------------------ | --------------------------------------- |
| **有全特化**           | 全特化 > 偏特化 > 主模板 | `TypeTrait<int>` 匹配全特化版本         |
| **无全特化，有偏特化** | 偏特化 > 主模板          | `TypeTrait<double*>` 匹配指针偏特化     |
| **只有主模板**         | 主模板                   | `TypeTrait<double>` 匹配主模板          |
| **多个偏特化匹配**     | 选择"最特化"的偏特化     | `Printer<T***>` 比 `Printer<T*>` 更特化 |
| **模糊匹配**           | 编译错误（二义性）       | 见下例                                  |

##### 1.5.2.1 模糊匹配示例（编译错误）

```cpp
template <typename T>
struct Ambiguous {};

// 两个可能匹配的偏特化
template <typename T>
struct Ambiguous<T*> {};

template <typename T>
struct Ambiguous<T[]> {};

// 使用时可能产生二义性
// Ambiguous<int*[]> var; // 错误：两个偏特化都匹配
```

1.5.3 

#### 1.5.3 示例代码与详细说明

```cpp
#include <iostream>
#include <type_traits>

// 1. 主模板（最通用）
template <typename T>
struct TypeTrait {
    static const char* name() { 
        return "Generic type"; 
    }
};

// 2. 偏特化：指针类型
template <typename T>
struct TypeTrait<T*> {
    static const char* name() { 
        return "Pointer to something"; 
    }
};

// 3. 偏特化：所有容器类型（使用模板模板参数）
template <template <typename> class Container, typename T>
struct TypeTrait<Container<T>> {
    static const char* name() { 
        return "Container"; 
    }
};

// 4. 全特化：int类型
template <>
struct TypeTrait<int> {
    static const char* name() { 
        return "int"; 
    }
};

// 5. 全特化：int*类型
template <>
struct TypeTrait<int*> {
    static const char* name() { 
        return "Pointer to int (fully specialized)"; 
    }
};

// 6. 全特化：std::vector<int>类型
template <>
struct TypeTrait<std::vector<int>> {
    static const char* name() { 
        return "Vector of int (fully specialized)"; 
    }
};

// 测试用的简单容器
template <typename T>
struct MyContainer {
    T data;
};

int main() {
    // 测试不同类型的匹配
    std::cout << "TypeTrait<double>::name(): " 
              << TypeTrait<double>::name() << std::endl;
    // 输出: Generic type (匹配主模板)
    
    std::cout << "TypeTrait<int>::name(): " 
              << TypeTrait<int>::name() << std::endl;
    // 输出: int (匹配全特化，而不是主模板)
    
    std::cout << "TypeTrait<int*>::name(): " 
              << TypeTrait<int*>::name() << std::endl;
    // 输出: Pointer to int (fully specialized)
    // 注意：虽然有指针偏特化，但int*有更具体的全特化版本
    
    std::cout << "TypeTrait<double*>::name(): " 
              << TypeTrait<double*>::name() << std::endl;
    // 输出: Pointer to something (匹配指针偏特化)
    
    std::cout << "TypeTrait<std::vector<double>>::name(): " 
              << TypeTrait<std::vector<double>>::name() << std::endl;
    // 输出: Container (匹配容器偏特化)
    
    std::cout << "TypeTrait<std::vector<int>>::name(): " 
              << TypeTrait<std::vector<int>>::name() << std::endl;
    // 输出: Vector of int (fully specialized)
    // 注意：虽然有容器偏特化，但vector<int>有更具体的全特化版本
    
    std::cout << "TypeTrait<MyContainer<double>>::name(): " 
              << TypeTrait<MyContainer<double>>::name() << std::endl;
    // 输出: Container (匹配容器偏特化)
    
    return 0;
}
```

匹配过程解析

1. `TypeTrait<double>` 的匹配过程

1. 检查是否有 `TypeTrait<double>` 的全特化 → 无
2. 检查是否有匹配的偏特化（`double` 不是指针，也不是容器）→ 无
3. 匹配主模板 → ✅

2. `TypeTrait<int>` 的匹配过程

1. 检查是否有 `TypeTrait<int>` 的全特化 → ✅ 有！直接使用全特化版本
2. 不会继续检查偏特化或主模板

3. `TypeTrait<int*>` 的匹配过程

1. 检查是否有 `TypeTrait<int*>` 的全特化 → ✅ 有！直接使用全特化版本
2. 虽然有 `TypeTrait<T*>` 偏特化，但全特化更具体

4. `TypeTrait<double*>` 的匹配过程

1. 检查是否有 `TypeTrait<double*>` 的全特化 → 无
2. 检查偏特化 `TypeTrait<T*>` → ✅ 匹配！
3. 不会使用主模板



## 2. 进阶模板编程

### 2.1 模板特化与偏特化

#### 2.1.1 为什么需要特化？

模板提供通用实现，但特定类型可能需要：

1. **性能优化**（如指针类型的特殊处理）
2. **特殊行为**（如C字符串的格式化）
3. **边界情况处理**（如空指针处理）
4. **类型适配**（如自定义类型的格式化）

#### 2.1.2 模板特化（Template Specialization）

模板特化允许开发者为特定类型或类型组合提供专门的实现。当通用模板无法满足特定需求时，特化模板可以调整行为以处理特定的情况。C++ 支持**全特化（Full Specialization）**********和************偏特化（Partial Specialization）**，但需要注意的是，**函数模板不支持偏特化**，只能进行全特化。

##### 2.1.2.1 全特化（Full Specialization）

为特定类型提供完全不同的实现

```cpp
#include <format>
#include <iostream>
#include <vector>

// 主模板
template <typename T>
struct Formatter {
    static std::string format(const T& value) {
        return std::format("Value: {}", value);
    }
};

// 全特化：int类型
template <>
struct Formatter<int> {
    static std::string format(int value) {
        return std::format("INT: {0} (hex: {0:#x})", value);
    }
};

// 全特化：vector类型
template <typename T>
struct Formatter<std::vector<T>> {
    static std::string format(const std::vector<T>& vec) {
        std::string result = "Vector[";
        for (const auto& item : vec) {
            result += Formatter<T>::format(item) + ", ";
        }
        if (!vec.empty()) result.erase(result.end()-2, result.end());
        return result + "]";
    }
};
```

使用示例：

```cpp
int main() {
    std::cout << Formatter<double>::format(3.14) << "\n"; 
    // 输出: Value: 3.14
    
    std::cout << Formatter<int>::format(42) << "\n";      
    // 输出: INT: 42 (hex: 0x2a)
    
    std::vector<int> vec = {1, 2, 3};
    std::cout << Formatter<decltype(vec)>::format(vec) << "\n";
    // 输出: Vector[INT: 1 (hex: 0x1), INT: 2 (hex: 0x2), INT: 3 (hex: 0x3)]
}
```

##### 2.1.2.2 偏特化（Partial Specialization）

模板偏特化是C++模板的一种特性，允许我们为特定模式下的模板参数提供特殊的定义。它通常用于类模板，不能用于函数模板（函数模板可以通过重载实现类似的效果）。

（**类模板特有，函数模板需用重载替代**），对模板参数的部分限制进行特化

```cpp
// 主模板：指针类型
template <typename T>
struct Formatter<T*> {
    static std::string format(T* ptr) {
        if (!ptr) return "Null pointer";
        return std::format("Pointer to: {}", Formatter<T>::format(*ptr));
    }
};

// 偏特化：对指针的指针
template <typename T>
struct Formatter<T**> {
    static std::string format(T** ptr) {
        if (!ptr || !*ptr) return "Null double pointer";
        return std::format("Double pointer to: {}", Formatter<T>::format(**ptr));
    }
};

// 偏特化：所有智能指针类型
template <template <typename> typename SmartPtr, typename T>
struct Formatter<SmartPtr<T>> {
    static std::string format(const SmartPtr<T>& ptr) {
        if (!ptr) return "Empty smart pointer";
        return std::format("SmartPtr: {}", Formatter<T>::format(*ptr));
    }
};
```

使用示例：

```cpp
#include <memory>

int main() {
    int x = 10;
    int* px = &x;
    int** ppx = &px;
    
    std::cout << Formatter<decltype(px)>::format(px) << "\n";
    // 输出: Pointer to: INT: 10 (hex: 0xa)
    
    std::cout << Formatter<decltype(ppx)>::format(ppx) << "\n";
    // 输出: Double pointer to: INT: 10 (hex: 0xa)
    
    auto sp = std::make_shared<double>(3.14);
    std::cout << Formatter<decltype(sp)>::format(sp) << "\n";
    // 输出: SmartPtr: Value: 3.14
}
```

#### 2.1.3 函数模板特化替代方案

##### 2.1.3.1 使用重载 + 约束（C++20）

```cpp
// 主模板
template <typename T>
std::string format_value(const T& value) {
    return std::format("Value: {}", value);
}

// 重载版本：C风格字符串
std::string format_value(const char* str) {
    return std::format("C-string: \"{}\"", str);
}

// 使用C++20约束的重载
template <typename T>
requires std::is_pointer_v<T>
std::string format_value(T ptr) {
    if (!ptr) return "Null pointer";
    return std::format("Pointer: {}", format_value(*ptr));
}
```

#### 2.1.4 特化机制解析

| 类型       | 特点                               | 适用场景                            |
| ---------- | ---------------------------------- | ----------------------------------- |
| **全特化** | 完全指定所有模板参数               | 特定类型的完全重写（如`vector<T>`） |
| **偏特化** | 部分指定模板参数（仅类模板）       | 类型类别处理（如所有指针类型）      |
| **重载**   | 函数模板替代方案（结合约束更强大） | 函数模板的特殊版本                  |

#### 2.1.5 总结

- **全特化**适用于为具体类型或类型组合提供专门实现，适用于类模板和函数模板。
- **偏特化**仅适用于类模板，允许针对部分参数进行特定处理，同时保持其他参数的通用性。
- **函数模板**仅支持全特化，不支持偏特化；类模板支持全特化和偏特化。
- **特化模板**提升了模板的灵活性和适应性，使其能够根据不同类型需求调整行为。

### 2.2 变参模板

变参模板允许模板接受可变数量的参数，提供极高的灵活性，是实现诸如 `std::tuple`、`std::variant` 等模板库组件的基础。

#### 2.2.1 定义与语法

变参模板使用 **参数包（Parameter Pack）**，通过 `...` 语法来表示。

```cpp
template <typename... Args>
class MyClass { /* ... */ };

template <typename T, typename... Args>
void myFunction(T first, Args... args) { /* ... */ }
```

#### 2.2.2 递归与展开（Recursion and Expansion）

变参模板通常与递归相结合，通过递归地处理参数包，或者使用 **折叠表达式（Fold Expressions）** 来展开发参数包。

##### 2.2.2.1 递归

```cpp
#include <iostream>

// 基础情况：无参数
void printAll() {
    std::cout << std::endl;
}

// 递归情况：至少一个参数
template <typename T, typename... Args>
void printAll(const T& first, const Args&... args) {
    std::cout << first << " ";
    printAll(args...);
}

int main() {
    printAll(1, 2.5, "Hello", 'A'); // 输出：1 2.5 Hello A 
    return 0;
}
```

##### 2.2.2.2 折叠表达式版本

```cpp
#include <iostream>

// 使用折叠表达式的printAll
template <typename... Args>
void printAll(const Args&... args) {
    // 使用左折叠展开参数包，并在每个参数之后输出一个空格
    ((std::cout << args << " "), ...);
    std::cout << std::endl;
}

int main() {
    printAll(1, 2.5, "Hello", 'A'); // 输出：1 2.5 Hello A 
    return 0;
}
```

##### 2.2.2.3 折叠表达式示例：计算总和

```cpp
#include <iostream>

template <typename... Args>
auto sum(Args... args) -> decltype((args + ...)) {
    return (args + ...); 
}

int main() {
    std::cout << sum(1, 2, 3, 4) << std::endl; // 输出：10
    std::cout << sum(1.5, 2.5, 3.0) << std::endl; // 输出：7
    return 0;
}
```

##### 2.2.2.4 示例：日志记录器

```cpp
#include <iostream>
#include <string>

// 基础情况：无参数
void log(const std::string& msg) {
    std::cout << msg << std::endl;
}

// 递归情况：至少一个参数
template <typename T, typename... Args>
void log(const std::string& msg, const T& first, const Args&... args) {
    std::cout << msg << ": " << first << " ";
    log("", args...); // 递归调用，省略消息前缀
}

int main() {
    log("Error", 404, "Not Found");
    // 输出: Error: 404 Not Found 

    log("Sum", 10, 20, 30);
    // 输出: Sum: 10 20 30 
    return 0;
}
```

### [2.3 模板折叠（Fold Expressions）](https://www.bilibili.com/video/BV1NM4y1e7Hn/)

#### 2.3.1 折叠表达式的概念与背景

在C++中，**可变参数模板**允许函数或类模板接受任意数量的模板参数。这在编写灵活且通用的代码时非常有用。然而，处理参数包中的每个参数往往需要递归模板技巧，这样的代码通常复杂且难以维护。

**折叠表达式**的引入显著简化了这一过程。它们允许开发者直接对参数包应用操作符，而无需手动展开或递归处理参数。这不仅使代码更加简洁，还提高了可读性和可维护性。

**折叠表达式**可分为：

- **一元折叠表达式（Unary Fold）**：对参数包中的每个参数应用一个一元操作符。
- **二元折叠表达式（Binary Fold）**：对参数包中的每个参数应用一个二元操作符。

此外，**二元折叠表达式**可进一步细分为**左折叠（Left Fold）**********和************右折叠（Right Fold）**，取决于操作符的结合方向。

#### 2.3.2 一元折叠表达式（Unary Fold）

**一元折叠表达式**用于在参数包的每个参数前或后应用一元操作符。语法形式如下：

**前置一元折叠（Unary Prefix Fold）**`(... + args)`（一元左折叠）

(op ... pack) 

对于调用 `unary_left_fold(1, 2, 3, 4)`，展开过程为：

```
((1 + 2) + 3) + 4
```

**后置一元折叠（Unary Postfix Fold）**`(args + ...)`（一元右折叠）

(pack ... op)

对于调用 `unary_right_fold(1, 2, 3, 4)`，展开过程为：

```
1 + (2 + (3 + 4))
```

其中，`op` 是一元操作符，如`!`（逻辑非）、`~`（按位取反）等。

**示例1：逻辑非操作**

```cpp
#include <iostream>

//对每个参数非操作，然后再将这些操作&&
//(!args && ...) 相当于 !a && !b && ...
template<typename... Args>
bool allNot(const Args&... args){
    return (!args && ...);
}
```

#### 2.3.3 二元折叠表达式（Binary Fold）

**二元折叠表达式**用于在参数包的每个参数之间应用一个二元操作符。它们可以分为**二元左折叠（Binary Left Fold）**********和************二元右折叠（Binary Right Fold）**，取决于操作符的结合方向。

**二元折叠表达式语法**

**二元左折叠（Left Fold） `(init + ... + args)`**：

- (init op ... op pack)

或者简化为：

- (pack1 op ... op packN)

对于调用 `binary_left_fold(10, 1, 2, 3, 4)`，展开过程为：

```
(((10 + 1) + 2) + 3) + 4 // 10是初始值，二元和一元区别时能够设置初始值
```



**二元右折叠（Right Fold）**`(args + ... + init)`：

- (pack1 op ... op init op ...)

或者简化为：

- (pack1 op ... op packN)

对于调用 `binary_right_fold(10, 1, 2, 3, 4)`，展开过程为：

```
1 + (2 + (3 + (4 + 10))) // 10是初始值
```



其中，`op` 是二元操作符，如`+`、`*`、`&&`、`||`、`<<` 等。

**左折叠与右折叠的区别**

- **二元左折叠（Binary Left Fold）**：操作符从左至右结合，等价于 `(((a op b) op c) op d)`。
- **二元右折叠（Binary Right Fold）**：操作符从右至左结合，等价于 `(a op (b op (c op d)))`。

**示例1：求和（Binary Left Fold）**

```cpp
#include <iostream>

// 二元左折叠：((arg1 + arg2) + arg3) + ... + argN
template<typename... Args>
auto sumLeftFold(const Args&... args) {
    return (args + ...); // 左折叠
}

int main() {
    std::cout << sumLeftFold(1, 2, 3, 4) << std::endl; // 输出：10
    return 0;
}
```

**解释**：

- `**(args + ...)**` 是一个二元左折叠表达式。
- 它将`+`操作符逐个应用于参数，按照左折叠顺序。
- 即，`((1 + 2) + 3) + 4 = 10`。

**示例2：乘积（Binary Right Fold）**

```cpp
#include <iostream>

// 二元右折叠：arg1 * (arg2 * (arg3 * ... * argN))
template<typename... Args>
auto productRightFold(const Args&... args) {
    return (... * args); // 右折叠
}

int main() {
    std::cout << productRightFold(2, 3, 4) << std::endl; // 输出：24
    return 0;
}
```

**解释**：

- `**(... \* args)**` 是一个二元右折叠表达式。
- 它将`*`操作符逐个应用于参数，按照右折叠顺序。
- 即，`2 * (3 * 4) = 2 * 12 = 24`。

**示例3：逻辑与（Binary Left Fold）**

```cpp
#include <iostream>

template<typename... Args>
bool allTrue(const Args&... args) {
    return (args && ...); // 左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << allTrue(true, true, false) << std::endl; // 输出：false
    std::cout << allTrue(true, true, true) << std::endl;  // 输出：true
    return 0;
}
```

**解释**：

- `**(args && ...)**` 是一个二元左折叠表达式。
- 用于检查所有参数是否为`true`。
- 类似于链式的逻辑与运算。

#### 2.3.4 左折叠与右折叠（Left and Right Folds）

了解**左折叠**和**右折叠**的区别，对于正确选择折叠表达式的形式至关重要。

**二元左折叠（Binary Left Fold）**

**语法**：

- (args op ...)

**展开方式**：

- ((arg1 op arg2) op arg3) op ... op argN
- **适用场景**：

- - 当操作符是结合性的且从左侧开始累积操作时（如`+`、`*`）。
  - 需要严格的顺序执行时，确保从左到右依次处理参数。

**示例**：

- (args + ...) // 左折叠求和

**二元右折叠（Binary Right Fold）**

**语法**：

- (... op args)

**展开方式**：

- arg1 op (arg2 op (arg3 op ... op argN))
- **适用场景**：

- - 当操作符是右结合的，或当需要从右侧开始累积操作时。
  - 某些特定的逻辑和数据结构可能需要右侧先处理。

**示例**：

- (... + args) // 右折叠求和

**嵌套折叠表达式**

在某些复杂场景下，可能需要嵌套使用左折叠和右折叠，以达到特定的操作顺序。例如，结合多个不同的操作符。

```cpp
#include <iostream>

template<typename... Args>
auto complexFold(const Args&... args) {
    // 先左折叠求和，然后右折叠求乘积
    return (args + ...) * (... + args);
}

int main() {
    std::cout << complexFold(1, 2, 3) << std::endl; // (1+2+3) * (1+2+3) = 6 * 6 = 36
    return 0;
}
```

**解释**：

- 在此示例中，我们首先对参数进行左折叠求和，然后对参数进行右折叠求和，最后将两者相乘。
- 这种嵌套用途展示了折叠表达式的灵活性。

#### 2.3.5 `op` 在折叠表达式中的作用

##### 支持的运算符

```
+ - * / % ^ & | = < > << >> += -= *= /= ^= &= |= <<= >>= == != <= >=
&& || , .* ->*

其中 传入空参数包时
&& 值为true
|| 值为false
,  值为void()

其他 错误非法
```

在折叠表达式中，`op` 代表**二元操作符**，用于定义如何将参数包中的各个参数相互结合。`op` 可以是任何合法的二元操作符，包括但不限于：

- **算术操作符**：`+`、`-`、`*`、`/`、`%` 等。
- **逻辑操作符**：`&&`、`||` 等。
- **按位操作符**：`&`、`|`、`^`、`<<`、`>>` 等。
- **比较操作符**：`==`、`!=`、`<`、`>`、`<=`、`>=` 等。
- **自定义操作符**：如果定义了自定义类型并重载了特定的操作符，也可以使用这些操作符。

`**op**` **的选择直接影响折叠表达式的行为和结果**。选择适当的操作符是实现特定功能的关键。

**示例1：使用加法操作符**

```cpp
#include <iostream>

template<typename... Args>
auto addAll(const Args&... args) {
    return (args + ...); // 使用 '+' 进行左折叠
}

int main() {
    std::cout << addAll(1, 2, 3, 4) << std::endl; // 输出：10
    return 0;
}
```

**示例2：使用逻辑与操作符**

```cpp
#include <iostream>

template<typename... Args>
bool allTrue(const Args&... args) {
    return (args && ...); // 使用 '&&' 进行左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << allTrue(true, true, false) << std::endl; // 输出：false
    std::cout << allTrue(true, true, true) << std::endl;  // 输出：true
    return 0;
}
```

**示例3：使用左移操作符（流插入）**

```cpp
#include <iostream>

template<typename... Args>
void printAll(const Args&... args) {
    (std::cout << ... << args) << std::endl; // 使用 '<<' 进行左折叠
}

int main() {
    printAll("Hello, ", "world", "!", 123); // 输出：Hello, world!123
    return 0;
}
```

**解释**：

- 在上述示例中，`op` 分别为 `+`、`&&`、`<<`。
- 每个操作符定义了如何将参数包中的元素相互结合。

**示例4：使用自定义操作符**

假设有一个自定义类型`Point`，并重载了`+`操作符以支持点的相加。

```cpp
#include <iostream>

struct Point {
int x, y;

// 重载 '+' 操作符
Point operator+(const Point& other) const {
    return Point{ x + other.x, y + other.y };
}
};

// 二元左折叠：((p1 + p2) + p3) + ... + pN
template<typename... Args>
Point sumPoints(const Args&... args) {
    return (args + ...); // 使用 '+' 进行左折叠
}

int main() {
    Point p1{1, 2}, p2{3, 4}, p3{5, 6};
    Point result = sumPoints(p1, p2, p3);
    std::cout << "Sum of Points: (" << result.x << ", " << result.y << ")\n"; // 输出：(9, 12)
    return 0;
}
```

**解释**：

- 通过重载`+`操作符，`sumPoints`函数能够将多个`Point`对象相加，得到累积的结果。

#### 2.3.6 逗号运算符在参数包展开中的详细解析

在C++模板编程中，逗号运算符在参数包展开中扮演着重要角色，特别是在C++11/14中处理可变参数模板时。本节将详细解析逗号运算符的工作原理、应用场景以及现代C++中的优化方案。

##### 2.3.6.1 逗号运算符的基本行为

在C++中，逗号运算符`,`具有以下特性：

1. **按从左到右的顺序计算每个操作数**
2. **返回最右侧操作数的值**
3. **整个表达式的类型是最右侧操作数的类型**

例如：`int x = (1, 2, 3);` 中，`x` 的值是 3。

##### 2.3.6.2 参数包展开中的逗号运算符

在C++11/14中，逗号运算符常用于参数包展开，特别是在初始化列表中。

###### 2.3.6.2.1 原始代码分析

```cpp
template<typename Func, typename... Args>
auto all_of(Func f, Args...args) {
    int _[] = { (0, f(args))... };
    return sizeof...(args) == std::accumulate(std::begin(_), std::end(_), 0);
}
```

###### 2.3.6.2.2 执行逻辑顺序

对于调用 `all_of([](int v) -> bool { return v % 2 == 0; }, 1, 2, 3, 4)`：

1. 参数包展开：

   ```cpp
   int _[] = {
       (0, f(1)),  // 第一步：计算0（无效果）
                   // 第二步：计算f(1)→返回false(0)
                   // 第三步：返回f(1)的结果→0
       (0, f(2)),  // 第一步：计算0（无效果）
                   // 第二步：计算f(2)→返回true(1)
                   // 第三步：返回f(2)的结果→1
       (0, f(3)),  // 返回f(3)的结果→0
       (0, f(4))   // 返回f(4)的结果→1
   };
   ```

2. 数组初始化：

   ```cpp
   int _[] = {0, 1, 0, 1};
   ```

3. 累加计算：

   ```cpp
   std::accumulate(std::begin(_), std::end(_), 0) → 0 + 1 + 0 + 1 = 2
   ```

4. 比较结果：

   ```cpp
   return 4 == 2; // 返回false
   ```

###### 2.3.6.2.3 为什么需要添加0？

1. **确保类型一致性**：
   - 如果函数`f`返回`void`，直接使用`f(args)...`会导致编译错误
   - `(0, f(args))`确保表达式始终有一个非void的返回值

2. **处理边界情况**：
   - 避免某些运算符优先级问题
   - 提供一种通用的参数包展开模式

3. **历史原因**：
   - 在C++11/14中，这是处理参数包展开的常见习惯用法

###### 2.3.6.2.4 顺序调整的影响

如果改为`(f(args), 0)...`：

```cpp
int _[] = { (f(args), 0)... };
```

执行逻辑变为：

1. 先计算`f(args)`（调用函数）
2. 然后计算`0`
3. 返回`0`的值

因此数组会被初始化为全0：`{0, 0, 0, 0}`，完全丢失了函数调用的结果。

##### 2.3.6.3 使用`std::index_sequence`编译时整数序列（C++14）和逗号运算符

在C++14中，类模板 `std::integer_sequence` 表示一个编译时整数序列。在此基础上有一些辅助工具：

- `std::make_integer_sequence<T, N>` - 创建一个类型为 `T` 的 `0, ..., N - 1` 序列。
- `std::index_sequence_for<T...>` - 将模板参数包转换为整数序列。

`std::index_sequence`与逗号运算符结合使用，可以创建编译时整数序列并用于参数包展开。

###### 2.3.6.3.1 创建重复值的数组

```cpp
#include <array>
#include <utility>

template <typename T, std::size_t N, std::size_t... Is>
constexpr auto make_array_impl(T&& value, std::index_sequence<Is...>) {
    // remove cvref from T
    // 逗号运算符：返回最后一个表达式的结果（std::forward<T>(value)）
    return std::array<std::decay_t<T>, N>{ (static_cast<void>(Is), std::forward<T>(value))... };
    /*
     return std::array<std::decay_t<T>, N>{ 
        (void)Is...,  // 展开并丢弃所有Is
        std::forward<T>(value)  // 最后一个值用作初始化
    };
    // like this:
    return std::array<int, 3>{
        (static_cast<void>(0), std::forward<T>(value)), // 类似宏的"挤兑"
        (static_cast<void>(1), std::forward<T>(value)),
        (static_cast<void>(2), std::forward<T>(value))
    };
    */
}

template <typename T, std::size_t N>
[[nodiscard]] constexpr auto make_array(T&& value) {
    return make_array_impl<T, N>(std::forward<T>(value), std::make_index_sequence<N>());
}

int main() {
    auto arr = make_array<int, 5>(42);
    // arr 包含 {42, 42, 42, 42, 42}
}
```

##### 2.3.6.4 C++17折叠表达式优化

C++17引入的折叠表达式可以大大简化这类代码，使得逗号运算符的技巧在许多场景下不再必要。

###### 2.3.6.4.1 使用逻辑与折叠表达式

```cpp
template<typename Func, typename... Args>
bool all_of(Func f, Args... args) {
    return (f(args) && ...);
}
```

###### 2.3.6.4.2 执行过程

对于相同的调用：

```cpp
all_of([](int v) -> bool { return v % 2 == 0; }, 1, 2, 3, 4)
```

折叠表达式展开为：

```cpp
return f(1) && f(2) && f(3) && f(4);
```

执行流程：

1. 计算`f(1)`→返回`false`
2. 由于逻辑与的短路特性，直接返回`false`，不再计算后续表达式

优势

1. **代码简洁**：一行代码替代了原来的多行实现
2. **性能优化**：利用短路求值，遇到第一个`false`就立即返回
3. **类型安全**：不需要中间数组，直接处理布尔结果
4. **可读性高**：意图更加明确，易于理解

##### 2.3.6.5 其他折叠表达式应用

###### 2.3.6.5.1 使用逗号运算符折叠

```cpp
template<typename Func, typename... Args>
void for_each(Func f, Args... args) {
    (f(args), ...);
}
```

这个实现会对每个参数调用函数`f`，忽略返回值，类似于原始代码但更加简洁。

###### 2.3.6.5.2 复杂条件检查

```cpp
template<typename... Conditions>
bool complex_condition(Conditions... conds) {
    return (conds() && ...);
}
```

可以用于检查多个复杂条件，每个条件通过函数调用获取。

#### 2.3.7 示例代码与应用

为了全面理解折叠表达式的应用，以下提供多个具体示例，涵盖不同类型的折叠表达式。

##### **示例1：字符串拼接**

```cpp
#include <iostream>
#include <string>

template<typename... Args>
std::string concatenate(const Args&... args) {
    return (std::string{} + ... + args); // 左折叠
    //左折叠展开为((std::string{} + "A") + "B") + "C"
    //return (args + ... + std::string{});右折叠
    //右折叠展开为"A" + ("B" + ("C" + std::string{}))
    // 两种写法输出一样，过程不一样
}

int main() {
    std::string result = concatenate("Hello, ", "world", "!", " Have a nice day.");
    std::cout << result << std::endl; // 输出：Hello, world! Have a nice day.
    return 0;
}
```

##### **示例2：计算逻辑与**

```cpp
#include <iostream>

template<typename... Args>
bool areAllTrue(const Args&... args) {
    return (args && ...); // 左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << areAllTrue(true, true, true) << std::endl;   // 输出：true
    std::cout << areAllTrue(true, false, true) << std::endl;  // 输出：false
    return 0;
}
```

##### **示例3：计算最大值**

```cpp
#include <iostream>
#include <algorithm>

template<typename T, typename... Args>
T maxAll(T first, Args... args) {
    return (std::max)(first, ... , args); // 左折叠
}

int main() {
    std::cout << maxAll(1, 5, 3, 9, 2) << std::endl; // 输出：9
    return 0;
}
```

**注意**：上述示例中的`(std::max)(first, ... , args)`是一个非标准用法，需要根据具体情况调整。通常，`std::max`不支持直接的折叠表达式，因此此例更适合作为概念性说明。在实际应用中，可以使用`std::initializer_list`或其他方法实现多参数的最大值计算。

##### **示例4：筛选逻辑**

假设需要检查多个条件是否满足，且每个条件之间使用逻辑或操作：

```cpp
#include <iostream>

template<typename... Args>
bool anyTrue(const Args&... args) {
    return (args || ...); // 左折叠
}

int main() {
    std::cout << std::boolalpha;
    std::cout << anyTrue(false, false, true) << std::endl; // 输出：true
    std::cout << anyTrue(false, false, false) << std::endl; // 输出：false
    return 0;
}
```

##### 示例5：值捕获参数包

```cpp
#include <iostream>
#include <functional>

template<typename Func, typename... Args>
auto delay_invoke(Func f, Args... args) {
    // 值捕获所有参数
    return [f, args...]() -> decltype(auto) {
        return std::invoke(f, args...);
    };
}

int main() {
    auto add = [](int a, int b) { return a + b; };
    auto delayed_add = delay_invoke(add, 10, 20);
    std::cout << delayed_add() << std::endl; // 输出: 30
    return 0;
}
```

##### 示例6：使用移动语义和元组

```cpp
#include <iostream>
#include <tuple>
#include <functional>

template<typename Func, typename... Args>
auto delay_invoke(Func f, Args... args) {
    // 使用移动语义，将参数存储在元组中
    return [f = std::move(f), tup = std::make_tuple(std::move(args)...)]() -> decltype(auto) {
        return std::apply(f, tup);
    };
}

int main() {
    auto concat = [](std::string a, std::string b, std::string c) {
        return a + b + c;
    };
    
    std::string s1 = "Hello, ";
    std::string s2 = "world";
    std::string s3 = "!";
    
    auto delayed_concat = delay_invoke(concat, s1, s2, s3);
    std::cout << delayed_concat() << std::endl; // 输出: Hello, world!
    
    // 原始字符串已移动，不能再使用
    // std::cout << s1 << std::endl; // 可能为空
    return 0;
}
```

##### 示例7：C++20简化写法（包展开捕获）

```cpp
#include <iostream>
#include <functional>

template<typename Func, typename... Args>
auto delay_invoke(Func f, Args... args) {
    // C++20起支持包展开捕获
    return [f = std::move(f), ...args = std::move(args)]() -> decltype(auto) {
        return std::invoke(f, args...);
    };
}

int main() {
    auto multiply = [](double a, double b, double c) { return a * b * c; };
    auto delayed_multiply = delay_invoke(multiply, 2.5, 3.0, 4.0);
    std::cout << delayed_multiply() << std::endl; // 输出: 30
    return 0;
}
```

##### 示例8：将数组转换为元组（`index_sequence`）

```cpp
#include <array>
#include <tuple>
#include <utility>

template<typename Array, std::size_t... I>
decltype(auto) a2t_impl(const Array& a, std::index_sequence<I...>) {
    // 使用索引序列展开数组元素
    return std::make_tuple(a[I]...);
}

template<typename T, std::size_t N, typename Indices = std::make_index_sequence<N>>
decltype(auto) a2t(const std::array<T, N>& a) {
    return a2t_impl(a, Indices());
}

int main() {
    std::array<int, 5> arr = {1, 2, 3, 4, 5};
    auto tup = a2t(arr);
    
    // 验证元组内容
    static_assert(std::tuple_size<decltype(tup)>::value == 5);
    std::cout << std::get<0>(tup) << std::endl; // 输出: 1
    std::cout << std::get<4>(tup) << std::endl; // 输出: 5
    
    return 0;
}
```

##### 示例9：多种打印函数的实现

```cpp
#include <iostream>
#include <tuple>
#include <utility>
#include <format>
#include <string_view>
#include <numbers>

// 方法1: 使用折叠表达式（C++17）
auto print1 = []<typename...Args>(Args&&...args1) -> void {
    //// &...args2 = std::forward<Args>(args1)引用捕获，...args2 = std::forward<Args>(args1)值捕获
    // 捕获引用，使用折叠表达式打印
    [&/*可以写成 "&...args2 = std::forward<Args>(args1)"*/]() {
        (std::cout << ... << args1) << " ";
    }();
    std::cout << std::endl;
};

// 方法2: 使用索引序列
auto print2 = [](auto&&...args) -> void {
    // 使用lambda模板和索引序列
    [&] <std::size_t...idx>(std::index_sequence<idx...>) {
        // 使用折叠表达式和std::get
        (std::print("{} ", std::get<idx>(std::forward_as_tuple(args...))/*C++26 can write as -> "args...[idx]"*/), ...);
    }(std::make_index_sequence<sizeof...(args)>{});
    std::cout << std::endl;
};

// 方法3: 使用初始化列表（要求所有参数类型一致）
auto print3 = [] <typename... Args>(Args&&... args) {
    // 创建初始化列表，要求所有元素类型相同
    /*C++26 can add "template" before for*/for (auto arg : { args... }) {
        std::cout << arg << " ";
    }
    std::cout << std::endl;
};

// 方法4: 打印元组（已知类型）
auto print4 = []<typename... Args>(const std::tuple<Args...>& _Tuple) {
    constexpr std::size_t N = sizeof...(Args);
    // 使用索引序列遍历元组
    [&] <size_t... I>(std::index_sequence<I...>) {
        // 使用折叠表达式，最后一个元素不加空格
        (..., (std::cout << std::get<I>(_Tuple) << (I != N - 1 ? " " : "")));
    }(std::make_index_sequence<N>());
    std::cout << std::endl;
};

// 方法5: 打印任意元组
auto print5 = [](const auto& _Tuple) {
    // 移除CV引用限定符，计算元组大小
    constexpr std::size_t N = std::tuple_size_v<std::remove_cvref_t<decltype(_Tuple)>>;
    [&] <size_t... I>(std::index_sequence<I...>) {
        (..., (std::cout << std::get<I>(_Tuple) << (I != N - 1 ? " " : "")));
    }(std::make_index_sequence<N>());
    std::cout << std::endl;
};

// 方法6: 使用C++20 format
auto print6 = []<typename...Args>(const std::string_view fmt_str, Args&&... args) {
    auto fmt_args{ std::make_format_args(std::forward<Args>(args)...) };
    std::string outstr{ std::vformat(fmt_str, fmt_args) };
    std::cout << outstr;
};

int main() {
    print1("1", "2", 3);                    // 输出: 1 2 3
    print2("1", "2", 3);                    // 输出: 1 2 3
    print3("1", "2", "3");                  // 输出: 1 2 3 (类型必须一致)
    print4(std::make_tuple("1", "2", 3));   // 输出: 1 2 3
    print5(std::tuple{ "1", "2", 3 });      // 输出: 1 2 3
    print6("PI: {:.6f}\n", std::numbers::pi); // 输出: PI: 3.141593
    return 0;
}
```

##### 示例10：初始化列表求和

```cpp
#include <iostream>
#include <numeric>
#include <type_traits>

// 求和函数1: 对多个初始化列表求和
auto sum_n1 = []<typename std::size_t...Ns, typename T>(T(&&... values)[Ns]) {
    // 将多个初始化列表整合为一个，计算每个列表的和
    auto _ = { std::accumulate(std::begin(values), std::end(values), 0)... };
    // 对所有列表的和再求和
    return std::accumulate(_.begin(), _.end(), 0);
};

// 求和函数2: 对多个参数求和（consteval编译时计算）
auto sum_n2 = []<typename...Args>(Args&&...args) consteval {
    // 找到所有参数的公共类型
    using T = std::common_type_t<Args...>;
    // 创建初始化列表，统一类型
    auto _ = { static_cast<T>(args)... };
    // 计算总和
    return std::accumulate(std::begin(_), std::end(_), T{});
};

int main() {
    // 测试sum_n1
    int result1 = sum_n1({1, 2, 3}, {5, 6});
    std::cout << "sum_n1({1,2,3}, {5,6}) = " << result1 << std::endl; // 输出: 17
    
    // 测试sum_n2（编译时计算）
    constexpr auto result2 = sum_n2(1, 2, 3.5f, 5, 6);
    static_assert(std::is_same_v<decltype(result2), const float>);
    std::cout << "sum_n2(1, 2, 3.5, 5, 6) = " << result2 << std::endl; // 输出: 17.5
    
    return 0;
}
```

##### 示例11：萃取相同类型

* 标准库提供`std::common_type_t`可以实现，我们这里手动实现了解底层原理

C++14写法

```C++
template<class T1, class T2>
struct common_type_two
{
  using type = decltype(0 ? std::declval<T1>() : std::declval<T2>());
  // 使用 三元运算符，根据C++的类型转换规则， 他们将会得到共同的类型，好比 1
  // + 2.0得到double，但是+运算符不是所有类型都支持，而三元运算符则是所有类型都支持
};

template<class ...Ts>
struct common_type
{

};

// 递归终止，和自己比较
template<class T0>
struct common_type<T0>
{
  using type = T0;
};

template<class T0, class T1, class... Ts>
struct common_type<T0, T1, Ts...>
{
  using type = typename common_type_two<T0, typename common_type<T1, Ts...>::type>::type;
};
```

C++17写法

* `std::type_identity_t`就是dummy，防止参数传递的时候如果该类型无拷贝、无移动、那么就会出错，而dummy进行包装的一个空类，可以支持拷贝，移动，我们仅需要通过模板保存类型`type`

```C++
_EXPORT_STD template <class _Ty>
struct type_identity {
    using type = _Ty;
};
_EXPORT_STD template <class _Ty>
using type_identity_t = type_identity<_Ty>::type;


template<class T0, class... Ts>
constexpr auto get_common_type(std::type_identity_t<T0> t0,
                               std::type_identity_t<Ts>... ts)
{
  if constexpr (sizeof...(Ts) == 0) return t0;
  else return 0 ? t0 : get_common_type(ts...);
}

struct Animal {};
struct Cat : public Animal {
    Cat(Cat &&) = delete
};

int main()
{
	using what = decltype(get_common_type(std::declval<Cat>(), std::declval<Animal>())); // 如果不包裹std::type_identity_t，编译出错
}
```

##### 示例12：参数列表判断是否可以进行显式/隐式转换

```C++
template<class T, class... Ts>
struct is_constructible_any // 显式转换检查
{
    static constexpr bool value = (false || ... || std::is_constructible_v<T, Ts>);
};

template<class T, class... Ts>
struct is_convertible_any // 隐式转换检查
{
    static constexpr bool value = (false || ... || std::is_convertible_v<Ts, T>);
};

struct A {
    explicit A(int) {}
    A(double) {}
};

struct B {};

int main() {
    // 检查 A 是否可从 int 或 double 构造
    static_assert(is_constructible_any<A, int, double>::value); // true
    // 检查 int 或 double 是否可隐式转换为 A
    static_assert(is_convertible_any<A, int, double>::value); // false，因为 explicit A(int) 阻止隐式转换，但 A(double) 允许隐式转换？实际上 is_convertible_v<int, A> 为 false，is_convertible_v<double, A> 为 true，所以整体为 true。
    // 但注意：is_convertible_v<double, A> 为 true，因为 A 有非 explicit 构造函数接受 double。
    // 具体取决于 A 的定义。如果 A(double) 是 non-explicit，则 is_convertible_v<double, A> 为 true。

    // 检查 B 是否可从 int 构造
    static_assert(!is_constructible_any<B, int>::value); // true
}
```

##### 示例13：展开映射tuple 、转换使用

* rebind技术
* 实现tuple_apply
* 实现tuple_map
* 实现tuple_cat（标准库提供，但是是方法传入变量名，我们实现是传入类型）
* 实现tuple_push_front
* 实现tuple_front
* 实现tuple_element（标准库提供）

```C++
// 示例11的类型萃取

template<template<class ...Ts> class Tmpl, class Tup>
struct tuple_apply
{ };

template<template<class... Ts> class Tmpl, class... Ts>
struct tuple_apply<Tmpl, std::tuple<Ts...>>
{
  using type = Tmpl<Ts...>;
};

template<template<class... Ts> class Tmpl, class... Ts>
struct tuple_apply<Tmpl, std::variant<Ts...>>
{
  using type = Tmpl<Ts...>;
};


/*
使用
using Tup = std::tuple<int, float, double>;
using Var = std::variant<int, float, double>;
using whatT = typename tuple_apply<std::tuple, Tup>::type;
using whatV = typename tuple_apply<std::variant, Var>::type;
*/

// template<template<class... Ts> class Tmpl, class... Ts>这样定义太麻烦，使用rebind技术简化模板参数
template<class Tmpl, class Tup>
struct tuple_apply
{ };

struct tupple_wrapper
{
  template<class... Ts>
  struct rebind
  {
    using type = std::tuple<Ts...>;
  };
};

template<class Tmpl, class... Ts>
struct tuple_apply<Tmpl, std::tuple<Ts...>>
{
  using type = typename Tmpl::template rebind<Ts...>::type;
};

using Tup = std::tuple<int, float, double>;
using whatT = typename tuple_apply<tupple_wrapper, Tup>::type;
```

根据这个思路我们可以给出，将类型转换为对应的`std::vector`、`std::array`

```C++
struct vector_wrapper
{
  template<class T>
  struct rebind
  {
    using type = std::vector<T>;
  };
};

template<class Tmpl, class Tup>
struct tuple_map
{ };

template<class Tmpl, class... Ts>
struct tuple_map<Tmpl, std::tuple<Ts...>>
{
  using type = std::tuple<typename Tmpl::template rebind<Ts>::type...>;
};

using whatV = tuple_map<vector_wrapper, Tup>::type; // vec<int>、vec<float>、vec<double>

/////////////////////////////
// 这是不重载的写法，重载写法，则需要是
// template<class T, size_t N> struct array_wrapper {template<class T>}
// 然后保持tuple_map 的rebind调用仅需要出传入一个参数和上面vector一样
struct array_wrapper
{
  template<class T, size_t N>
  struct rebind
  {
    using type = std::array<T, N>;
  };
};

template<class Tmpl, class Tup>
struct tuple_map
{ };

template<class Tmpl, class... Ts>
struct tuple_map<Tmpl, std::tuple<Ts...>>
{
  using type = std::tuple<typename Tmpl::template rebind<Ts, std::tuple_size_v<std::tuple<Ts...>>>::type...>;
};
/*using whatA = tuple_map<array_wrapper, Tup>::type;*/
```

标准库提供了`std::tuple_cat`，但是它是一个函数，仅接收`tuple`变量名，我们实现一个可以根据类型合并的模板

```C++
template<class Tup1, class Tup2>
struct tuple_cat
{ };

template<class... T1s, class... T2s>
struct tuple_cat<std::tuple<T1s...>, std::tuple<T2s...>>
{
  using type = std::tuple<T1s..., T2s...>;
};
/*using whatC = tuple_cat<Tup, whatV>::type; // int、float、double、 vec<int>、vec<float>、vec<double>*/
```

实现`tuple_push_front`、`tuple_front`、`tuple_element`（标准库提供了`std::tuple_element`）

```C++
template<class T1, class Tup2>
struct tuple_push_front
{ };

template<class T1, class... T2s>
struct tuple_push_front<T1, std::tuple<T2s...>>
{
  using type = std::tuple<T1, T2s...>;
};
/*using whatPF = tuple_push_front<char *, Tup>::type; */

template<class Tup>
struct tuple_front
{ };

template<class T0, class... Ts>
struct tuple_front<std::tuple<T0, Ts...>>
{
  using type = T0;
};

template<size_t I, class Tup>
struct tuple_element
{ };

template<class T0, class... Ts>
struct tuple_element<0, std::tuple<T0, Ts...>>
{
  using type = T0;
};

template<size_t N, class T0, class... Ts>
struct tuple_element<N, std::tuple<T0, Ts...>>
{
  using type = typename tuple_element<N - 1, std::tuple<Ts...>>::type;
};
```

##### 示例14：`std::variant`

```cpp
template <class ...Ts>
struct variant
{
private:
	size_t m_index;
	// 手动定义内联体
	alignas(std::max({alignof(Ts)...})) char m_union[std::max({sizeof(Ts)...})];
	
	// 每个类型的析构，使用数组函数指针存储析构的lambda
	inline static void (*destructors[sizeof...(Ts)])(char *) noexcept {
		[] (char *m_union) noexcept {
			reinterpret_cast<Ts*>(m_union)->~Ts();
		}...
	};
}
```



#### 2.3.8 注意事项与最佳实践

> 1. **结合律与折叠方向**：
>    - 对于满足结合律的运算符（如加法、乘法），一元左折叠和一元右折叠的结果相同
>    - 对于不满足结合律的运算符（如减法、除法），不同折叠方式会产生不同结果
>
> 2. **空参数包的处理**：
>    - 一元折叠要求参数包至少包含一个参数（空参数包会导致编译错误）
>    - 二元折叠可以处理空参数包，此时表达式的结果就是初始值
>
> 3. **类型一致性**：
>    - 使用初始化列表时，所有元素必须具有相同类型或可转换为相同类型
>    - 对于混合类型，使用`std::common_type_t`获取公共类型
>
> 4. **性能考虑**：
>    - 折叠表达式在编译时展开，运行时无额外开销
>    - 初始化列表可能涉及拷贝，对于大对象需谨慎使用
>
> 5. **现代C++特性**：
>    - C++17折叠表达式大大简化了参数包处理
>    - C++20概念和约束提供了更好的类型安全
>    - C++20包展开捕获简化了lambda表达式的参数捕获

**1. 操作符的选择**

选择合适的操作符（`op`）对于实现正确的折叠行为至关重要。确保所选的操作符符合所需的逻辑和计算需求。

**2. 操作符的结合性**

不同的操作符具有不同的结合性（左结合、右结合）。了解操作符的结合性有助于选择正确的折叠方向（左折叠或右折叠）。

**3. 参数包的初始化**

在二元折叠表达式中，有时需要一个初始值（`init`）。这主要用于确保折叠的正确性，尤其在参数包可能为空的情况下。

**示例**：

```cpp
#include <iostream>
#include <numeric>

template<typename... Args>
auto sumWithInit(int init, Args... args) {
    return (init + ... + args); // 左折叠
}

int main() {
    std::cout << sumWithInit(10, 1, 2, 3) << std::endl; // 输出：16 (10 + 1 + 2 + 3)
    return 0;
}
```

**4. 参数包为空的情况**

如果参数包为空，折叠表达式的结果取决于折叠的类型和初始值。合理设置初始值可以避免潜在的错误。

**示例**：

```cpp
#include <iostream>

// 求和函数，如果参数包为空返回0
template<typename... Args>
auto sum(Args... args) {
    return (0 + ... + args); // 左折叠，初始值为0
}

int main() {
    std::cout << sum(1, 2, 3) << std::endl; // 输出：6
    std::cout << sum() << std::endl;        // 输出：0
    return 0;
}
```

**5. 与递归模板的比较**

折叠表达式在处理可变参数模板时，比传统的递归模板方法更简洁、易读且易于维护。然而，理解折叠表达式的基本原理和语法对于充分利用其优势至关重要。

**6. 编译器支持**

确保所使用的编译器支持C++17或更高标准，因为折叠表达式是在C++17中引入的。常见的支持C++17的编译器包括：

- **GCC**：从版本7开始支持C++17，其中完整支持在后续版本中得到增强。
- **Clang**：从版本5开始支持C++17。
- **MSVC（Visual Studio）**：从Visual Studio 2017版本15.7开始提供较全面的C++17支持。

**7. 性能考虑**

折叠表达式本身并不引入额外的性能开销。它们是在编译时展开的，生成的代码与手动展开参数包时的代码几乎相同。然而，编写高效的折叠表达式仍然需要理解所应用操作符的性能特性。

#### 2.3.9 总结示例使用代码

```c++
#include <iostream>
#include <string>
#include <vector>

// 一元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename... Args>
auto unary_left_fold(Args... args) {
    return (... + args); // 展开为 ((arg1 + arg2) + ...) + argN
}

// 一元右折叠：(arg1 op (arg2 op (... op argN)))
template<typename... Args>
auto unary_right_fold(Args... args) {
    return (args + ...); // 展开为 arg1 + (arg2 + (... + argN))
}

// 二元左折叠：((((init op arg1) op arg2) op ...) op argN)
template<typename Init, typename... Args>
auto binary_left_fold(Init init, Args... args) {
    return (init + ... + args); // 展开为 (((init + arg1) + arg2) + ...) + argN
}

// 二元右折叠：(arg1 op (arg2 op (... op (argN op init))))
template<typename Init, typename... Args>
auto binary_right_fold(Init init, Args... args) {
    return (args + ... + init); // 展开为 arg1 + (arg2 + (... + (argN + init)))
}

// 打印参数包内容的辅助函数
template<typename T>
void print_arg(T arg) {
    std::cout << arg << " ";
}

template<typename... Args>
void print_all(Args... args) {
    (print_arg(args), ...); // 使用逗号运算符的一元右折叠
    std::cout << std::endl;
}

int main() {
    std::cout << "=== 折叠表达式示例 ===" << std::endl;
    
    // 一元左折叠
    std::cout << "一元左折叠 (1+2+3+4): " << unary_left_fold(1, 2, 3, 4) << std::endl;
    
    // 一元右折叠
    std::cout << "一元右折叠 (1+2+3+4): " << unary_right_fold(1, 2, 3, 4) << std::endl;
    
    // 二元左折叠
    std::cout << "二元左折叠 (10+1+2+3+4): " << binary_left_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 二元右折叠
    std::cout << "二元右折叠 (1+2+3+4+10): " << binary_right_fold(10, 1, 2, 3, 4) << std::endl;
    
    // 使用折叠表达式打印所有参数
    std::cout << "打印所有参数: ";
    print_all(1, 2.5, "Hello", 'A');
    
    // 对于加法，左右折叠结果相同（加法满足结合律）
    std::cout << "\n=== 减法示例（展示结合顺序的区别）===" << std::endl;
    
    // 一元左折叠减法：(((10-1)-2)-3)
    auto left_sub = [](auto... args) { return (args - ...); };
    std::cout << "一元左折叠减法 (10-1-2-3): " << left_sub(10, 1, 2, 3) << std::endl;
    
    // 一元右折叠减法：(10-(1-(2-3)))
    auto right_sub = [](auto... args) { return (... - args); };
    std::cout << "一元右折叠减法 (10-1-2-3): " << right_sub(10, 1, 2, 3) << std::endl;
    
    // 二元左折叠减法：((((100-10)-1)-2)-3)
    std::cout << "二元左折叠减法 (100-10-1-2-3): " << binary_left_fold(100, 10, 1, 2, 3) << std::endl;
    
    // 二元右折叠减法：(10-(1-(2-(3-100))))
    std::cout << "二元右折叠减法 (10-1-2-3-100): " << binary_right_fold(100, 10, 1, 2, 3) << std::endl;
    
    return 0;
}
```



## [3. SFINAE（Substitution Failure Is Not An Error）](https://www.bilibili.com/video/BV1yo4y1E73a/)

### 3.1 什么是SFINAE？

**SFINAE** 是 "Substitution Failure Is Not An Error"（替换失败不是错误）的缩写，是C++模板编程中的一个重要概念。它允许编译器在模板实例化过程中，如果在替换模板参数时失败（即不满足某些条件），不会将其视为编译错误，而是继续寻找其他可能的模板或重载。这一机制为条件编译、类型特性检测、函数重载等提供了强大的支持。

### 3.2 SFINAE的工作原理

在模板实例化过程中，编译器会尝试将模板参数替换为具体类型。如果在替换过程中出现不合法的表达式或类型，编译器不会报错，而是将该模板视为不可行的，继续尝试其他模板或重载。这一特性允许开发者根据类型特性选择不同的模板实现。

### 3.3 SFINAE的应用场景

1. **函数重载选择**：根据参数类型的不同选择不同的函数实现。
2. **类型特性检测**：检测类型是否具有某些成员或特性，从而决定是否启用某些功能。
3. **条件编译**：根据模板参数的特性决定是否编译某些代码段。

### 3.4 SFINAE的基本用法

SFINAE通常与`std::enable_if`、模板特化、以及类型萃取等技术结合使用。以下通过几个例子来说明SFINAE的应用。

#### 3.4.1 示例一：通过`std::enable_if`实现函数重载

```cpp
#include <type_traits>
#include <iostream>

// 适用于整数类型
template <typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print_type(T value) {
    std::cout << "Integral type: " << value << std::endl;
}

// 适用于浮点类型
template <typename T>
typename std::enable_if<std::is_floating_point<T>::value, void>::type
print_type(T value) {
    std::cout << "Floating point type: " << value << std::endl;
}

int main() {
    print_type(10);      // 输出: Integral type: 10
    print_type(3.14);    // 输出: Floating point type: 3.14
    // print_type("Hello"); // 编译错误，没有匹配的函数
    return 0;
}
```

**解释**：

- `std::enable_if` 根据条件 `std::is_integral<T>::value` 或 `std::is_floating_point<T>::value` 决定是否启用对应的函数模板。
- 当条件不满足时，该模板实例化失败，但由于SFINAE规则，编译器不会报错，而是忽略该模板，从而实现函数重载选择。

#### 3.4.2 示例二：检测类型是否具有特定成员

假设我们需要实现一个函数，仅当类型 `T` 具有成员函数 `foo` 时才启用该函数。

```cpp
#include <type_traits>
#include <iostream>

// 辅助类型，检测是否存在成员函数 foo
template <typename T>
class has_foo {
private:
typedef char yes[1];
typedef char no[2];

template <typename U, void (U::*)()>
struct SFINAE {};

template <typename U>
static yes& test(SFINAE<U, &U::foo>*);

template <typename U>
static no& test(...);

public:
static constexpr bool value = sizeof(test<T>(0)) == sizeof(yes);
};

// 函数仅在 T 有 foo() 成员时启用
template <typename T>
typename std::enable_if<has_foo<T>::value, void>::type
call_foo(T& obj) {
    obj.foo();
    std::cout << "foo() called." << std::endl;
}

class WithFoo {
public:
void foo() { std::cout << "WithFoo::foo()" << std::endl; }
};

class WithoutFoo {};

int main() {
    WithFoo wf;
    call_foo(wf); // 输出: WithFoo::foo() \n foo() called.

    // WithoutFoo wf2;
    // call_foo(wf2); // 编译错误，没有匹配的函数
    return 0;
}
```

**解释**：

- `has_foo` 是一个类型萃取类，用于检测类型 `T` 是否具有成员函数 `foo`。
- `call_foo` 函数模板仅在 `T` 具有 `foo` 成员时启用。
- 对于不具有 `foo` 成员的类型，编译器会忽略 `call_foo`，从而避免编译错误。

#### 3.4.3 示例三：通过模板特化实现不同的行为

以下是完整的、正确实现 `TypePrinter` 的代码示例：

```cpp
#include <type_traits>
#include <iostream>

// 1. 定义一个 Trait 用于检测 T 是否有非 void 的 `value_type`
template <typename T, typename = void>
struct has_non_void_value_type : std::false_type {};

// 仅当 T 有 `value_type` 且 `value_type` 不是 void 时，特化为 std::true_type
template <typename T>
struct has_non_void_value_type<T, std::enable_if_t<!std::is_void_v<typename T::value_type>>> : std::true_type {};

// 2. 定义 TypePrinter 主模板，使用一个布尔参数控制特化
template <typename T, bool HasValueType = has_non_void_value_type<T>::value>
struct TypePrinter;

// 3. 特化：当 HasValueType 为 true 时，表示 T 有非 void 的 `value_type`
template <typename T>
struct TypePrinter<T, true> {
    static void print(){
        std::cout << "T has a member type 'value_type'." << std::endl;
    }
};

// 特化：当 HasValueType 为 false 时，表示 T 没有 `value_type` 或 `value_type` 是 void
template <typename T>
struct TypePrinter<T, false> {
    static void print(){
        std::cout << "hello world! T does not have a member type 'value_type'." << std::endl;
    }
};

// 测试结构体
struct WithValueType{
    using value_type = int;
};

struct WithoutValueType{};

struct WithVoidValueType{
    using value_type = void;
};

int main() {
    TypePrinter<WithValueType>::print();        // 输出: T has a member type 'value_type'.
    TypePrinter<WithoutValueType>::print();     // 输出: hello world! T does not have a member type 'value_type'.
    TypePrinter<WithVoidValueType>::print();    // 输出: hello world! T does not have a member type 'value_type'.
    return 0;
}
```

**代码解释**

1. **Trait** `has_non_void_value_type`:
   - **主模板**：默认情况下，`has_non_void_value_type<T>` 继承自 `std::false_type`，表示 `T` 没有 `value_type` 或 `value_type` 是 `void`。
   - **特化模板**：仅当 `T` 有 `value_type` 且 `value_type` 不是 `void` 时，`has_non_void_value_type<T>` 继承自 `std::true_type`。

2. `TypePrinter` **模板**:
   - **主模板**：接受一个类型 `T` 和一个布尔模板参数 `HasValueType`，默认为 `has_non_void_value_type<T>::value`。
   - **特化版本** `TypePrinter<T, true>`：当 `HasValueType` 为 `true` 时，表示 `T` 有非 `void` 的 `value_type`，提供相应的 `print` 实现。
   - **特化版本** `TypePrinter<T, false>`：当 `HasValueType` 为 `false` 时，表示 `T` 没有 `value_type` 或 `value_type` 是 `void`，提供默认的 `print` 实现。

3. **测试结构体**：
   - `WithValueType`：有一个非 `void` 的 `value_type`。
   - `WithoutValueType`：没有 `value_type`。
   - `WithVoidValueType`：有一个 `value_type`，但它是 `void`。

4. `main` **函数**：
   - 分别测试了三种情况，验证 `TypePrinter` 的行为是否符合预期。

### 3.5 SFINAE的两种常见写法

在SFINAE实践中，有两种常见的写法：`typename = std::enable_if_t<...>`和`std::enable_if_t<..., int> = 0`。这两种写法都是使用SFINAE的常见方式，但它们有一些关键区别。

#### 3.5.1 语法区别

##### 3.5.1.1 第一种：使用类型参数默认值

```cpp
template <typename U, typename /*C++14特性这里可以省略一个名字*/ = std::enable_if_t<is_compatible_v<U>>>
```

- 第二个参数是类型参数
- 给它一个默认类型（`std::enable_if_t<...>`）
- `std::enable_if_t`默认返回`void`
- 当条件为`false`时，`std::enable_if_t`没有`type`成员，导致替换失败
- 参数名通常省略，因为它只是用于SFINAE

**特点**：

- 简单易写
- 但**不适用于函数重载**（因为默认模板参数不影响函数签名）

##### 3.5.1.2 第二种：使用非类型参数

```cpp
template <typename U, typename std::enable_if_t<is_compatible_v<U>, int> = 0>

template<typename T, typename std::enable_if_t<std::is_same_v<std::decay_t<T>, int>, void*> = nullptr>
```

- 第二个参数是非类型参数
- 类型是`std::enable_if_t<...>`
- 默认值是`0`
- 当条件为`false`时，替换失败

**特点**：

- `= 0` 或 `= nullptr` 是默认值
- **条件为 false 时，模板参数类型不存在，触发 SFINAE**
- 常使用 `int` 或 `void*` 作为默认类型，因为它们可以有合理的默认值

##### 3.5.1.3 第三种：作为返回值

```C++
template<typename T>
std::enable_if_t<std::same_as<std::decay_t<T>, int>, T> printx(T&& t)
{
  return t;
}
```

* 第一个参数是判断是否类型相等
* 第二个参数`T`是函数的返回值，默认是void

**特点**：

- 直接控制函数的返回类型
- 条件为 false 时，函数模板不存在（SFINAE）

和第二种大差不差

#### 3.5.2 为什么可以这样写？

##### 3.5.2.1 `typename = std::enable_if_t<...>`

- `typename`声明一个类型模板参数
- `=`给这个参数提供默认值
- 当`std::enable_if_t<condition>`有效时，它产生一个类型（默认是`void`）
- 示例：

```cpp
// 当 is_compatible_v<U> 为 true 时
template <typename U, typename = void>
// 当为 false 时，std::enable_if_t 无效，触发 SFINAE
```

##### 3.5.2.2 `std::enable_if_t<...> = 0`

- 这里定义了一个非类型模板参数
- 参数类型是`std::enable_if_t<condition>`
- `= 0`给这个参数默认值
- **关键**：`std::enable_if_t<true>`产生`void`，但`void = 0`是无效的！
- 实际上，这通常写成：

```cpp
template <typename U, std::enable_if_t<is_compatible_v<U>, int> = 0>
// 或者
template <typename U, std::enable_if_t<is_compatible_v<U>, bool> = true>
```

#### 3.5.3 为什么赋值`0`？

赋值`0`（或其他值）的原因：

- 非类型模板参数必须有默认值（如果你希望它是可选的）
- 对于整数类型（如`int`、`std::size_t`），`0`是常见的默认值
- 对于布尔类型，常用`true`或`false`

#### 3.5.4 正确用法示例

```cpp
// 使用 int 作为非类型参数类型
template <typename U, 
          std::enable_if_t<is_compatible_v<U>, int> = 0>
void func(U u) { /* ... */ }

// 使用 bool
template <typename U,
          std::enable_if_t<is_compatible_v<U>, bool> = true>
void func(U u) { /* ... */ }
```

#### 3.5.5 实际使用中的问题

##### 3.5.5.1 第一种写法的问题（产生相同签名）

```cpp
template <typename U, typename = std::enable_if_t<is_compatible_v<U>>>
void func(U u) { /* ... */ }
```

- 不同SFINAE条件会产生相同的函数签名
- 可能导致重定义错误
- 原因：因为`std::enable_if_t`默认是返回void
- 示例：

```cpp
template <typename U, typename = std::enable_if_t<is_compatible_v<U>>>
void func(U u) {}

template <typename U, typename = std::enable_if_t<is_other_v<U>>>
void func(U u) {}  // 错误：重定义，签名相同
```

看起来不同，但实际上在编译器看来**签名完全相同**：

1. 两个模板都有两个类型模板参数
2. 第二个模板参数都有默认值
3. 函数参数都是 `U&& u`

**默认模板参数不影响函数签名**，所以编译器认为这两个函数模板是同一个，从而产生重定义错误。

##### 3.5.5.2 第二种写法更好

```cpp
template <typename U, 
          std::enable_if_t<is_compatible_v<U>, int> = 0>
void func(U u) {}

template <typename U,
          std::enable_if_t<is_other_v<U>, int> = 0>
void func(U u) {}  // OK：不同的非类型参数类型
```

##### 3.5.5.3 第三种写法

保留第二种写法能够解决签名相同的问题，也能够处理函数返回值类型

```C++
template<typename T>
std::enable_if_t<std::same_as<std::decay_t<T>, int>, T> 
printx(T&& t)
{
  return t;
}

template<typename T>
std::enable_if_t<std::same_as<std::decay_t<T>, std::string>, T>
printx(T&& t)
{
  return t;
}
```

#### 3.5.6 SFINAE使用无法获取变量构造解决办法

我们无法使用`t`变量进行，`t.toString()`，所以可能需要构造一个对象，比如`t().toString()`，但是T类型可能没有默认构造或者默认构造被删除，使用`std::declval<T>()`进行**声明**一个对象，它被包裹在`decltype()`中，是**未求值上下文**，没有实际内存分配或构造，仅仅是声明该类型，进行判断类型下是否存在某一个变量或者某一方法

```C++
template<typename T>
requires (std::same_as<decltype(std::declval<std::decay_t<T>>().toString()),
                       std::string>)
void print(T&& t)
{
}
```

在C++20中可以解决这个问题

#### 3.5.7 现代C++的替代方案

C++17/20提供了更好的方式：

##### 3.5.7.1 C++17: `if constexpr`

```cpp
template <typename U>
void func(U u) {
    if constexpr (is_compatible_v<U>) {
        // 兼容的代码
    } else {
        // 或不处理
    }
}
```

##### 3.5.7.2 C++20: Concepts（解决无法获取变量）

```cpp
template <typename U>
requires is_compatible_v<U>
void func(U u) { /* ... */ }

// 或者
template <is_compatible U>
void func(U u) { /* ... */ }

// 解决无法获取变量
template <class U>
requires (requires (F f) { f() -> std::void; })
void func(U u) { /* ... */ }
```

#### 3.5.8 SFINAE案例

##### 3.5.8.1 检测函数返回类型、签名、参数

* 类似的有`std::invoke_result_t`、`std::is_invocable_v`、`std::is_invocable_r_v`检测函数是否可调用

```C++
// 主模板
template<typename Class, typename ReturnType, typename FuncPtr,
         typename... Args>
struct is_has_function : std::false_type
{ };

// 检测函数签名
template<typename Class, typename ReturnType, typename... Args>
struct is_has_function<Class, ReturnType, ReturnType (Class::*)(Args...),
                       Args...> : std::true_type
{ };

// 检测const版本
template<typename Class, typename ReturnType, typename... Args>
struct is_has_function<Class, ReturnType, ReturnType (Class::*)(Args...) const,
                       Args...> : std::true_type
{ };

template<typename Class, typename ReturnType, typename FuncPtr,
         typename... Args>
inline constexpr bool is_has_function_v =
    is_has_function<Class, ReturnType, FuncPtr, Args...>::value;

struct MyClass
{
  int a;

  void serialize() const { std::cout << "Serializing MyClass\n"; }

  void setA(int a) { this->a = a; }

  int getA() const { return a; }

  std::string toString() const { return std::to_string(a); }
};

int main()
{
  MyClass myclass { .a = 1 };

  constexpr bool has_serialize =
      is_has_function_v<MyClass, void,
                        decltype(&MyClass::serialize())>;
  constexpr bool has_setA =
      is_has_function_v<MyClass, void, decltype(&MyClass::setA), int>;
  constexpr bool has_getA =
      is_has_function_v<MyClass, int, decltype(&MyClass::getA)>;
}
```

##### 3.5.8.2 无法知道函数名字情况

* 使用宏进行代码生成，防止SFINAE类型名相同，导致后续定义的被覆盖

```C++
#define DEFINE_HAS_FUNCTION(function_name)                                \
  template<typename T, typename Signature, typename = void>               \
  struct has_##function_name : std::false_type                            \
  { };                                                                    \
                                                                          \
  template<typename T, typename Ret, typename... Args>                    \
  struct has_##                                                           \
      function_name<T, Ret(Args...),                                      \
                    std::void_t<decltype(std::declval<T>().function_name( \
                        std::declval<Args>()...))>>                       \
      : std::is_same<decltype(std::declval<T>().function_name(            \
                         std::declval<Args>()...)),                       \
                     Ret>                                                 \
  { };                                                                    \
                                                                          \
  template<typename T, typename Signature>                                \
  inline constexpr bool has_##function_name##_v =                         \
      has_##function_name<T, Signature>::value;

DEFINE_HAS_FUNCTION(serialize)
DEFINE_HAS_FUNCTION(setA)
DEFINE_HAS_FUNCTION(getA)
    
int main()
{
  constexpr bool has_serialize =
      has_serialize_v<MyClass, void()>;

  constexpr bool has_setA_int = has_setA_v<MyClass, void(int)>;

  constexpr bool has_getA = has_getA_v<MyClass, int()>;
}
```



#### 3.5.9 总结

| 特性     | `typename = enable_if_t<...>` | `enable_if_t<..., int> = 0` |
| -------- | ----------------------------- | --------------------------- |
| 参数类型 | 类型参数                      | 非类型参数                  |
| 默认值   | 类型默认值                    | 值默认值                    |
| 重载区分 | 不好区分                      | 可以区分                    |
| 常见问题 | 容易导致重定义                | 需要指定具体类型            |

**建议**：使用第二种形式，并明确指定类型（如`int`或`bool`），以避免重载冲突问题。

### 3.6 SFINAE的优缺点

#### 3.6.1 优点

1. **灵活性高**：能够根据类型特性选择不同的实现，提升代码的泛化能力。
2. **类型安全**：通过编译期检测，避免了运行时错误。
3. **无需额外的运行时开销**：所有的类型筛选都在编译期完成。

#### 3.6.2 缺点

1. **复杂性高**：SFINAE相关的代码往往较为复杂，阅读和维护难度较大。
2. **编译器错误信息难以理解**：SFINAE失败时，编译器可能给出晦涩的错误信息，调试困难。
3. **模板实例化深度限制**：过度使用SFINAE可能导致编译时间增加和模板实例化深度限制问题。

### 3.7 现代C++中的替代方案

随着C++11及后续标准的发展，引入了诸如`decltype`、`constexpr`、`if constexpr`、概念（C++20）等新的特性，部分情况下可以替代传统的SFINAE，提高代码的可读性和可维护性。例如，C++20引入的**概念（Concepts）**提供了更为简洁和直观的方式来约束模板参数，减少了SFINAE的复杂性。

#### 3.7.1 示例：使用概念替代SFINAE

```cpp
#include <concepts>
#include <iostream>

// 定义一个概念，要求类型 T 是整数类型
template <typename T>
concept Integral = std::is_integral_v<T>;

// 仅当 T 满足 Integral 概念时启用
template <Integral T>
void print_type(T value) {
    std::cout << "Integral type: " << value << std::endl;
}

int main() {
    print_type(42);        // 输出: Integral type: 42
    // print_type(3.14);   // 编译错误，不满足 Integral 概念
    return 0;
}
```

#### 3.7.2 示例：使用`std::void_t`简化`has_foo`

```cpp
#include <type_traits>
#include <iostream>

// 使用 std::void_t 简化 has_foo
template <typename, typename = std::void_t<>>
struct has_foo : std::false_type {};

template <typename T>
struct has_foo<T, std::void_t<decltype(std::declval<T>().foo())>> : std::true_type {};

// 函数仅在 T 有 foo() 成员时启用
template <typename T>
std::enable_if_t<has_foo<T>::value, void>
call_foo(T& obj) {
    obj.foo();
    std::cout << "foo() called." << std::endl;
}

class WithFoo {
public:
    void foo() { std::cout << "WithFoo::foo()" << std::endl; }
};

class WithoutFoo {};

int main() {
    WithFoo wf;
    call_foo(wf); // 输出: WithFoo::foo()
                   //      foo() called.

    // WithoutFoo wf2;
    // call_foo(wf2); // 编译错误，没有匹配的函数
    return 0;
}
```

#### 3.7.3 使用C++20概念

如果你使用的是支持C++20的编译器，可以利用概念（Concepts）进一步简化和增强可读性。

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// 定义一个概念，要求类型 T 具有 void foo()
template <typename T>
concept HasFoo = requires(T t) {
    { t.foo() } -> std::same_as<void>;
};

// 仅当 T 满足 HasFoo 概念时启用
template <HasFoo T>
void call_foo(T& obj) {
    obj.foo();
    std::cout << "foo() called." << std::endl;
}

class WithFoo {
public:
    void foo() { std::cout << "WithFoo::foo()" << std::endl; }
};

class WithoutFoo {};

int main() {
    WithFoo wf;
    call_foo(wf); // 输出: WithFoo::foo()
                   //      foo() called.

    // WithoutFoo wf2;
    // call_foo(wf2); // 编译错误，不满足 HasFoo 概念
    return 0;
}
```

### 3.8 SFINAE 和 偏特化的区别联系

#### 3.8.1 区别联系优缺点对比

区别与联系

- 偏特化是模板的一种特化形式，用于类模板，它根据模板参数的模式来选择不同的实现。
- SFINAE是一种利用模板替换失败来指导重载解析的技术，常用于函数模板和类模板的成员函数。
- 两者都可以用于类型特性的判断，但偏特化更直接，而SFINAE更灵活，可以用于更复杂的条件。
- 偏特化通常用于类模板，而SFINAE可以用于函数模板和类模板的成员函数。

用偏特化和SFINAE实现判断指针类型的优缺点

- 偏特化实现：
  优点：直观，易于理解，编译效率高。
  缺点：只能用于类模板，对于函数模板则无法使用偏特化（但可以通过重载模拟）。
- SFINAE实现：
  优点：非常灵活，可以用于复杂的条件判断，并且可以用于函数模板。
  缺点：代码可能晦涩难懂，编译错误信息不友好，编译时间可能较长。

#### 3.8.2 使用二者进行是西安判断类型是否是指针

##### 3.8.2.1 偏特化

```C++
#include <iostream>
#include <type_traits>

// 主模板：默认不是指针
template<typename T>
struct is_pointer_impl {
    static constexpr bool value = false;
};

// 偏特化：当T是指针类型时
template<typename T>
struct is_pointer_impl<T*> {
    static constexpr bool value = true;
};

template<typename T>
struct is_pointer_impl<T* const> {
    static constexpr bool value = true;
};

template<typename T>
struct is_pointer_impl<T* volatile> {
    static constexpr bool value = true;
};

template<typename T>
struct is_pointer_impl<T* const volatile> {
    static constexpr bool value = true;
};

// 变量模板
template<typename T>
inline constexpr bool is_pointer_v = is_pointer_impl<T>::value;

// 测试
struct MyClass {};

int main() {
    std::cout << std::boolalpha;
    std::cout << "int: " << is_pointer_v<int> << std::endl;               // false
    std::cout << "int*: " << is_pointer_v<int*> << std::endl;             // true
    std::cout << "int**: " << is_pointer_v<int**> << std::endl;           // true
    std::cout << "const int*: " << is_pointer_v<const int*> << std::endl; // true
    std::cout << "MyClass*: " << is_pointer_v<MyClass*> << std::endl;     // true
    return 0;
}
```

##### 3.8.2.2 SFINAE

```C++
#include <iostream>
#include <type_traits>

// 方法1：使用void_t和decltype
template<typename T, typename = void>
struct is_pointer_sfinae : std::false_type {};

template<typename T>
struct is_pointer_sfinae<T, 
    std::void_t<decltype(*std::declval<T>()),
                decltype(std::declval<T>() == nullptr),
                decltype(++std::declval<T&>()),
                decltype(--std::declval<T&>())>>
    : std::true_type {};

// 方法2：更简洁的SFINAE
template<typename T>
struct is_pointer_sfinae2 {
private:
    template<typename U>
    static std::true_type test(U*);
    
    template<typename U>
    static std::false_type test(...);
    
public:
    static constexpr bool value = decltype(test<T>(nullptr))::value;
};

// 变量模板
template<typename T>
inline constexpr bool is_pointer_sfinae_v = is_pointer_sfinae<T>::value;

template<typename T>
inline constexpr bool is_pointer_sfinae2_v = is_pointer_sfinae2<T>::value;

// 测试
int main() {
    std::cout << std::boolalpha;
    std::cout << "int: " << is_pointer_sfinae_v<int> << std::endl;     // false
    std::cout << "int*: " << is_pointer_sfinae_v<int*> << std::endl;   // true
    
    std::cout << "int: " << is_pointer_sfinae2_v<int> << std::endl;    // false
    std::cout << "int*: " << is_pointer_sfinae2_v<int*> << std::endl;  // true
    return 0;
}
```



### 3.9 总结

SFINAE作为C++模板编程中的一项强大功能，通过在模板实例化过程中允许替换失败而不报错，实现了基于类型特性的编程。然而，SFINAE的语法复杂且难以维护，现代C++引入的新特性如概念等在某些情况下已经能够更简洁地实现类似的功能。尽管如此，理解SFINAE的工作机制依然对于掌握高级模板技术和阅读老旧代码具有重要意义。

对于SFINAE的两种常见写法，建议使用`std::enable_if_t<..., int> = 0`这种形式，并明确指定类型（如`int`或`bool`），以避免重载冲突问题。同时，随着C++20的普及，更推荐使用Concepts来替代SFINAE，以获得更好的可读性和维护性。

## 4. 高级模板特性

### 4.1 C++20 Concepts

C++20 引入了 **Concepts**，它们为模板参数提供了更强的约束和表达能力，使模板的使用更简洁、错误信息更友好。

#### 4.1.1 定义与使用

**定义一个 Concept**

Concepts 使用 `concept` 关键字定义，并作为函数或类模板的约束。

```cpp
#include <concepts>
#include <iostream>

// 定义一个 Concept：要求类型必须是可输出到 std::ostream
template <typename T>
concept Printable = requires(T a) {
{ std::cout << a } -> std::same_as<std::ostream&>;
};

// 使用 Concepts 约束函数模板
template <Printable T>
void print(const T& value) {
    std::cout << value << std::endl;
}

int main() {
    print(42);          // 正常调用
    print("Hello");     // 正常调用
    // print(std::vector<int>{1, 2, 3}); // 编译错误，std::vector<int> 不满足 Printable
    return 0;
}
```

#### 4.1.2 限制与约束

Concepts 允许为模板参数定义复杂的约束，使得模板更具表达性，同时提升编译器错误信息的可理解性。

**示例：排序函数中的 Concepts**

```cpp
#include <concepts>
#include <vector>
#include <iostream>
#include <algorithm>

// 定义一个可比较的概念
template <typename T>
concept Comparable = requires(T a, T b) {
{ a < b } -> std::convertible_to<bool>;
};

// 排序函数，约束类型必须可比较
template <Comparable T>
void sortVector(std::vector<T>& vec) {
    std::sort(vec.begin(), vec.end());
}

int main() {
    std::vector<int> nums = {4, 2, 3, 1};
    sortVector(nums);
    for(auto num : nums)
        std::cout << num << " "; // 输出：1 2 3 4 
    std::cout << std::endl;

    // std::vector<std::vector<int>> vecs;
    // sortVector(vecs); // 编译错误，std::vector<int> 不满足 Comparable
    return 0;
}
```

#### 4.1.3 requires子句

```C++
template<class T>
bool gench(T t)
{
  constexpr bool is_has_rebel = requires (int i) { t.rebel(i); };
  if constexpr (requires { t.dismantle(); }) {
    t.dismantle();
  } else if constexpr (is_has_rebel) {
    for (int i = 1; i <= 4; ++i) {
      t.rebel(i);
    }
  } else {
    printf("no any method supported!\n");
  }
  return XX;
}
```



### 4.2 高级模板元编程技巧

#### 4.2.1 类型列表和元素访问

```cpp
// 定义类型列表
template <typename... Ts>
struct TypeList {};

// 获取类型列表中第N个类型
template <typename List, std::size_t N>
struct TypeAt;

template <typename Head, typename... Tail>
struct TypeAt<TypeList<Head, Tail...>, 0> {
using type = Head;
};

template <typename Head, typename... Tail, std::size_t N>
struct TypeAt<TypeList<Head, Tail...>, N> {
using type = typename TypeAt<TypeList<Tail...>, N - 1>::type;
};

// 使用
using list = TypeList<int, double, char>;
using third_type = TypeAt<list, 2>::type; // char
```

**讲解：**

1. `**TypeList**`：定义一个包含多个类型的类型列表。
2. `TypeAt`：通过递归模板，从`TypeList`中获取第N个类型。

- - 当N为0时，类型为`Head`。
  - 否则，递归获取`Tail...`中第N-1个类型。

1. **使用**：定义`list`为`TypeList<int, double, char>`，`third_type`为第2个类型，即`char`。

### 4.3 其他高级模板特性

#### 4.3.1 SFINAE (Substitution Failure Is Not An Error)

当模板参数匹配失败时，编译器会跳过该候选而非报错，常用于条件编译。

```cpp
#include <type_traits>

// 仅对整数类型生效
template <typename T>
auto add(T a, T b) -> std::enable_if_t<std::is_integral_v<T>, T> {
    return a + b;
}

add(3, 5);     // 编译通过
add(3.2, 5.1); // 编译错误：无匹配函数
```

#### 4.3.2 C++20 约束与概念 (Concepts)

简化 SFINAE，通过 `concept` 声明类型约束。

```cpp
template <typename T>
concept Integral = std::is_integral_v<T>;

template <Integral T> // 约束 T 必须是整数类型
T multiply(T a, T b) {
    return a * b;
}

multiply(4, 2);     // OK
// multiply(1.5, 2.0); // 错误：不满足约束
```

#### 4.3.3 参数包与完美转发

- **参数包 (Variadic Templates)**：处理任意数量参数
- **完美转发**：保持参数的值类别（左值/右值）

```cpp
// 递归展开参数包
void print() {} // 终止递归

template <typename First, typename... Rest>
void print(First&& first, Rest&&... rest) {
    std::cout << std::forward<First>(first) << " ";
    print(std::forward<Rest>(rest)...);
}

print("Hello", 42, 3.14); // 输出：Hello 42 3.14
```

#### 4.3.4 Lambda 定义匿名模板方法 (C++14+)

Lambda 支持泛型参数（`auto`），实现匿名模板函数。

```cpp
// 泛型 Lambda（C++14）
auto make_adder = [](auto x) {
    return [x](auto y) { return x + y; };
};

auto add5 = make_adder(5);
std::cout << add5(3);     // 输出 8 (int)
std::cout << add5(2.3);   // 输出 7.3 (double)
```

### 4.4 inline定义

**不使用** `**inline**`**（需要类外定义）**

```cpp
#include <utility>

// 编译期字符串
template <char... Cs>
struct String {
static constexpr char value[sizeof...(Cs) + 1] = { Cs..., '\0' };
};

// 外部定义
template <char... Cs>
constexpr char String<Cs...>::value[sizeof...(Cs) + 1];

// 使用
using hello = String<'H','e','l','l','o'>;

int main() {
    // 访问 value
    // std::cout << hello::value;
}
```

**使用** `**inline**`**（无需类外定义，C++17 起）**

```cpp
#include <utility>

// 编译期字符串
template <char... Cs>
struct String {
inline static constexpr char value[sizeof...(Cs) + 1] = { Cs..., '\0' };
};

// 使用
using hello = String<'H','e','l','l','o'>;

int main() {
    // 访问 value
    // std::cout << hello::value;
}
```

### 4.5 模板参数 或 返回值变量 约束

#### 模板参数约束

```C++
template<
    std::bidirectional_iterator BiIter,
    std::strict_weak_order<typename std::iter_value_t<BiIter>,
                           typename std::iterator_traits<BiIter>::value_type>
        Compare>
void insert_sort(BiIter start, BiIter end, Compare comp)
{
}

// 或者

void insert_sort(
    std::bidirectional_iterator auto start,
    std::bidirectional_iterator auto end,
    std::strict_weak_order<
        typename std::iter_value_t<decltype(start)>,
        typename std::iterator_traits<decltype(start)>::value_type> auto comp)
{
}
```



#### 返回值变量约束

```C++
auto func() { return std::declval<std::list<int>>().begin(); }

int main()
{
  std::bidirectional_iterator auto it = func(); // OK
  std::random_access_iterator auto it = func(); // Error
}
```



## 5. 关键特性对比与总结

### 5.1 关键特性对比

| 特性         | 用途              | 示例                           |
| ------------ | ----------------- | ------------------------------ |
| **函数模板** | 通用算法          | `sort(vec.begin(), vec.end())` |
| **SFINAE**   | 条件编译          | `std::enable_if`               |
| **Concepts** | 类型约束（C++20） | `requires std::integral<T>`    |
| **参数包**   | 处理不定参数      | `std::make_shared<T>(args...)` |
| **完美转发** | 保持值类别        | `std::forward<T>(arg)`         |

### 5.2 参考书籍

1. **《C++ Primer》第5版**
2. **《Effective Modern C++》**
3. **《C++ Templates: The Complete Guide》**

## 6. 杂

### 6.1 元组 参数包 解包 存储形参（`std::thread`的实现）

> [std::thread](./并发支持库.md)
>
> [std::tuple](./通用工具库.md)	
>
> [std::invoke](./通用工具库.md)	
>
> [std::invocable](./概念库.md)	

```c
#include <tuple>
#include <iostream>
template <typename _Func, typename... _Args>
requires std::invocable<_Func, _Args...>
struct Input {
    using R = std::invoke_result_t<_Func, _Args...>;
    _Func _func;
    std::tuple<_Args...> _values;

    Input(_Func&& func, _Args&&... args) : _func(std::forward<_Func>(func)), _values(std::forward<_Args>(args)...) {}
    constexpr R operator()() const noexcept {
        return std::apply([&](auto&&... args) { return _func(args...); }, _values);
    }
};
int main() {
    Input input([](int a, int b) { return a + b; }, 1, 2);
    input();
    std::cout << std::get<0>(input._values) << std::endl;
    return 0;
}
```

### 6.2 弃置函数禁用隐式转换

利用模板匹配有限的特性

```CPP
void f(int){}

struct X{
    operator int()const { return 0; }
};
struct Y {
    operator double()const { return 0.; }
};

template<typename T>
void f(T) = delete;	//使用弃置函数禁止隐式转换

// void f(auto) = delete; // C++20 起 模板简化
// void f(std::same_as<int> auto) // C++20 起 概念

int main(){
    f(1);               // int
    f(1u);              // unsigned int
    f(1l);              // long
    f(1ll);             // long long
    f(1lu);             // unsigned long
    f(1llu);            // unsigned long long
    f(1.);              // double
    f(1.f);             // float
    f('c');             // char
    f(std::uint8_t{});  // unsigned char
    f(std::int8_t{});   // signed char
    f(X{});             // X
    f(Y{});             // Y
}
```

### 6.3 不要将成员函数模板声明为虚函数

在类模板中，非虚函数仅在被使用时才会被实例化——但虚函数每次都会被实例化。这会膨胀代码大小，并且可能通过实例化不需要的功能而过度限制通用类型。避免这种情况，尽管标准库的 facet 犯了这个错误。

```c++
#include <locale>
#include <iostream>

// 标准库中的 facet（例如 numpunct）确实有这个问题
template <class CharT>
class MyFacet : public std::locale::facet {
public:
    static std::locale::id id;  // facet 需要这个 ID
    
    // 虚函数 - 总是会被实例化
    virtual std::basic_string<CharT> grouping() const {
        return std::basic_string<CharT>();
    }
    
    virtual CharT decimal_point() const {
        return CharT('.');
    }
    
    virtual CharT thousands_sep() const {
        return CharT(',');
    }
    
    // 非虚函数 - 按需实例化
    CharT get_separator() const {
        return thousands_sep();
    }
};

template <class CharT>
std::locale::id MyFacet<CharT>::id;

int main() {
    // 即使我们只使用 decimal_point，grouping() 和 thousands_sep() 也会被实例化
    MyFacet<char> facet;
    std::cout << facet.decimal_point() << std::endl;
    
    return 0;
}
```

解决CRTP

```c
// 基类模板，提供接口但不强制实现所有方法
template<typename Derived>
class CalculatorBase {
public:
    // 使用静态多态代替虚函数
    auto add(auto a, auto b) const {
        return static_cast<const Derived*>(this)->impl_add(a, b);
    }
    
    auto multiply(auto a, auto b) const {
        return static_cast<const Derived*>(this)->impl_multiply(a, b);
    }
};

// 具体的实现类
template<typename T>
class SimpleCalculator : public CalculatorBase<SimpleCalculator<T>> {
public:
    T impl_add(T a, T b) const {
        return a + b;
    }
    
    // 不实现 multiply，除非需要
    // 不会强制要求 T 支持乘法
};

// 专门为支持乘法的类型实现
template<typename T>
class FullCalculator : public CalculatorBase<FullCalculator<T>> {
public:
    T impl_add(T a, T b) const {
        return a + b;
    }
    
    T impl_multiply(T a, T b) const {
        return a * b;
    }
};
```

策略模式

```c++
// 将功能分离到策略类中
template<typename T, typename AddPolicy, typename MultiplyPolicy = void>
class Calculator {
    AddPolicy add_policy;
    
public:
    T add(T a, T b) {
        return add_policy(a, b);
    }
    
    // 条件编译：只有提供了 MultiplyPolicy 时才启用 multiply
    template<typename U = MultiplyPolicy>
    std::enable_if_t<!std::is_same_v<U, void>, T>
    multiply(T a, T b) {
        MultiplyPolicy policy;
        return policy(a, b);
    }
};

// 使用
struct IntAdd {
    int operator()(int a, int b) const { return a + b; }
};

struct IntMultiply {
    int operator()(int a, int b) const { return a * b; }
};

Calculator<int, IntAdd> calc1;        // 只有加法
Calculator<int, IntAdd, IntMultiply> calc2;  // 加法和乘法
```

# C++11/14/17/20模板语言支持特性增强

## 一、C++11：模板现代化的基石
C++11对模板进行了大量基础性增强，解决了旧版模板的诸多痛点：

### 1. 模板别名（Template Aliases）
- **语法**：`template <typename T> using Vec = std::vector<T>;`
- **作用**：为模板类型创建简洁的别名，替代C++98中只能用`typedef`配合嵌套类的繁琐方式，支持模板参数化的别名定义。
- **示例**：
  ```cpp
  // C++98 繁琐写法（需嵌套类）
  template <typename T>
  struct VecAlias {
      typedef std::vector<T> type;
  };
  VecAlias<int>::type v1;
  
  // C++11 简洁写法
  template <typename T>
  using Vec = std::vector<T>;
  Vec<int> v2; // 直接使用，无需::type
  ```

### 2. 变长模板参数（Variadic Templates）
- **核心**：允许模板接受任意数量、任意类型的参数（参数包），通过`...`声明，`args...`展开。
- **作用**：彻底解决C++98模板参数数量固定的问题，是实现泛型容器、函数包装器（如`std::function`）、`std::tuple`的核心基础。
- **示例**：
  ```cpp
  // 递归展开参数包
  void print() {} // 终止递归
  
  template <typename T, typename... Args>
  void print(T first, Args... args) {
      std::cout << first << " ";
      print(args...); // 展开剩余参数
  }
  
  int main() {
      print(1, "hello", 3.14); // 输出：1 hello 3.14
  }
  ```

### 3. 外部模板（Extern Templates）
- **语法**：`extern template class std::vector<int>;`
- **作用**：避免模板在多个编译单元中重复实例化，减少编译时间和目标文件体积，明确指定模板实例化的位置。
- **对比**：C++98中模板会在每个使用的编译单元实例化，导致冗余；C++11通过`extern`声明“该模板实例化在其他地方”。

### 4. 类型推导增强（auto + decltype + declval）
- **auto**：模板函数中可推导返回值/参数类型，简化泛型代码（如`template <typename T> auto func(T a) -> decltype(a+1)`）。
- **decltype**：获取表达式的类型，解决模板中“返回值依赖于参数类型”的问题（C++98无法直接推导）。
- **`decltype`和`declval`**：更精细的表达式SFINAE
- **示例**：
  ```cpp
  template <typename T, typename U>
  auto add(T a, U b) -> decltype(a + b) {
      return a + b;
  }
  // 推导add(1, 2.5)的返回值为double
  ```
  
  ```CPP
  template<typename T>
  auto test(int) -> decltype(std::declval<T>().size(), std::true_type{});
  
  template<typename T>
  std::false_type test(...);
  
  // 检测T是否有size()方法
  template<typename T>
  using has_size = decltype(test<T>(0));
  ```

### 5. 右值引用与模板完美转发
- **std::forward**：结合模板参数推导，实现“完美转发”——保持参数的左值/右值属性，解决模板传递参数时的类型丢失问题。
- **示例**：
  ```cpp
  template <typename T>
  void wrapper(T&& arg) {
      func(std::forward<T>(arg)); // 完美转发arg的属性
  }
  ```

### 6. 模板默认参数的扩展（函数模板）

* **函数模板默认参数**：C++98 仅支持类模板的默认参数，**C++11 将默认参数扩展到函数模板**，这是模板灵活性的重要提升

* **示例**：

  ```c++
  // C++11 支持
  template <typename T = int, typename U = std::allocator<T>>
  std::vector<T, U> create_vector(size_t n, const T& val = T{}) {
      return std::vector<T, U>(n, val);
  }
  
  // 使用：可省略部分/全部模板参数
  auto v1 = create_vector(5);          // T=int, U=std::allocator<int>
  auto v2 = create_vector<double>(3);  // T=double, U=std::allocator<double>
  ```

### 7.`std::enable_if`（SFINAE 核心工具）

> 详细见 **第3章的SFINAE** 的介绍

* **std::enable_if**：C++11 引入的`std::enable_if`是模板元编程的核心工具，基于 SFINAE（替换失败并非错误）实现模板重载 / 特化的条件筛选

* **示例**：

  ```c++
  // 仅当T是算术类型时启用此函数
  template <typename T>
  typename std::enable_if<std::is_arithmetic<T>::value, T>::type
  abs(T val) {
      return val < 0 ? -val : val;
  }
  
  // 非算术类型则匹配其他重载（或编译失败）
  ```

## 二、C++14：模板简化与易用性提升
C++14在C++11基础上进一步简化模板使用，核心增强如下：

### 1. 函数返回值类型推导（无需尾置返回值）
- **特性**：模板函数可直接用`auto`推导返回值，无需`decltype`尾置声明，代码更简洁。
- **示例**：
  ```cpp
  // C++11 需尾置返回值
  template <typename T, typename U>
  auto add(T a, U b) -> decltype(a + b) { return a + b; }
  
  // C++14 直接推导
  template <typename T, typename U>
  auto add(T a, U b) { return a + b; }
  ```

### 2. 泛型lambda（Generic Lambdas）
- **核心**：lambda表达式的参数可使用`auto`，本质是编译器自动生成模板化的闭包类，极大简化短生命周期的泛型逻辑。
- **示例**：
  ```cpp
  // C++14 泛型lambda
  auto print = [](auto x) { std::cout << x << std::endl; };
  print(1);    // 实例化print<int>
  print("hi"); // 实例化print<const char*>
  ```

### 3. 变量模板（Variable Templates）
- **语法**：`template <typename T> constexpr T pi = T(3.1415926535);`
- **作用**：模板化的变量，替代C++11中“模板类嵌套静态常量”的方式，支持类型参数化的常量/变量定义。
- **示例**：
  ```cpp
  template <typename T>
  constexpr T pi = T(3.1415926535);
  
  double d = pi<double>; // 3.1415926535
  float f = pi<float>;   // 3.1415927f
  ```

### 4. 模板别名支持默认参数
- **特性**：C++11的模板别名不支持默认参数，C++14补全该特性，与普通模板保持一致。
- **示例**：
  ```cpp
  // C++14 支持
  template <typename T = int>
  using Vec = std::vector<T>;
  Vec<> v; // 等价于Vec<int>
  ```

### 5. **模板变量支持constexpr**

- **特性**：模板变量可以声明为constexpr，用于编译期常量

- **示例**：

  ```cpp
  template<typename T>
  constexpr T zero = T(0);
  
  static_assert(zero<int> == 0, "");
  static_assert(zero<double> == 0.0, "");
  ```

### 6. **`std::integer_sequence` 及配套工具**

- **特性**：C++14 引入的`std::integer_sequence`是编译期整数序列生成工具，是变长模板参数与编译期索引操作的基础（如 tuple 展开、数组元编程）
- **示例**：详细见 **第2章 2.2小结** 的介绍

## 三、C++17：模板编译期能力与灵活性提升
C++17聚焦模板的编译期计算、条件实例化和语法简化，核心特性：

### 1. 折叠表达式（Fold Expressions）
- **核心**：简化变长模板参数包的展开，替代C++11/14的递归展开方式，支持4种折叠形式（左折叠、右折叠）。
- **语法**：`(args op ...)`（右折叠）、`(... op args)`（左折叠）、`(args op ... op init)`（带初始值）。
- **示例**：
  
  ```cpp
  // C++11 递归求和
  template <typename... Args>
  int sum(Args... args) {
      return (args + ...); // C++17 折叠表达式，等价于1+2+3+4
  }
  
  int main() {
      std::cout << sum(1,2,3,4); // 输出10
  }
  ```

### 2. 类模板参数推导（CTAD, Class Template Argument Deduction）
- **核心**：编译器可根据构造函数参数推导类模板的模板参数，无需显式指定（如`std::pair p(1, "hi")`替代`std::pair<int, const char*> p(1, "hi")`）。
- **增强**：支持自定义推导指南（Deduction Guides），解决复杂模板的推导歧义。
- **示例**：
  ```cpp
  // C++11/14 需显式指定模板参数
  std::vector<int> v1{1,2,3};
  
  // C++17 自动推导
  std::vector v2{1,2,3}; // 推导为std::vector<int>
  
  // 自定义推导指南
  template <typename T>
  struct MyContainer {
      MyContainer(T a, T b) { /* ... */ }
      
      template<typename Iter>
      MyVector(Iter begin, Iter end) { /* ... */ }
  };
  // 推导指南：当传入不同类型时，推导为double
  MyContainer(char, double) -> MyContainer<double>;
  // 推导指南：用于迭代器对
  template<typename Iter>
  MyVector(Iter, Iter) -> MyVector<typename std::iterator_traits<Iter>::value_type>;
  
  MyContainer c(1, 2.5); // 推导为MyContainer<double>
  
  std::list<int> lst{1,2,3};
  MyVector v(lst.begin(), lst.end()); // 推导为MyVector<int>
  ```

### 3. if constexpr（编译期条件判断）
- **核心**：模板中根据编译期常量条件分支，未满足的分支不会实例化，解决“模板中分支代码对某些类型不合法”的问题。
- **示例**：
  ```cpp
  template <typename T>
  auto get_value(T t) {
      if constexpr (std::is_pointer_v<T>) {
          return *t; // 仅当T是指针时实例化此分支
      } else {
          return t;  // 非指针时实例化此分支
      }
  }
  
  int main() {
      int a = 10;
      std::cout << get_value(&a); // 输出10
      std::cout << get_value(20); // 输出20
  }
  ```

### 4. inline变量（模板静态变量优化）
- **特性**：模板类的静态成员变量可声明为`inline`，避免“多编译单元实例化导致重复定义”的问题，简化模板静态变量的使用。
- **示例**：
  ```cpp
  template <typename T>
  struct MyClass {
      inline static T value = T{}; // C++17 inline，无需在外部定义
  };
  ```

### 5. 模板参数的auto（非类型模板参数）
- **核心**：非类型模板参数可使用`auto`推导类型，替代C++11中“必须显式指定类型”的限制。
- **示例**：
  
  ```cpp
  // C++11 需指定类型
  template <int N> struct Num {};
  Num<5> n1;
  
  // C++17 auto推导
  template <auto N> struct Num {};
  Num<5> n2;    // N推导为int
  Num<3.14> n3; // N推导为double
  ```

### 6.  **模板模板参数匹配放宽**

- **核心**：模板模板参数可以匹配更多类型的模板

- **示例**：

  ```cpp
  // C++17前：模板参数必须完全匹配
  template<template<typename> class Container>  // 只接受单参数模板
  
  // C++17：可以使用可变参数模板匹配
  template<template<typename...> class Container>  // 可以匹配std::vector、std::list等
  ```

### 7.  **using声明中的包展开**

- **核心**：模板模板参数可以匹配更多类型的模板，可以在using声明中展开参数包

- **示例**：

  ```cpp
  template<typename... Bases>
  struct Derived : Bases... {
      using Bases::operator()...;  // C++17：展开所有基类的operator()
  };
  ```

### 8. `std::void_t`（SFINAE 简化工具）

- **特性**：C++17 引入`std::void_t`，极大简化 SFINAE 条件判断（替代 C++11 中繁琐的`decltype(..., void())`写法）

- **示例**：

  ```cpp
  // 检测T是否有begin()/end()成员（C++17 简洁写法）
  template <typename T, typename = std::void_t<>>
  struct is_iterable : std::false_type {};
  
  template <typename T>
  struct is_iterable<T, std::void_t<decltype(std::declval<T>().begin()),
                                    decltype(std::declval<T>().end())>>
      : std::true_type {};
  
  static_assert(is_iterable<std::vector<int>>::value, "");
  ```

## 四、C++20：模板功能的重大扩展
C++20对模板的增强是革命性的，核心聚焦编译期编程、概念约束、模板简化：

### 1. 概念（Concepts）：模板参数的类型约束
- **核心**：为模板参数定义“语义约束”（如“可比较”“数值类型”），替代C++11/17的`static_assert`或SFINAE，错误提示更友好，代码更易读。
- **语法**：`template <typename T> concept Integral = std::is_integral_v<T>;`，结合`requires`子句定义约束。
- **示例**：
  ```cpp
  // 定义概念：可相加的类型
  template <typename T, typename U>
  concept Addable = requires(T a, U b) {
      { a + b } -> std::convertible_to<double>; // 要求a+b的结果可转换为double
  };
  
  // 模板仅接受满足Addable的参数
  template <typename T, typename U>
  requires Addable<T, U>
  auto add(T a, U b) {
      return a + b;
  }
  
  // 简化写法（C++20）
  template <Addable T, Addable U>
  auto add(T a, U b) { return a + b; }
  
  // 带默认参数的约束
  template<std::floating_point T = double>  
  T multiply(T a, T b) { return a * b; }
  
  // 使用auto约束
  void sort(auto& container) requires std::ranges::range<decltype(container)> {}
  
  void add(Addable auto a, Addable auto b) {}
  ```

### 2. if constexpr补充requires表达式（Requires Expressions）

- **核心**：作为concept的底层支撑，可直接在模板中使用`requires`判断类型是否满足特定语法/语义约束，是模板元编程的重要增强。

- **示例**：

  ```cpp
  template <typename T>
  auto get_size(T t) {
      if constexpr (requires { t.size(); }) {
          return t.size(); // 有size()成员则调用
      } else {
          return std::size(t); // 否则用std::size
      }
  }
  ```

### 3. **模板requires子句Traits Bound的位置灵活性和嵌套**

- **核心**：作为concept的底层支撑，可直接在模板中使用`requires`判断类型是否满足特定语法/语义约束，是模板元编程的重要增强。

- **示例**：

  ```cpp
  // requires子句的多种位置
  template<typename T>
  requires std::integral<T>  // 在模板后
  auto func1(T t) { return t; }
  
  template<typename T>
  auto func2(T t) requires std::integral<T> {  // 在函数声明后
      return t;
  }
  
  // 嵌套requires
  template<typename T>
  concept ComplexConcept = requires(T t) {
      requires std::integral<decltype(t.value)>;
      { t.get_value() } -> std::same_as<int>;
  };
  ```

### 4. **auto返回值类型约束**

- **核心**：可以使用concept概念约束返回值

- **示例**：

  ```cpp
  template<typename T>
  auto find(T a, T b)
  {
      return a;
  }
  std::list<int> lst {1,2};
  std::random_access_iterator auto findIt = find(lst.begin(), lst.end()); // error
  std::bidirectional_iterator auto findIt = find(lst.begin(), lst.end()); // ok
  ```

### 5. 模板lambda（Template Lambdas）
- **核心**：lambda可显式声明模板参数，支持默认参数、可变模板等完整模板功能，替代C++14泛型lambda的隐式`auto`，支持更精细的模板控制。
- **示例**：
  
  ```cpp
  // C++20 模板lambda
  auto print = []<typename T>(T x) {
      std::cout << x << std::endl;
  };
  // 也可结合concept
  auto sum = []<std::integral T>(T a, T b) { return a + b; };
  
  // 可变参数模板lambda
  auto print_all = []<typename... Ts>(Ts&&... args) {
      (std::cout << ... << args);
  };
  
  // 带默认参数的模板lambda
  auto process = []<typename T = int>(T value) {
      return value * 2;
  };
  ```

### 6. 编译期函数（consteval）与模板
- **consteval**：声明“立即函数”，必须在编译期执行，结合模板实现更高效的编译期计算，替代部分`constexpr`的运行时调用风险。
- **示例**：
  ```cpp
  template <int N>
  consteval int factorial() {
      return N <= 1 ? 1 : N * factorial<N-1>();
  }
  constexpr int val = factorial<5>(); // 编译期计算为120
  ```

### 7. 非类型模板参数的扩展
- **核心**：C++20允许非类型模板参数为“字面量类型”（如字符串字面量、自定义字面量类型），并支持`std::nullptr_t`作为非类型模板参数。
- **示例**：
  ```cpp
  // C++20 支持字符串字面量（需满足字面量类型要求）
  template <const char* Str>
  struct StringHolder {
      static constexpr const char* value = Str;
  };
  constexpr const char hello[] = "hello";
  StringHolder<hello> sh; // 合法
  
  // 自定义fixed_string类型
  template<size_t N>
  struct fixed_string
  {
    char value [N];
  
    constexpr fixed_string(const char (&str) [N])
    {
      for (size_t i = 0; i < N; ++i) {
        value [i] = str [i];
      }
    }
  
    constexpr operator const char*() const { return value; }
  
    constexpr const char* data() const { return value; }
  
    constexpr size_t size() const { return N - 1; }  // 减去空字符
  };
  
  template<fixed_string T>
  void fund() { /*...*/ }
  ```

### 8. 模板参数的`typename`弱化（非类型模板参数）

- **核心**：C++20 放宽了非类型模板参数的`typename`要求，对于依赖类型的非类型参数，可省略冗余的`typename`

- **示例**：

  ```cpp
  // C++20 简化前：需typename
  template <typename T, typename T::type N> struct A {};
  // C++20 简化后：可省略
  template <typename T, T::type N> struct A {};
  
  ```

### 9. 模板参数包的结构化绑定
- **核心**：C++20允许在模板中对参数包使用结构化绑定，简化复杂数据结构的泛型处理。
- **示例**：
  
  ```cpp
  template <typename... Ts>
  void print_pairs(std::pair<Ts, Ts>... pairs) {
      ((std::cout << std::get<0>(pairs) << ":" << std::get<1>(pairs) << " "), ...);
      // 结构化绑定写法
      for (auto [a, b] : {pairs...}) {
          std::cout << a << ":" << b << " ";
      }
  }
  ```

---

## 总结
1. **C++11**：奠定模板现代化基础，核心是变长模板参数、模板别名、auto/decltype推导、完美转发，解决模板基础易用性问题。
2. **C++14**：聚焦简化，核心是泛型lambda、变量模板、返回值自动推导，降低模板使用成本。
3. **C++17**：强化编译期能力，核心是折叠表达式、CTAD、if constexpr，提升模板编译期计算和条件实例化的灵活性。
4. **C++20**：革命性增强，核心是Concepts（类型约束）、模板lambda、consteval，解决模板“无约束”“错误提示差”“编译期编程复杂”的核心痛点。

这些特性的演进逻辑是：从“能用”（C++11）→“易用”（C++14）→“高效”（C++17）→“优雅且安全”（C++20），逐步将模板从“复杂的元编程工具”转变为“通用、易维护的泛型编程基础”。