## c++11

### （）explicit

在C++中，`explicit`关键字用于修饰只有一个参数的类构造函数，以防止该类构造函数被不期望地用作隐式类型转换。当你将`explicit`关键字应用于构造函数时，编译器就不会自动地（隐式地）使用该构造函数来执行类型转换。这有助于避免一些由于意外类型转换导致的错误和混淆。

下面是一个使用`explicit`关键字的例子来说明其用途：

```cpp
cpp

#include <iostream>  

  

class Rational {  

public:  

    // 显式构造函数  

    explicit Rational(int numerator) : numerator_(numerator), denominator_(1) {}  

  

    // 其他成员函数...  

    void print() const {  

        std::cout << numerator_ << "/" << denominator_ << std::endl;  

    }  

  

private:  

    int numerator_;  

    int denominator_;  

};  

  

int main() {  

    Rational r(5); // 正确用法，显式地调用构造函数  

    r.print(); // 输出: 5/1  

  

    // Rational r2 = 7; // 错误用法，如果Rational的的构造函数不是显式的  

    // 上面的代码行会导致编译错误，因为Rational的的构造函数是显式的  

  

    // 显式地创建一个Rational对象并赋值给r3  

    Rational r3 = Rational(7); // 正确用法，尽管略显冗长  

    r3.print(); // 输出: 7/1  

  

    // 不能隐式地执行算术运算，因为Rational的的构造函数是显式的  

    // Rational r4 = Rational(2) + Rational(3); // 错误用法，会导致编译错误  

  

    // 正确的做法是先创建Rational对象，然后进行运算  

    Rational r5(2);  

    Rational r6(3);  

    Rational r7 = r5 + r6; // 假设Rational类定义了加法运算符  

    r7.print(); // 假设输出加法结果  

  

    return 0;  

}
```

在上面的例子中，`Rational`类有一个接受单个`int`参数的构造函数，它被标记为`explicit`。因此，你不能直接将一个整数隐式地转换为一个`Rational`对象，如`Rational r2 = 7;`这样的代码行会导致编译错误。相反，你必须显式地调用构造函数来创建`Rational`对象，例如`Rational r3 = Rational(7);`。

通过使用`explicit`关键字，你可以防止编译器在不需要的时候进行不期望的类型转换，这有助于减少程序中的错误和混淆。这在设计库或API时尤其重要，因为不恰当的类型转换可能会导致难以追踪的错误。

### (1) [字符串原始字面量](https://subingwen.cn/cpp/R/)—R"(str)"

在C++11中添加了定义原始字符串的字面量，定义方式为：**R “xxx(原始字符串)xxx”其中（）两边的字符串可以省略**。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "D:\hello\world\test.text";
    cout << str << endl;
    string str1 = "D:\\hello\\world\\test.text";
    cout << str1 << endl;
    string str2 = R"(D:\hello\world\test.text)";
    cout << str2 << endl;

    return 0;
}
```

最后强调一个细节：***在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。***

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str1 = R"(D:\hello\world\test.text)";
    cout << str1 << endl;
    string str2 = R"luffy(D:\hello\world\test.text)luffy";
    cout << str2 << endl;
#if 0
    string str3 = R"luffy(D:\hello\world\test.text)robin";	// 语法错误，编译不通过
    cout << str3 << endl;
#endif

    return 0;
}
```

### (2) [指针空值类型—nullptr](https://subingwen.cn/cpp/nullptr/)

在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为NULL，避免产生野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：

```c++
char *ptr = 0;
char *ptr = NULL;
```

在底层源码中NULL这个宏是这样定义的:

```c++
#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif
```

也就是说如果源码是**<u>C++程序NULL就是0，如果是C程序NULL表示(void*)0。</u>**那么为什么要这样做呢？ 是由于 C++ 中，<u>void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 ((void *)0)，用于解决空指针的问题</u>。这个0（0x0000 0000）表示的就是虚拟地址空间中的0地址，这块地址是只读的。



C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分：

```c++
#include <iostream>
using namespace std;

void func(char *p)
{
    cout << "void func(char *p)" << endl;
}

void func(int p)
{
    cout << "void func(int p)" << endl;
}

int main()
{
    func(NULL);   // 想要调用重载函数 void func(char *p)
    func(250);    // 想要调用重载函数 void func(int p)

    return 0;
}

测试代码打印的结果为：（原因NULL等价于0是int）
void func(int p)
void func(int p)
```

出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字nullptr。**nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化**：

```c++
int*    ptr1 = nullptr;
char*   ptr2 = nullptr;
double* ptr3 = nullptr;
```

对应上面的代码编译器会分别将 nullptr **隐式转换**成 int*、char* 以及 double* 指针类型。

### (3) [常量表达式修饰符 - constexpr](https://subingwen.cn/cpp/constexpr/)

#### 1.1 const

在C++11之前只有const关键字，从功能上来说这个关键字有双重语义：**变量只读，修饰常量**，举一个简单的例子：

```c++
void func(const int num)//num是变量，只是传进来被修改
{
    const int count = 24;
    int array[num];            // error，num是一个只读变量，不是常量
    int array1[count];         // ok，count是一个常量

    int a1 = 520;
    int a2 = 250;
    const int& b = a1;
    b = a2;                         // error
    a1 = 1314;
    cout << "b: " << b << endl;     // 输出结果为1314
}
```

* 函数void func(const int num)的参数num表示这个变量是只读的，但不是常量，因此使用int array[num]; 这种方式定义一个数组，编译器是会报错的，提示num不可用作为常量来使用。
* const int count = 24;中的count却是一个常量，因此可以使用这个常量来定义一个静态数组。

另外，变量只读并不等价于常量，二者是两个概念不能混为一谈，分析一下这句测试代码const int& b = a1;

* b是一个常量的引用，所以b引用的变量是不能被修改的，也就是说b = a2; 这句代码语法是错误的。

* 在const对于变量a1是没有任何约束的，a1的值变了b的值也就变了

* 引用b是只读的，但是并不能保证它的值是不可改变的，也就是说它不是常量。

#### 1.2 constexpr

在C++11中添加了一个新的关键字constexpr，这个关键字是用来**修饰常量表达式的**。<u>所谓常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</u>

需要额外强调的是，**常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，**因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。

采用constexpr是为了区分，让编译器知道这是一个常量表达式

```c++
const int m = f();  // 不是常量表达式，m的值只有在运行时才会获取。
const int i=520;    // 是一个常量表达式
const int j=i+1;    // 是一个常量表达式

constexpr int i=520;    // 是一个常量表达式
constexpr int j=i+1;    // 是一个常量表达式
```

结构体struct和类class，constexpr修饰注意事项：

```c++
// 此处的constexpr修饰是无效的
constexpr struct Test
{
    int id;
    int num;
};

// 以下为正确写法
struct Test
{
    int id;
    int num;
};

int main()
{
    constexpr Test t{ 1, 2 };
    constexpr int id = t.id;
    constexpr int num = t.num;
    // error，不能修改常量，因为对象t是一个常量，因此它的成员也是常量
    t.num += 100;
    cout << "id: " << id << ", num: " << num << endl;

    return 0;
}
```

### (4) [常量表达式函数](https://subingwen.cn/cpp/constexpr/)

#### 1.1 修饰函数——三规则

1. **函数必须要有返回值，并且return 返回的表达式必须是常量表达式。**

```c++
// error，不是常量表达式函数，void说明没有返回值
constexpr void func1()
{
    int a = 100;
    cout << "a: " << a << endl;
}

// error，返回值是变量a，不是常量表达式函数，
constexpr int func1()
{
    int a = 100;
    return a;
}
```

2. **函数在使用之前，必须有对应的定义语句。**

```c++
#include <iostream>
using namespace std;

constexpr int func1();
int main()
{
    constexpr int num = func1();	// error
    return 0;
}

constexpr int func1()
{
    constexpr int a = 100;
    return a;
}

/*
在测试程序constexpr int num = func1();中，还没有定义func1()就直接调用了，应该将func1()函数的定义放到main()函数的上边。
*/
```

3. 整个函数的函数体中，不能出现非常量表达式之外的语句（<u>using 指令、typedef 语句以及 static_assert 断言、return语句除外</u>）。

```c++
// error，不允许出现for
constexpr int func1()
{
    constexpr int a = 100;
    constexpr int b = 10;
    for (int i = 0; i < b; ++i)
    {
        cout << "i: " << i << endl;
    }
    return a + b;
}

// ok
constexpr int func2()
{
    using mytype = int;
    constexpr mytype a = 100;
    constexpr mytype b = 10;
    constexpr mytype c = a * b;
    return c - (a + b);
}
```

**以上三条规则不仅对应普通函数适用，对应<u>*类的成员函数*</u>也是适用的**

#### 1.2 修饰模板函数

C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。**如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。**

```c++
#include <iostream>
using namespace std;

struct Person {
    const char* name;
    int age;
};

// 定义函数模板
template<typename T>
constexpr T dispaly(T t) {
    return t;
}

int main()
{
    struct Person p { "luffy", 19 };
    //普通函数
    struct Person ret = dispaly(p);
    cout << "luffy's name: " << ret.name << ", age: " << ret.age << endl;

    //常量表达式函数
    constexpr int ret1 = dispaly(250);
    cout << ret1 << endl;

    constexpr struct Person p1 { "luffy", 19 };
    constexpr struct Person p2 = dispaly(p1);
    cout << "luffy's name: " << p2.name << ", age: " << p2.age << endl;
    return 0;
}
/*
在上面示例程序中定义了一个函数模板 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：

   * struct Person ret = dispaly(p);由于参数p是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的
   * constexpr int ret1 = dispaly(250);参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的
   * constexpr struct Person p2 = dispaly(p1);参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的
*/
```

#### 1.3 修饰构造函数

如果想用直接得到一个常量对象，也可以使用constexpr修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：**<u>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值</u>**。

```c++
#include <iostream>
using namespace std;

struct Person {
    constexpr Person(const char* p, int age) :name(p), age(age)
    {
    }
    const char* name;
    int age;
};

int main()
{
    constexpr struct Person p1("luffy", 19);
    cout << "luffy's name: " << p1.name << ", age: " << p1.age << endl;
    return 0;
}
```

### (5) 自动类型推导

#### 1.1 auto——必须初始化

C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，**使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型**。使用语法如下：

```c++
// auto 变量名 = 变量值;

auto x = 3.14;      // x 是浮点型 double
auto y = 520;       // y 是整形 int
auto z = 'a';       // z 是字符型 char
auto nb;            // error，变量必须要初始化
auto double nbl;    // 语法错误, 不能修改数据类型   

```

不仅如此，auto还可以和指针、引用结合起来使用也可以带上const、volatile(使用该关键字编译器不会进行优化常用语多线程安全)限定符，在不同的场景下有对应的推导规则，规则内容如下：

* **当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字**
* **当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字**

先来看一组变量带指针和引用并使用auto进行类型推导的例子：

```c++
int temp = 110;
auto *a = &temp;	
auto b = &temp;		
auto &c = temp;		
auto d = temp;		
auto e = c;
```

* 变量a的数据类型为 int\*，因此auto关键字被推导为 int类型
* 变量b的数据类型为 int\*，因此auto关键字被推导为 int*类型
* 变量c的数据类型为 int&，因此auto关键字被推导为 int类型
* 变量d的数据类型为 int，因此auto关键字被推导为 int类型。
* *<u>变量e的数据类型为 int，即使c数据类型为 int&，原因`auto`型别推导会**忽略引用和顶层const**, 所以要对对象加上想要的修饰.</u>*



在来看一组带const限定的变量，使用auto进行类型推导的例子:

```c++
int tmp = 250;
const auto a1 = tmp;
auto a2 = a1;
const auto &a3 = tmp;
auto &a4 = a3;
```

* 变量a1的数据类型为 const int，因此auto关键字被推导为 int类型
* 变量a2的数据类型为 int，但是a2没有声明为指针或引用因此 const属性被去掉, auto被推导为 int
* 变量a3的数据类型为 const int&，a3被声明为引用因此 const属性被保留，auto关键字被推导为 int类型
* 变量a4的数据类型为 const int&，a4被声明为引用因此 const属性被保留，auto关键字被推导为 const int类型

#### 1.2 auto限制

auto关键字并不是万能的，在以下这些场景中是不能完成类型推导的：

1. 不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。

```c++
int func(auto a, auto b)	// error
{	
    cout << "a: " << a <<", b: " << b << endl;
}
```



2. 不能用于类的非静态成员变量的初始化

```c++
class Test
{
    auto v1 = 0;                    // error
    static auto v2 = 0;             // error,类的静态非常量成员不允许在类内部直接初始化
    static const auto v3 = 10;      // ok
}
```



3. 不能使用auto关键字定义数组

``` c++
int func()
{
    int array[] = {1,2,3,4,5};  // 定义数组
    auto t1 = array;            // ok, t1被推导为 int* 类型，为数组地址
    auto t2[] = array;          // error, auto无法定义为新的数组
    auto t3[] = {1,2,3,4,5};;   // error, auto无法定义为新的数组
}
```



4. 无法使用auto推导出模板参数（模版需要具体类型，auto也需要具体类型）

```c++
template <typename T>
struct Test{}

int func()
{
    Test<double> t;
    Test<auto> t1 = t;           // error, 无法推导出模板类型，这里两个都需要推导不行
    return 0;
}
```

#### 1.3 auto的应用

了解了auto的限制之后，我们就可以避开这些场景快乐的编程了，下面列举几个比较常用的场景：

1. 用于STL的容器遍历。

​	在C++11之前，定义了一个stl容器之后，遍历的时候常常会写出这样的代码：

```c++
#include <map>
int main()
{
    map<int, string> person;
    map<int, string>::iterator it = person.begin();
    for (; it != person.end(); ++it)
    {
        // do something
    }
    return 0;
}
```

可以看到在定义迭代器变量 it 的时候代码是很长的，写起来就很麻烦，使用了auto之后，就变得清爽了不少：

```c++
#include <map>
int main()
{
    map<int, string> person;
	person.insert(std::make_pair(1, "123"));
    // 代码简化
    for (auto it = person.begin(); it != person.end(); ++it)
    {
        // do something
		std::cout << it-》first << std::endl;
    }
    // 更简化
    for (auto it : person) {
		std::cout << it.first << std::endl;
	}
    return 0;
}
```

2. 用于泛型编程，在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，比如下面的代码：

```c++
#include <iostream>
#include <string>
using namespace std;

class T1
{
public:
    static int get()
    {
        return 10;
    }
};

class T2
{
public:
    static string get()
    {
        return "hello, world";
    }
};
#if 1
template <class A>
void func(void)
{
    auto val = A::get();//我们给了A模版类型，模版知道了，auto自然也能够推导出
    cout << "val: " << val << endl;
}

int main()
{
    func<T1>();
    func<T2>();
    return 0;
}
#else
/*
在这个例子中定义了泛型函数func，在函数中调用了类A的静态方法 get() ，这个函数的返回值是不能确定的，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下：
*/
template <class A, typename B>        // 添加了模板参数 B
void func(void)
{
    B val = A::get();
    cout << "val: " << val << endl;
}

int main()
{
    func<T1, int>();                  // 手动指定返回值类型 -> int
    func<T2, string>();               // 手动指定返回值类型 -> string
    return 0;
}
#endif

```

#### 2.1 decltype

在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用C++11提供的decltype关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型，语法格式如下：

```c++
// decltype (表达式)

int a = 10;
decltype(a) b = 99;                 // b -> int
decltype(a+3.14) c = 52.13;         // c -> double
decltype(a+b*c) d = 520.1314;       // d -> double
```

#### 2.2 decltype推导规则

1. 表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。

```c++
#include <iostream>
#include <string>
using namespace std;

class Test
{
public:
    string text;
    static const int value = 110;
};

int main()
{
    int x = 99;
    const int &y = x;
    decltype(x) a = x;
    decltype(y) b = x;
    decltype(Test::value) c = 0;

    Test t;
    decltype(t.text) d = "hello, world";

    return 0;
}
/*
 *变量a被推导为 int类型
 *变量b被推导为 const int &类型
 *变量c被推导为 const int类型
 *变量d被推导为 string类型
*/
```

2. 表达式是函数调用，使用decltype推导出的类型和函数返回值一致。

```c++
class Test{...};
//函数声明
int func_int();                 // 返回值为 int
int& func_int_r();              // 返回值为 int&
int&& func_int_rr();            // 返回值为 int&&

const int func_cint();          // 返回值为 const int
const int& func_cint_r();       // 返回值为 const int&
const int&& func_cint_rr();     // 返回值为 const int&&

const Test func_ctest();        // 返回值为 const Test

//decltype类型推导
int n = 100;
decltype(func_int()) a = 0;		
decltype(func_int_r()) b = n;	
decltype(func_int_rr()) c = 0;	
decltype(func_cint())  d = 0;	
decltype(func_cint_r())  e = n;	
decltype(func_cint_rr()) f = 0;	
decltype(func_ctest()) g = Test();	
/*
    变量a被推导为 int类型
    变量b被推导为 int&类型
    变量c被推导为 int&&类型
    变量d被推导为 int类型
    变量e被推导为 const int &类型
    变量f被推导为 const int &&类型
    变量g被推导为 const Test类型
*/
```

函数 func_cint() 返回的是一个纯右值（它指的是一个表达式，**该表达式的值可以被计算出来**，但没有对应的持久性对象。**纯右值不能被修改**，也不能获取其地址在表达式执行结束后不再存在的数据，也就是**临时性的数据，Lambda表达式都属于纯右值**），**对于纯右值而言，只有类类型可以携带const、volatile限定符**，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为 int 而不是 const int。

3. 表达式是一个左值，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）。

```c++
#include <iostream>
#include <vector>
using namespace std;

class Test
{
public:
    int num;
};

int main() {
    const Test obj;
    //带有括号的表达式
    decltype(obj.num) a = 0;
    decltype((obj.num)) b = a;
    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;
    decltype(n = n + m) d = n;
    return 0;
}
/*
obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int
obj.num 带有括号，符合场景3，因此b 的类型为 const int&。
n+m 得到一个右值，匿名地址看不到，符合场景1，因此c的类型为 int
n=n+m 得到一个左值 n，符合场景3，因此d的类型为 int&
*/
```

#### 2.3 decltype的应用

关于decltype的应用多出现在泛型编程中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：

```c++
#include <list>
using namespace std;

template <class T>
class Container
{
public:
    //需要m_it迭代器输出容器数据
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    T::iterator m_it;  // 使用迭代器都要指名是哪个容器类型的迭代器，这里不能确定迭代器类型，模版在编译就确定了，但是T不能指定具体迭代器
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

关于迭代器变量一共有两种类型：只读（T::const_iterator）和读写（T::iterator），有了decltype就可以完美的解决这个问题了，当 T 是一个 非 const 容器得到一个 T::iterator，当 T 是一个 const 容器时就会得到一个 T::const_iterator。

```c++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // T加()说明T是一个对象，这里确定容器对象，就能得到容器类型的迭代器，通过decltype推导类型给m_it
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

#### 3. 返回类型后置 auto -> decltype

在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：

```c++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<decltype(x + y), int, double>(x, y);
    auto z = add<decltype(x + y)>(x, y);	// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

关于返回值，从上面的代码可以推断出和表达式 t+u的结果类型是一样的，因此可以通过通过decltype进行推导，关于模板函数的参数t和u可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。

```c++
template <typename T, typename U>
decltype(t+u) add(T t, U u)
{
    return t + u;
}
/*
当我们在编译器中将这几行代码改出来后就直接报错了，因此decltype中的 t 和 u 都是函数参数，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在，有点心急了。
*/
```

**在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导。其语法格式如下:**

```c++
// 符号 -> 后边跟随的是函数返回值的类型
auto func(参数1, 参数2, ...) -> decltype(参数表达式)

```

通过对上述返回类型后置语法代码的分析，得到结论：**auto 会追踪 decltype() 推导出的类型**，因此上边的add()函数可以做如下的修改：

```c++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t+u) 
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<int, double>(x, y);
    auto z = add(x, y);		// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

为了进一步说明这个语法，我们再看一个例子：

```c++
#include <iostream>
using namespace std;

int& test(int &i)
{
    return i;
}

double test(double &d)
{
    d = d + 100;
    return d;
}

template <typename T>
// 返回类型后置语法
auto myFunc(T& t) -> decltype(test(t))
{
    return test(t);
}
/** 等价于c++14新增
template <typename T>  
decltype(auto) myFunc(T& t)  
{  
    return test(t);  
}
*/
int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = myFunc<int>(x);
    auto z = myFunc(x);             // 简化之后的写法，myFunc(x)返回参数引用，auto会忽略&，z为int，myFunc(x)为int&，
    //auto z = &myFunc(x); z为int*
    cout << "z: " << z << endl;

    // auto z = myFunc<double>(y);
    auto z1 = myFunc(y);            // 简化之后的写法
    cout << "z1: " << z1 << endl;
    return 0;
}
```

#### 4. decltype(auto)

在 C++14 标准中出现了 decltype 和 auto 两个关键字的结合体：decltype(auto)。它的作用简单来说，**就是告诉编译器用decltype的推导表达式规则来推导auto。另外需要注意的是，decltype(auto)必须单独声明，也就是它不能结合指针、引用以及cv限定符。**

```c++
int i;
int&& f();
auto x1a = i; // x1a推导类型为int
decltype(auto) x1d = i; // x1d推导类型为int
auto x2a = (i); // x2a推导类型为int
decltype(auto) x2d = (i); // x2d推导类型为int&
auto x3a = f(); // x3a推导类型为int
decltype(auto) x3d = f(); // x3d推导类型为int&&
auto x4a = { 1, 2 }; // x4a推导类型为
std::initializer_list<int>
decltype(auto) x4d = { 1, 2 }; // 编译失败, {1, 2}不是表达式
auto *x5a = &i; // x5a推导类型为int*
decltype(auto)*x5d = &i; // 编译失败，decltype(auto)必须单独声明

```

有了decltype(auto)之后，我们又多了一种返回引用的形式：

```c++
template <typename T>  
auto myFunc(T& t) -> decltype(test(t))
{
	return test(t);
}
// 等价于
template <typename T>  
decltype(auto) myFunc(T& t)  
{  
    return test(t);  
}
```

在C++17 标准中，decltype(auto)还能作为非类型模板形参的占位符，例如：

```c++
#include <iostream>
template<decltype(auto) N>
void f()
{
    std::cout << N << std::endl;
}
```

### (6) final和override

#### 1. final

C++中增加了final关键字来**限制某个类不能被继承，或者某个虚函数不能被重写**，和Java的final关键字的功能是类似的。如果**使用final修饰函数，只能修饰虚函数，并且要把final关键字放到类或者函数的后面**。

##### 1.1 修饰函数

如果使用final修饰函数，只能修饰虚函数，这样就能阻止子类重写父类的这个函数了：

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout << "GrandChild class...";
    }
};
```

##### 1.2 修饰类

使用final关键字修饰过的类是不允许被继承的，也就是说这个类不能有派生类。

```
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child final: public Base
{
public:
    void test()
    {
        cout << "Child class...";
    }
};

// error, 语法错误
class GrandChild : public Child
{
public:
};
```

Child类是被final修饰过的，因此Child类不允许有派生类GrandChild类的继承是非法的，Child是个断子绝孙的类。

#### 2. override

override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。使用方法如下：

```c++
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    void test() override
    {
        cout << "Child class...";
    }
};
```

### (7) 模板的优化

####  1. 模板的右尖括号

在泛型编程中，模板实例化有一个非常繁琐的地方，那就是连续的两个右尖括号（>>）会被编译器解析成右移操作符，而不是模板参数表的结束。我们先来看一段关于容器遍历的代码，在创建的类模板Base中提供了遍历容器的操作函数traversal():

```
// test.cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
class Base
{
public:
    void traversal(T& t)
    {
        auto it = t.begin();
        for (; it != t.end(); ++it)
        {
            cout << *it << " ";
        }
        cout << endl;
    }
};


int main()
{
    vector<int> v{ 1,2,3,4,5,6,7,8,9 };
    Base<vector<int>> b;
    b.traversal(v);

    return 0;
}
```

#### 2. 默认模板参数

```c++
#include <iostream>
using namespace std;

template <typename T=int>	// C++98/03不支持这种写法, C++11中支持这种写法
void func(T t)
{
    cout << "current value: " << t << endl;
}

int main()
{
    func(100);
    return 0;
}
```



```c++
template <typename T = long, typename U = int>
void mytest(T t = 'A', U u = 'B') {
	cout << "t:" << t << ",u:" << u << endl;
}

int main()
{
	// 优先级，指定>推导>默认

	// 推导为char,char
	mytest<>('a', 'b');
	// 指定加推导为int,char
	mytest<int>('a', 'b');
	// 指定加推导为char,int
	mytest<char>('a', 'b');
	// 指定为int,char
	mytest<int, char>('a', 'b');
	// 指定为char,int
	mytest<char, int>('a', 'b');
	// 默认long，int
	mytest<>();

	return 0;
}
```

当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：

指定数据类型优先级最高

如果可以推导出参数类型则使用推导出的类型
如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数
如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。

### (8) using的使用

在C++中using用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在C++11中赋予了using新的功能，让C++变得更年轻，更灵活。

#### 1. 定义别名（using和typedef对比）

在 C++中可以通过 typedef 重定义一个类型，语法格式如下：

```c++
typedef 旧的类型名 新的类型名;
// 使用举例
typedef unsigned int uint_t;

```

被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用using。

在使用的时候，关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。**类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上是等效的。**

使用using定义别名的语法格式是这样的：

```c++
using 新的类型 = 旧的类型;
// 使用举例
using uint_t = int;
```


通过using和typedef的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了，看一下下面的例子：

```c++
// 使用typedef定义函数指针，传两个参数
typedef int(*func_ptr)(int, double);

// 使用using定义函数指针，传两个参数
using func_ptr1 = int(*)(int, double);

func f mytest;
funcl f1 mytest;
f(10,"he11o");
f1(10,"he11o"):
(*f)(10,"s");
```

如果不是特别熟悉函数指针与typedef，<u>第一眼很难看出func_ptr其实是一个别名，其本质是一个函数指针，指向的函数返回类型是int，函数参数有两个分别是int，double类型。</u>

使用using定义函数指针别名的写法看起来就非常直观了**，把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边，比较清晰，可读性比较好**。

#### 2. 模板的别名

使用typename不支持给模板定义别名，这个简单的需求仅通过typedef很难办到，需要添加一个外敷类：

```c++
#include <iostream>
#include <functional>
#include <map>
using namespace std;

template <typename T>
// 定义外敷类
struct MyMap
{
    typedef map<int, T> type;
};

int main(void)
{
    MyMap<string>::type m;
    m.insert(make_pair(1, "luffy"));
    m.insert(make_pair(2, "ace"));

    MyMap<int>::type m1;
    m1.insert(1, 100);
    m1.insert(2, 200);

    return 0;
}
```

通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。在C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名，对于上面的需求可以写成这样：

```c++
template <typename T>
using mymap = map<int, T>;

```

```c++
#include <iostream>
#include <functional>
#include <map>
using namespace std;

template <typename T>
using mymap = map<int, T>;

int main(void)
{
    // map的value指定为string类型
    mymap<string> m;
    m.insert(make_pair(1, "luffy"));
    m.insert(make_pair(2, "ace"));

    // map的value指定为int类型
    mymap<int> m1;
    m1.insert(1, 100);
    m1.insert(2, 200);

    return 0;
}
```

**最后在强调一点：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。**



### (9) 委托构造和继承构造函数

#### 1. 委托构造函数

委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。下面举例说明：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min)
    {
        this->m_max = max > 0 ? max : 100;              // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;   
    }

    Test(int max, int min, int mid)
    {
        this->m_max = max > 0 ? max : 100;             // 冗余代码
        this->m_min = min > 0 && min < max ? min : 1;  // 冗余代码
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};

int main()
{
    Test t(90, 30, 60);
    cout << "min: " << t.m_min << ", middle: " 
         << t.m_middle << ", max: " << t.m_max << endl;
    return 0;
}
```

在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在C++11之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this->m_max = max > 0 ? max : 100;
    }

    Test(int max, int min):Test(max)
    {
        this->m_min = min > 0 && min < max ? min : 1;
    }

    Test(int max, int min, int mid):Test(max, min)
    {
        this->m_middle = mid < max && mid > min ? mid : 50;
    }

    int m_min;
    int m_max;
    int m_middle;
};

int main()
{
    Test t(90, 30, 60);
    cout << "min: " << t.m_min << ", middle: " 
         << t.m_middle << ", max: " << t.m_max << endl;
    return 0;
}
```

在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：

* **这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。**

* **如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。**

```c++
Test(int max)
{
    this->m_max = max > 0 ? max : 100;
}

Test(int max, int min)
{
    Test(max);	// error, 此处编译器会报错, 提示形参max被重复定义
    this->m_min = min > 0 && min < max ? min : 1;
}
```

* 在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。

```c++
// 错误, 使用了委托构造函数就不能再次m_max初始化了
Test(int max, int min) : Test(max), m_max(max)
{
    this->m_min = min > 0 && min < max ? min : 1;
}
```

#### 2. 继承构造函数——using父类::构造函数/同名方法

C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    Child(int i) :Base(i) {}
    Child(int i, double j) :Base(i, j) {}
    Child(int i, double j, string k) :Base(i, j, k) {}
};

int main()
{
    Child c(520, 13.14, "i love you");
    cout << "int: " << c.m_i << ", double: " 
         << c.m_j << ", string: " << c.m_k << endl;
    return 0;
}
```

通过测试代码可以看出，在子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数，这是非常繁琐的，C++11中通过添加继承构造函数这个新特性完美的解决了这个问题，使得代码更加精简。

继承构造函数的使用方法是这样的：**通过使用using 类名::构造函数名**（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;
};

int main()
{
    Child c1(520, 13.14);
    cout << "int: " << c1.m_i << ", double: " << c1.m_j << endl;
    Child c2(520, 13.14, "i love you");
    cout << "int: " << c2.m_i << ", double: " 
         << c2.m_j << ", string: " << c2.m_k << endl;
    return 0;
}
```

另外**如果在子类中隐藏了父类中的同名函数**，也可以通过using的方式在子类中使用基类中的这些父类函数：

```c++
#include <iostream>
#include <string>
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    void func(int i)
    {
        cout << "base class: i = " << i << endl;
    }
    
    void func(int i, string str)
    {
        cout << "base class: i = " << i << ", str = " << str << endl;
    }

    int m_i;
    double m_j;
    string m_k;
};

class Child : public Base
{
public:
    using Base::Base;
    using Base::func;
    void func()
    {
        cout << "child class: i'am luffy!!!" << endl;
    }
};

int main()
{
    Child c(250);
    c.func();
    c.func(19);
    c.func(19, "luffy");
    // 如果不加    using Base::func;等价于
    c.Base::func();
    c.Base::func(19);
    c.Base::func(19, "luffy");
    return 0;
}
```

### (10) 列表初始化

#### 1. 统一的初始化

在C++98/03中，对应普通数组和可以直接进行内存拷贝（memcpy()）的对象是可以使用列表初始化来初始化数据的

```c++
// 数组的初始化
int array[] = { 1,3,5,7,9 };
double array1[3] = { 1.2, 1.3, 1.4 };

// 对象的初始化
struct Person
{
    int id;
    double salary;
}zhang3{ 1, 3000 };

```

在C++11中，列表初始化变得更加灵活了，来看一下下面这段初始化类对象的代码：

```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test(int) {}
private:
    Test(const Test &);
};

int main(void)
{
    Test t1(520);
    Test t2 = 520; //隐式转换，编译器看类中是否有int类型的构造函数
    Test t3 = { 520 };
    Test t4{ 520 };
    int a1 = { 1314 };
    int a2{ 1314 };
    int arr1[] = { 1, 2, 3 };
    int arr2[]{ 1, 2, 3 };
    return 0;
}
```

#### 2. 列表初始化细节

##### 2.1 聚合体

在C++11中，列表初始化的使用范围被大大增强了，但是一些模糊的概念也随之而来，在前面的例子可以得知，列表初始化可以用于自定义类型的初始化，但是对于一个自定义类型，列表初始化可能有两种执行结果：

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    int y;
}a = { 123, 321 };

struct T2
{
    int x;
    int y;
    T2(int, int) : x(10), y(20) {}
}b = { 123, 321 };

int main(void)
{
    cout << "a.x: " << a.x << ", a.y: " << a.y << endl;
    cout << "b.x: " << b.x << ", b.y: " << b.y << endl;
    return 0;
}
```

程序执行的结果是这样的:

```c++
a.x: 123, a.y: 321
b.x: 10, b.y: 20
```

在上边的程序中都是用列表初始化的方式对对象进行了初始化，但是得到结果却不同，对象b并没有被初始化列表中的数据初始化，这是为什么呢？

* **对象a是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的成员。**
* **在结构体T2中自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的。**

<u>因为如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是初始化列表中的数据就会拷贝到对象中。</u>

那么，使用列表初始化时，对于什么样的类型C++会认为它是一个聚合体呢？

* 普通数组本身可以看做是一个聚合类型

```
int x[] = {1,2,3,4,5,6};
double y[3][3] = {
    {1.23, 2.34, 3.45},
    {4.56, 5.67, 6.78},
    {7.89, 8.91, 9.99},
};
char carry[] = {'a', 'b', 'c', 'd', 'e', 'f'};
std::string sarry[] = {"hello", "world", "nihao", "shijie"};
```

* 满足以下条件的类（class、struct、union）可以被看做是一个聚合类型：

  * 无用户自定义的构造函数。

  * 无私有或保护的非静态数据成员。

    * 场景1: 类中有私有成员, 无法使用列表初始化进行初始化

    ```c++
    struct T1
    {
        int x;
        long y;
    protected:
        int z;
    }t{ 1, 100, 2};		// error, 类中有私有成员, 无法使用初始化列表初始化
    ```

    * 场景2：类中有非静态成员可以通过列表初始化进行初始化，但它不能初始化静态成员变量。

    ```c++
    struct T2
    {
        int x;
        long y;
    protected:
        static int z;
    }t{ 1, 100， 2};		// error
    
    ```

    **结构体中的静态变量 z 不能使用列表初始化进行初始化，它的初始化遵循静态成员的初始化方式。**

    ```
    struct T2
    {
        int x;
        long y;
    protected:
        static int z;
    }t{ 1, 100};		// ok
    // 静态成员的初始化
    int T2::z = 2;
    ```

* 无基类。

* 无虚函数。

* 类中不能有使用{}和=直接初始化的非静态数据成员（从c++14开始就支持了）。

```c++
#include <iostream>
#include <string>
using namespace std;

struct T2
{
    int x;
    long y;
protected:
    static int z;
}t1{ 1, 100 };		// ok
// 静态成员的初始化
int T2::z = 2;

struct T3
{
    int x;
    double y = 1.34;
    int z[3]{1,2,3};
};

int main(void)
{
    T3 t{520, 13.14, {6,7,8}};		// error, c++11不支持,从c++14开始就支持了
    return 0;
}
```

##### 2.2 非聚合体

对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，**需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:**

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    double y;
    // 在构造函数中使用初始化列表初始化类成员
    T1(int a, double b, int c) : x(a), y(b), z(c){}
    virtual void print()
    {
        cout << "x: " << x << ", y: " << y << ", z: " << z << endl;
    }
private:
    int z;
};

int main(void)
{
    T1 t{ 520, 13.14, 1314 };	// ok, 基于构造函数使用初始化列表初始化类成员
    t.print();
    return 0;
}
```

另外，需要额外注意的是**聚合类型的定义并非递归的**，也就是说**当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型**，比如下面的这个例子：

```c++
#include <iostream>
#include <string>
using namespace std;

struct T1
{
    int x;
    double y;
private:
    int z;
};

struct T2
{
    T1 t1;
    long x1;
    double y1;
};

int main(void)
{
    T2 t2{ {}, 520, 13.14 };
    return 0;
}
```

可以看到，T1并非一个聚合类型，因为它有一个Private的非静态成员。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。

最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号{}，这相当于调用是T1的无参构造函数

**对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数。**

##### 2.3 std::initializer_list

在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用std::initializer_list这个轻量级的类模板来实现。

先来介绍一下这个类模板的一些特点：

* 它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的概念，遍历时得到的迭代器是只读的。
* 对于std::initializer_list<T>而言，它可以接收任意长度的初始化列表，但是要求元素必须是同种类型T
* 在std::initializer_list内部有三个成员接口：size(), begin(), end()。
* std::initializer_list对象只能被整体初始化或者赋值。

###### 	2.3.1 作为普通函数参数

如果想要自定义一个函数并且接收任意个数的参数（变参函数），只需要将函数参数指定为std::initializer_list，使用初始化列表{ }作为实参进行数据传递即可。

```c++
#include <iostream>
#include <string>
using namespace std;

void traversal(std::initializer_list<int> a)
{
    for (auto it = a.begin(); it != a.end(); ++it)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main(void)
{
    initializer_list<int> list;
    cout << "current list size: " << list.size() << endl;
    traversal(list);

    list = { 1,2,3,4,5,6,7,8,9,0 };
    cout << "current list size: " << list.size() << endl;
    traversal(list);
    cout << endl;
    
    list = { 1,3,5,7,9 };
    cout << "current list size: " << list.size() << endl;
    traversal(list);
    cout << endl;

    ////////////////////////////////////////////////////
    ////////////// 直接通过初始化列表传递数据 //////////////
    ////////////////////////////////////////////////////
    traversal({ 2, 4, 6, 8, 0 });
    cout << endl;

    traversal({ 11,12,13,14,15,16 });
    cout << endl;


    return 0;
}
```

std::initializer_list拥有一个无参构造函数，因此，它可以直接定义实例，此时将得到一个空的std::initializer_list，因为在遍历这种类型的容器的时候得到的是一个只读的迭代器，因此我们不能修改里边的数据，只能通过值覆盖的方式进行容器内部数据的修改。虽然如此，在效率方面也无需担心，std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。

###### 	2.3.2 作为构造函数参数

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Test
{
public:
    Test(std::initializer_list<string> list)
    {
        for (auto it = list.begin(); it != list.end(); ++it)
        {
            cout << *it << " ";
            m_names.push_back(*it);
        }
        cout << endl;
    }
private:
    vector<string> m_names;
};

int main(void)
{
    Test t({ "jack", "lucy", "tom" });
    Test t1({ "hello", "world", "nihao", "shijie" });
    return 0;
}
```

### (11) 基于范围的for循环

#### 1. for循环新语法

C++98/03中普通的for循环，语法格式：

```
for(表达式 1; 表达式 2; 表达式 3)
{
    // 循环体
}

```

C++11基于范围的for循环，语法格式：

```
for (declaration : expression)
{
    // 循环体
}

```

**在上面的语法格式中declaration表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。**

```
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (auto value : t)
    {
        cout << value << " ";
    }
    cout << endl;

    return 0;
}
```

在上面的例子中，**是将容器中遍历的当前元素拷贝到了声明的变量value中，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用。**

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    cout << "遍历修改之前的容器: ";
    for (auto &value : t)
    {
        cout << value++ << " ";
    }
    cout << endl << "遍历修改之后的容器: ";

    for (auto &value : t)
    {
        cout << value << " ";
    }
    cout << endl;

    return 0;
}
```

对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用const定义保存元素数据的变量，在定义的时候建议使用const auto &，这样相对于const auto效率要更高一些。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (const auto& value : t)
    {
        cout << value << " ";
    }

    return 0;
}
```

#### 2. 使用细节

##### 2.1 关系型容器

使用基于范围的for循环有一些需要注意的细节，先来看一下对关系型容器map的遍历：

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    // 基于范围的for循环方式
    for (auto& it : m)
    {
        cout << "id: " << it.first << ", name: " << it.second << endl;
    }

    // 普通的for循环方式
    for (auto it = m.begin(); it != m.end(); ++it)
    {
        cout << "id: " << it->first << ", name: " << it->second << endl;
    }

    return 0;
}
```

在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：

1. **使用普通的for循环方式（基于迭代器）遍历关联性容器， auto自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）：**
       it->first
       it->second
2. **使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：**
       it.first
       it.second

##### 2.2 元素只读

**对应<u>set容器</u>来说，内部元素都是只读的，这是由容器的特性决定的，因此在for循环中auto&会被视为const auto & 。**

```c++
#include <iostream>
#include <set>
using namespace std;

int main(void)
{
    set<int> st{ 1,2,3,4,5,6 };
    for (auto &item : st) 
    {
        cout << item++ << endl;		// error, 不能给常量赋值
    }
    return 0;
}
```

除此之外，**在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。**

```c++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    for (auto& item : m)
    {
        // item.first 是一个常量
        cout << "id: " << item.first++ << ", name: " << item.second << endl;  // error
    }

    return 0;
}
```

##### 2.3 访问次数

基于范围的for循环遍历的对象可以是一个表达式或者容器/数组等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：

```c++
#include <iostream>
#include <vector>
using namespace std;

vector<int> v{ 1,2,3,4,5,6 };
vector<int>& getRange()
{
    cout << "get vector range..." << endl;
    return v;
}

int main(void)
{
    for (auto val : getRange())
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

**对应<u>*基于范围的for循环来说，冒号后边的表达式只会被执行一次*</u>。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。**

### (12) 可调用对象包装器、绑定器

#### 1. （难）可调用对象——四种

* 是一个函数指针

```c++
int print(int a, double b)
{
    cout << a << b << endl;
    return 0;
}
// 定义函数指针
int (*func)(int, double) = &print;
```



* 是一个具有operator()成员函数的类对象（仿函数）

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

struct Test
{
    // ()操作符重载
    void operator()(string msg)
    {
        cout << "msg: " << msg << endl;
    }
};

int main(void)
{
    Test t;
    t("我是要成为海贼王的男人!!!");	// 仿函数
    return 0;
}
```



* 是一个可被转换为函数指针的类对象

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

using func_ptr = void(*)(int, string);
struct Test
{
    static void print(int a, string b)
    {
        cout << "name: " << b << ", age: " << a << endl;
    }

    // 将类对象转换为函数指针,static编译就存在，如果不是static就会报错，因为只有执行才能有实例对象
    operator func_ptr()
    {
        return print;
    }
};

int main(void)
{
    Test t;
    // 对象转换为函数指针, 并调用
    t(19, "Monkey D. Luffy");

    return 0;
}
```



* 是一个类成员函数指针或者类成员指针

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

struct Test
{
	void print(int a, string b)
	{
		cout << "name: " << b << ", age: " << a << endl;
	}
	int m_num;
};

int main(void)
{
	// 定义类成员函数指针指向类成员函数
	void (Test:: * func_ptr)(int, string) = &Test::print;
	// 类成员指针指向类成员变量
	int Test::* obj_ptr = &Test::m_num;
	using objptr = int Test::*;
	objptr o1 = &Test::m_num;
	Test t;
	// 通过类成员函数指针调用类成员函数
	(t.*func_ptr)(19, "Monkey D. Luffy");

	// 通过类成员指针初始化类成员变量
	t.*obj_ptr = 1;
	t.*o1 = 2;
	cout << "number is: " << t.m_num << endl;

	/* 等价于使用using
	using funcptr = void (Test::*)(int, string);
	funcptr f1 = &Test::print;
	Test t;
	(t.*f1)(18, "QQ");

	// int类型的指针
	using objptr = int Test::*;
	objptr o1 = &Test::m_num;
	Test t;
	t.*o1 = 2;

	*/
	return 0;
}
```

#### 2. 可调用对象包装器——function

**std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。**

可以使用对象包装器的可调用对象

1. 包装普通函数
2. 包装类的静态函数
3. 包装仿函数
4. 包装转换为函数指针的对象

##### 2.1 (重点)基本用法

std::function必须要包含一个叫做functional的头文件，可调用对象包装器使用语法如下:

```c++
#include <functional>
std::function<返回值类型(参数类型列表)> diy_name = 可调用对象;
```



```c++
#include <iostream>
#include <functional>
using namespace std;

int add(int a, int b)
{
	cout << a << " + " << b << " = " << a + b << endl;
	return a + b;
}

class T1
{
public:
	static int sub(int a, int b)
	{
		cout << a << " - " << b << " = " << a - b << endl;
		return a - b;
	}
};

using funcptr = int(*)(int, int);
class T2
{
public:
	int operator()(int a, int b)
	{
		cout << a << " * " << b << " = " << a * b << endl;
		return a * b;
	}
	operator funcptr() {
		return sub;
	}
	static int sub(int a, int b)
	{
		cout << a << " - " << b << " = " << a - b << endl;
		return a - b;
	}
};

int main(void)
{
	// 绑定一个普通函数
	function<int(int, int)> f1 = add;
	// 绑定以静态类成员函数
	function<int(int, int)> f2 = T1::sub;
	// 绑定一个仿函数
	T2 t1;
	function<int(int, int)> f3 = t1;
	// 包装转换为函数指针的对象
	T2 t2;
	function<int(int, int)> f4 = t2;


	// 函数调用
	f1(9, 3);
	f2(9, 3);
	f3(9, 3);
	f4(10, 3);
	return 0;
}
```

**通过测试代码可以得到结论：std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。**

##### 2.2 (重点)作为回调函数使用

因为回调函数本身就是通过函数指针实现的，**使用对象包装器可以取代函数指针的作用**，来看一下下面的例子：

```c++
#include <iostream>
#include <functional>
using namespace std;
class A
{
public:
	// 构造函数参数是一个包装器对象
	A(const function<void(int, int)>& f) : callback(f)
	{
	}

	void notify(int a, int b)
	{
		callback(a, b); // 调用通过构造函数得到的函数指针
	}
private:
	function<void(int, int)> callback; //
};
int add(int a, int b)
{
	cout << a << " + " << b << " = " << a + b << endl;
	return a + b;
}

class T1
{
public:
	static int sub(int a, int b)
	{
		cout << a << " - " << b << " = " << a - b << endl;
		return a - b;
	}
};

using funcptr = int(*)(int, int);
class T2
{
public:
	int operator()(int a, int b)
	{
		cout << a << " * " << b << " = " << a * b << endl;
		return a * b;
	}
	operator funcptr() {
		return sub;
	}
	static int sub(int a, int b)
	{
		cout << a << " - " << b << " = " << a - b << endl;
		return a - b;
	}
};

int main(void)
{
	// 绑定一个普通函数
	function<int(int, int)> f1 = add;
	// 绑定以静态类成员函数
	function<int(int, int)> f2 = T1::sub;
	// 绑定一个仿函数
	T2 t1;
	function<int(int, int)> f3 = t1;
	// 包装转换为函数指针的对象
	T2 t2;
	function<int(int, int)> f4 = t2;


	// 函数调用
	f1(9, 3);
	f2(9, 3);
	f3(9, 3);
	f4(10, 3);

	// 作为回调函数使用
	A aa(f1);
	aa.notify(3, 9);

	A ab(f2);
	ab.notify(3, 10);

	A ac(f3);
	ac.notify(3, 11);

	A ad(f4);
	ad.notify(3, 12);
	return 0;
}
```

<u>**注意返回类型，参数要统一**</u>

通过上面的例子可以看出，使用对象包装器std::function可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。

另外，使用std::function作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性。

##### 2.3 (重点)绑定器

**std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，**并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用：

1. **<u>*将可调用对象与其参数一起绑定成一个仿函数*</u>。**
2. **将多元（参数个数为n，n>1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。**

绑定器函数使用语法格式如下：

```c++
// 绑定非类成员函数/变量/静态函数
auto f = std::bind(可调用对象地址, 绑定的参数/占位符);
// 绑定类成员函/变量
auto f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);
```

下面来看一个关于绑定器的实际使用的例子：

```c++
#include <iostream>
#include <functional>
using namespace std;

void output(int x, int y)
{
    cout << x << " " << y << endl;
}

int main(void)
{
    // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数
    bind(output, 1, 2)();
    bind(output, placeholders::_1, 2)(10);
    bind(output, 2, placeholders::_1)(10);

    // error, 调用时没有第二个参数
    // bind(output, 2, placeholders::_2)(10);
    // 调用时第一个参数10被吞掉了，没有被使用
    bind(output, 2, placeholders::_2)(10, 20);

    bind(output, placeholders::_1, placeholders::_2)(10, 20);
    bind(output, placeholders::_2, placeholders::_1)(10, 20);


    return 0;
}
```

示例代码执行的结果:

```c++
1  2		// bind(output, 1, 2)();
10 2		// bind(output, placeholders::_1, 2)(10);
2 10		// bind(output, 2, placeholders::_1)(10);
2 20		// bind(output, 2, placeholders::_2)(10, 20);
10 20		// bind(output, placeholders::_1, placeholders::_2)(10, 20);
20 10		// bind(output, placeholders::_2, placeholders::_1)(10, 20);

```

**std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。**

placeholders::_1是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5等……

```c++
#include <iostream>
#include <functional>
using namespace std;

void callFunc(int x, int y, const function<void(int, int)>& f)
{
	if (x % 2 == 0)
	{
		f(x, y);
	}
}

void output_add(int x, int y)
{
	cout << "x:" << x << ",y:" << y << ",x+y=" << x + y << endl;
}

int main(void)
{
	// 使用绑定器绑定可调用对象和参数
	for (int i = 0; i < 10; ++i)
	{
        //绑定output_add传给callFunc
        // callFunc中的i被覆盖
		auto f = bind(output_add, i + 100, i + 200);
		callFunc(i, i, f);
        // 正确写法
		auto f1 = bind(output_add, placeholders::_1, placeholders::_2);
		callFunc(i, i, f1);
	}
	cout << endl;
	return 0;
}
```

###### 	成员变量(函数)的绑定——得到仿函数

```c++
#include <iostream>
#include <functional>
#include<string>
using namespace std;
class Test {
public:
	void print(string x, string y) {
		cout << x + y << endl;
	}
	int m_num{ 100 };
};

int main(void)
{
	//成员函数绑定
	Test t;
	auto f1 = bind(&Test::print, &t, "I ", placeholders::_1);
	function<void(string, string)> f11 = f1;
	f1("love");

	//成员变量
	auto f2 = bind(&Test::m_num, &t);
	// 无参void，绑定器可读可写，包装器可读可写要加&
	// 绑定器和包装器类型不一样，绑定器是仿函数，包装器将仿函数包装
	function<int&(void)> f22 = f2; //编译器自动进行了隐式类型转换

	cout << f2() << endl;
	f2() = 666;
	cout << f2() << endl;

	return 0;
}
```

### (13) Lambda表达式

#### 1. 基本用法

lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式简单归纳如下：

```
[capture](params) opt -> ret {body;};
```

其中**capture是捕获列表**，**params是参数列表**，**opt是函数选项**，**ret是返回值类型**，**body是函数体**。

1. 捕获列表[]: 捕获一定范围内的变量

2. 参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。

```c++
auto f = [](){return 1;}	// 没有参数, 参数列表为空
auto f = []{return 1;}		// 没有参数, 参数列表省略不写
```

3. opt 选项， 不需要可以省略

* mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
* exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();

4. 返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。
5. 函数体：函数的实现，这部分不能省略，但函数体可以为空。 

####  2. 捕获列表

lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：

* [] - 不捕捉任何变量
* [&] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (**按引用捕获**)
* [=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (**按值捕获**)
  * **拷贝的副本在匿名函数体内部是只读的**
* [=, &foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo
* [bar] - 按值捕获 bar 变量, 同时不捕获其他变量
* [&bar] - 按引用捕获 bar 变量, 同时不捕获其他变量
* [this] - 捕获当前类中的this指针
  * 让lambda表达式拥有和当前类成员函数同样的访问权限
  * 如果已经使用了 & 或者 =, 默认添加此选项

```c++
#include <iostream>
#include <functional>
using namespace std;

class Test
{
public:
    void output(int x, int y)
    {
        auto x1 = [] {return m_number; };                      // error
        auto x2 = [=] {return m_number + x + y; };             // ok
        auto x3 = [&] {return m_number + x + y; };             // ok
        auto x4 = [this] {return m_number; };                  // ok
        auto x5 = [this] {return m_number + x + y; };          // error
        auto x6 = [this, x, y] {return m_number + x + y; };    // ok
        auto x7 = [this] {return m_number++; };                // ok
    }
    int m_number = 100;
};
/*
x1：错误，没有捕获外部变量，不能使用类成员 m_number
x2：正确，以值拷贝的方式捕获所有外部变量
x3：正确，以引用的方式捕获所有外部变量
x4：正确，捕获this指针，可访问对象内部成员
x5：错误，捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。
x6：正确，捕获this指针，x，y
x7：正确，捕获this指针，并且可以修改对象内部变量的值
*/
```

#### 3. 返回值

很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。

```c++
// 完整的lambda表达式定义
auto f = [](int a) -> int
{
    return a+10;  
};

// 忽略返回值的lambda表达式定义
auto f = [](int a)
{
    return a+10;  
};
```

一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是**labmda表达式不能通过列表初始化自动推导出返回值类型。**

```c++
// ok，可以自动推导出返回值类型
auto f = [](int i)
{
    return i;
}

// error，不能推导出返回值类型
auto f1 = []()
{
    return {1, 2};	// 基于列表初始化推导返回值，错误
}
```



#### 4. 函数本质

使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，**被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性**

```c++
int a = 0;
auto f1 = [=] {return a++; };              // error, 按值捕获外部变量, a是只读的
auto f2 = [=]()mutable {return a++; };     // ok
```

最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:

1. **lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。**
2. **按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。**

<u>**mutable选项的作用就在于取消operator()的const属性。**</u>

因为<u>*lambda表达式在C++中*</u>会被看做是一个<u>*仿函数*</u>，因此可以使用<u>*std::function和std::bind来存储和操作lambda表达式*</u>：

```c++
#include <iostream>
#include <functional>
using namespace std;

int main(void)
{
    // 没有捕获类型，是指针
    // 包装可调用函数
    std::function<int(int)> f1 = [](int a) {return a; };
    // 绑定可调用函数，可以降元操作
    std::function<int(int)> f2 = bind([](int a) {return a; }, placeholders::_1);

    // 函数调用
    cout << f1(100) << endl;
    cout << f2(200) << endl;
    return 0;
}
```

**<u>对于*没有捕获任何变量的lambda表达式*，还可以转换成一个普通的函数指针：</u>**

```c++
using func_ptr = int(*)(int);
// 没有捕获任何外部变量的匿名函数
func_ptr f = [](int a)
{
    return a;  
};
// 函数调用
f(1314);
```

其他使用注意事项

```c++
void func(int x, int y)
{
	int a = 7;
	int b = 9;
    //lambda是右值引用
    // 想用到外面的b，得用mutable
    //如果需要调用lambda表达式得加()传参数
    //因为捕获=，值拷贝，所以输出的是10，9（外面的不便）
	[=, &x](int z)mutable {
		int c = a;
		int d = x;
        b++;
		cout << "b:" << b << endl;
	}(88);
	cout < "b:" << b < endl;
}
	
int main(void){
	func(1, 2);
	return 0;
}
```

### (14) 右值引用

#### 1. 右值

C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为 **&&**。在介绍右值引用类型之前先要了解什么是左值和右值：

* lvalue 是loactor value的缩写，rvalue 是 read value的缩写

* **左值是指存储在内存中、有明确存储地址（可取地址）的数据；**

* **右值是指可以提供数据值的数据（不可取地址）**；

通过描述可以看出，区分左值与右值的便捷方法是：**可以对表达式取地址（&）就是左值，否则为右值** 。***所有有名字的变量或对象都是左值，而右值是匿名的***。

C++11 中右值可以分为两种：一个是将亡值（ xvalue, expiring value），另一个则是纯右值（ prvalue, PureRvalue）：

* 纯右值：**非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等**
* 将亡值：**与右值引用相关的表达式，比如，T&&类型函数的返回值、 std::move 的返回值等**

```c++
#include <iostream>
#include <functional>
using namespace std;

int main(void)
{
	//左值
	int num = 9;
	//左值引用
	int& a = num;
	//右值
	//右值引用
	int&& b = 8;
	//常量右值引用
	const int&& d = 6;
	// 常量左值引用
	const int& c = num;
	const int& f = b;
	const int& g = d;

	const int&& e = b;//error,右值引用不能赋值给常量右值引用
	int&& f = b;//error,右值引用不能赋值给右值引用
	return 0;
}
```



#### 2. 右值引用

右值引用就是对一个右值进行引用的类型。因为<u>右值是匿名</u>的，所以我们只能通过引用的方式找到它。**<u>无论声明左值引用还是右值引用都必须立即进行初始化</u>，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”**，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

关于右值引用的使用，参考代码如下：

```c++
#include <iostream>
using namespace std;

int&& value = 520;
class Test
{
public:
    Test()
    {
        cout << "construct: my name is jerry" << endl;
    }
    Test(const Test& a)
    {
        cout << "copy construct: my name is tom" << endl;
    }
};

Test getObj()
{
    return Test();
}

int main()
{
    int a1;
    int &&a2 = a1;        // error
    Test& t = getObj();   // error
    Test && t = getObj();
    const Test& t = getObj();
    return 0;
}
/*
在上面的例子中int&& value = 520;里面520是纯右值，value是对字面量520这个右值的引用。

在int &&a2 = a1;中a1虽然写在了=右边，但是它仍然是一个左值，使用左值初始化一个右值引用类型是不合法的。

在Test& t = getObj()这句代码中语法是错误的，右值不能给普通的左值引用赋值。

在Test && t = getObj();中getObj()返回的临时对象被称之为将亡值，t是这个将亡值的右值引用。

const Test& t = getObj()这句代码的语法是正确的，常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。
*/
```





```c++
#include <iostream>
using namespace std;

int&& value = 520;
class Test
{
public:
	Test() :m_num(new int(100))
	{
		cout << "construct: my name is jerry" << endl;
		printf("m num 地址：%p\n", m_num);
	}
	Test(const Test& a) :m_num(new int(*a.m_num))
	{
		cout << "copy construct: my name is tom" << endl;
	}
	//移动构造函数->复用其他对象中的资源（堆内存）
	// m_num, 浅拷贝
	//Test(Test&& a) : m_num(a.m_num)
	//{
	//	a.m_num = nullptr;
	//	cout << "move construct..." << endl;
	//}
	~Test() {
		cout << "destruct Test class ..." << endl;
		delete m_num;
	}
	int* m_num;
};
Test getObj1()
{
	Test t;
	return t;
}
//将亡值
Test getObj2()
{
	return Test();
}
//将亡值
Test&& getObj3()
{
	return Test();
}
int main()
{
	//要求右侧的对象是一个临时对象，才会调用移动构造函数
	//如果没有移动构造函数，就会调用拷贝构造函数，移动构造只会续命即将释放的堆内存资源
	Test t = getObj1();
	cout << endl;
	Test&& t1 = getObj1();
	printf("m num 地址：%p\n", t1.m_num);
	cout << endl;

	// 如果没有移动构造函数，使用右值引用初始化要求更高一些
	// 要求右侧是一个临时的不能取地址的对象
	// t2进行续命t1将要释放的所有资源
	Test&& t2 = getObj2();
	printf("m num 地址：%p\n", t2.m_num);

	return 0;
}
```

#### 3. 性能优化

在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。

再来修改一下上面的实例代码：



```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() : m_num(new int(100))
    {
        cout << "construct: my name is jerry" << endl;
    }
    Test(const Test& a) : m_num(new int(*a.m_num))
    {
        cout << "copy construct: my name is tom" << endl;
    }

    ~Test()
    {
        delete m_num;
    }

    int* m_num;
};

Test getObj()
{
    Test t;
    return t;
}

int main()
{
    Test t = getObj();
    cout << "t.m_num: " << *t.m_num << endl;
    return 0;
};
```
测试代码执行的结果为（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）:

> construct: my name is jerry
> copy construct: my name is tom
> t.m_num: 100

通过输出的结果可以看到调用==Test t = getObj();==的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到了对象t，在==getObj()==函数中创建的对象虽然进行了内存的申请操作，但是没有使用就释放掉了。如果能够使用临时对象已经申请的资源，既能节省资源，还能节省资源申请和释放的时间，如果要执行这样的操作就需要使用右值引用了，==右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。==



```c++
#include <iostream>
using namespace std;

class Test
{
public:
    Test() : m_num(new int(100))
    {
        cout << "construct: my name is jerry" << endl;
    }

    Test(const Test& a) : m_num(new int(*a.m_num))
    {
        cout << "copy construct: my name is tom" << endl;
    }

    // 添加移动构造函数
    Test(Test&& a) : m_num(a.m_num)
    {
        a.m_num = nullptr;
        cout << "move construct: my name is sunny" << endl;
    }

    ~Test()
    {
        delete m_num;
        cout << "destruct Test class ..." << endl;
    }

    int* m_num;
};

Test getObj()
{
    Test t;
    return t;
}

int main()
{
    Test t = getObj();//编译器优化
    cout << "t.m_num: " << *t.m_num << endl;
    return 0;
};
```


测试代码执行的结果如下（当时使用的vs版本为2019，vs2022已无法看到相同的输出，代码被优化了）:

> construct: my name is jerry
> move construct: my name is sunny
> destruct Test class ...
> t.m_num: 100
> destruct Test class ...

**在C++中，当你从函数返回一个对象时，如果满足某些条件，编译器会尝试使用移动构造函数（如果存在）来避免不必要的复制。这种机制被称为返回值优化（RVO, Return Value Optimization）或更泛化地说，是复制消除（Copy Elision）。**



通过修改，在上面的代码给Test类添加了==移动构造函数（参数为右值引用类型）==，这样在进行==Test t = getObj();==操作的时候并没有调用拷贝构造函数进行深拷贝，而是调用了移动构造函数，在这个函数中只是进行了浅拷贝，没有对临时对象进行深拷贝，提高了性能。

在测试程序中getObj()的返回值就是一个将亡值，也就是说是一个右值，在进行赋值操作的时候如果=右边是一个右值，那么移动构造函数就会被调用。==移动构造中使用了右值引用，会将临时对象中的堆内存地址的所有权转移给对象t，这块内存被成功续命，因此在t对象中还可以继续使用这块内存。==

> ==对于需要动态申请大量资源的类，应该设计移动构造函数，以提高程序效率。需要注意的是，我们一般在提供移动构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造函数。==








#### 4. (重点)&& 的特性

在C++中，并不是所有情况下 && 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为T&&，如果是自动类型推导需要指定为auto &&，在这两种场景下 &&被称作未定的引用类型。***<u>另外还有一点需要额外注意const T&&表示一个右值引用，不是未定引用类型</u>***。

先来看第一个例子，在函数模板中使用&&:

```c++
template<typename T>
void f(T&& param);
void f1(const T&& param); //一定是右值引用
f(10); 	
int x = 10;
f(x); 
f1(x);	// error, x是左值
f1(10); // ok, 10是右值

/*
第4行中，对于f(10)来说传入的实参10是右值，因此T&&表示右值引用
第6行中，对于f(x)来说传入的实参是x是左值，因此T&&表示左值引用
第7行中，f1(x)的参数是const T&&不是未定引用类型，不需要推导，本身就表示一个右值引用
*/
```

再来看第二个例子:

```c++
int main()
{
    int x = 520, y = 1314;
    auto&& v1 = x;
    auto&& v2 = 250;
    decltype(x)&& v3 = y;   // error
    cout << "v1: " << v1 << ", v2: " << v2 << endl;
    return 0;
};
/*
第4行中 auto&&表示一个整形的左值引用
第5行中 auto&&表示一个整形的右值引用
第6行中decltype(x)&&等价于int&&是一个右值引用不是未定引用类型，y是一个左值，不能使用左值初始化一个右值引用类型。
*/
```

由于上述代码中存在T&&或者auto&&这种未定引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，**在进行类型推导时右值引用类型（&&）会发生变化，这种变化被称为<u>*引用折叠*</u>**。在C++11中引用折叠的规则如下：

* <u>**通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型**</u>

* <u>**通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&& 或者 auto&& 得到的是一个左值引用类型**</u>

```c++
int&& a1 = 5; //右值引用
auto&& bb = a1;//左值引用
auto&& bb1 = 5;//右值引用

int a2 = 5;//左值
int &a3 = a2;//左值引用
auto&& cc = a3;//左值引用
auto&& cc1 = a2;//左值引用

const int& s1 = 100;//常量左值引用
const int&& s2 = 100;//常量右值引用
auto&& dd = s1;//常量左值引用
auto&& ee = s2;//常量左值引用

const auto&& x = 5;//常量右值引用

```

再看最后一个例子，代码如下：

```c++
#include <iostream>
using namespace std;

void printValue(int &i)
{
    cout << "l-value: " << i << endl;
}

void printValue(int &&i)
{
    cout << "r-value: " << i << endl;
}
// 传进来是右值引用，但是再传printValue——>int&i = k，此时k是左值引用
void forward(int &&k)
{
    printValue(k);
}

int main()
{
    int i = 520;
    printValue(i);
    printValue(1314);
    forward(250);

    return 0;
};
```

测试代码输出的结果如下:左右左

```c**
l-value: 520
r-value: 1314
l-value: 250
```

根据测试代码可以得知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重置函数（printValue），函数forward()接收的是一个右值，但是在这个函数中调用函数printValue()时，参数k变成了一个命名对象，编译器会将其当做左值来处理。

最后总结一下关于&&的使用：

* **左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。**
* **编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。**
* **auto&&或者函数参数类型自动推导的T&&是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。**
* **通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型，其余都是左值引用类型。**

### (15) 转移和完美转发

#### 1. move

在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，**使用<u>*std::move方法可以将左值转换为右值*</u>（这里是将亡值）。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，<u>*将对象的状态或者所有权从一个对象转移到另一个对象*</u>，<u>*只是转移，没有内存拷贝*</u>。**

从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);，函数原型如下:

```c++
template<class _Ty>
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) _NOEXCEPT
{	// forward _Arg as movable
    return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
}
```

使用方法如下：

```c++
class Test
{
public：
    Test(){}
    ......
}
int main()
{
    Test t;
    Test && v1 = t;          // error
    Test && v2 = move(t);    // ok
    return 0;
}
/*
在第4行中，使用左值初始化右值引用，因此语法是错误的
在第5行中，使用move()函数将左值转换为了右值，这样就可以初始化右值引用了。
```

假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：

```c++
list<string> ls;
ls.push_back("hello");
ls.push_back("world");
......
list<string> ls1 = ls;        // 需要拷贝, 效率低
list<string> ls2 = move(ls); // 使用权转移，效率高
```

<u>如果不使用std::move，拷贝的代价很大，性能较低</u>。***使用move几乎没有任何代价，只是转换了资源的所有权***。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（T::T(T&& another)）和和具有移动语义的赋值函数（T&& T::operator=(T&& rhs)），在构造对象和赋值的时候尽可能的进行资源的重复利用，因为它们都是接收一个右值引用参数。

#### 2. forward

右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，<u>在函数内部转发该参数给内部其他函数时，*它就变成一个左值，并不是原来的类型了*。如果需要按照参数原来的类型转发到另一个函数</u>，可以使用C++11提供的std::forward()函数，**该函数实现的功能称之为完美转发**。

```c++
// 函数原型
template <class T> T&& forward (typename remove_reference<T>::type& t) noexcept;
template <class T> T&& forward (typename remove_reference<T>::type&& t) noexcept;

// 精简之后的样子
std::forward<T>(t);
```

* **当T为左值引用类型时，t将被转换为T类型的左值**
* **当T不是左值引用类型时，t将被转换为T类型的右值**

下面通过一个例子演示一下关于forward的使用:

```c++
#include <iostream>
using namespace std;

template<typename T>
void printValue(T& t)
{
    cout << "l-value: " << t << endl;
}

template<typename T>
void printValue(T&& t)
{
    cout << "r-value: " << t << endl;
}

template<typename T>
void testForward(T && v)//520传进来是右
{
    printValue(v);//左
    printValue(move(v));//右
    printValue(forward<T>(v));//右
    cout << endl;
}

int main()
{
    testForward(520);
    int num = 1314;
    testForward(num);// 传进来是左，转换后是左、右、左
    testForward(forward<int>(num));//num是左值，但不是左值引用。forward后变为右值
    testForward(forward<int&>(num));//num是左值引用，forward后变为左值
    testForward(forward<int&&>(num));//num是右值引用，forward后变为右值

    return 0;
}
```

测试代码打印的结果如下:

```c++
l-value: 520
r-value: 520
r-value: 520

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314


testForward(520);函数的形参为未定引用类型T&&，实参为右值，初始化后被推导为一个右值引用

    printValue(v);已命名的右值v，编译器会视为左值处理，实参为左值
    printValue(move(v));已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值
    printValue(forward<T>(v));forward的模板参数为右值引用，最终得到一个右值，实参为``右值`

testForward(num);函数的形参为未定引用类型T&&，实参为左值，初始化后被推导为一个左值引用

    printValue(v);实参为左值
    printValue(move(v));通过move将左值转换为右值，实参为右值
    printValue(forward<T>(v));forward的模板参数为左值引用，最终得到一个左值引用，实参为左值

testForward(forward<int>(num));forward的模板类型为int，最终会得到一个右值，函数的形参为未定引用类型T&&被右值初始化后得到一个右值引用类型

    printValue(v);已命名的右值v，编译器会视为左值处理，实参为左值
    printValue(move(v));已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值
    printValue(forward<T>(v));forward的模板参数为右值引用，最终得到一个右值，实参为右值

testForward(forward<int&>(num));forward的模板类型为int&，最终会得到一个左值，函数的形参为未定引用类型T&&被左值初始化后得到一个左值引用类型

    printValue(v);实参为左值
    printValue(move(v));通过move将左值转换为右值，实参为右值
    printValue(forward<T>(v));forward的模板参数为左值引用，最终得到一个左值，实参为左值

testForward(forward<int&&>(num));forward的模板类型为int&&，最终会得到一个右值，函数的形参为未定引用类型T&&被右值初始化后得到一个右值引用类型

    printValue(v);已命名的右值v，编译器会视为左值处理，实参为左值
    printValue(move(v));已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值
    printValue(forward<T>(v));forward的模板参数为右值引用，最终得到一个右值，实参为右值
```

### (16) (重点)共享智能指针

在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<u>**智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。*智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。***</u>

C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<memory>：

* **std::shared_ptr：共享的智能指针**
* **std::unique_ptr：独占的智能指针**
* **std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。**

#### 1. shared_ptr的初始化

共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count，函数原型如下：

```c++
// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。
long use_count() const noexcept;
```

##### 1.1 通过构造函数初始化

```c++
// shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:
std::shared_ptr<T> 智能指针名字(创建堆内存);
```

测试代码如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    // 使用智能指针管理一块 int 型的堆内存
    shared_ptr<int> ptr1(new int(520));
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;
    // 使用智能指针管理一块字符数组对应的堆内存
    shared_ptr<char> ptr2(new char[12]);
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;
    // 创建智能指针对象, 不管理任何内存
    shared_ptr<int> ptr3;
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;
    // 创建智能指针对象, 初始化为空
    shared_ptr<int> ptr4(nullptr);
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;

    return 0;
}
```

测试代码输出的结果如下:

```
ptr1管理的内存引用计数: 1
ptr2管理的内存引用计数: 1
ptr3管理的内存引用计数: 0
ptr4管理的内存引用计数: 0
```

**如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1。<u>另外，不要使用一个原始指针初始化多个shared_ptr。</u>**

```c++
int *p = new int;
shared_ptr<int> p1(p);
shared_ptr<int> p2(p);		// error, 编译不会报错, 运行会出错
```

##### 1.2 通过拷贝和移动构造函数初始化

当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。

```c++
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr<int> ptr1(new int(520));
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;
    //调用拷贝构造函数
    shared_ptr<int> ptr2(ptr1);
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;
    shared_ptr<int> ptr3 = ptr1;
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;
    //调用移动构造函数
    shared_ptr<int> ptr4(std::move(ptr1));
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;
    std::shared_ptr<int> ptr5 = std::move(ptr2);
    cout << "ptr5管理的内存引用计数: " << ptr5.use_count() << endl;

    return 0;
}
```

测试程序输入的结果：

```
ptr1管理的内存引用计数: 1
ptr2管理的内存引用计数: 2
ptr3管理的内存引用计数: 3
ptr4管理的内存引用计数: 3
ptr5管理的内存引用计数: 3
```

***如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；*** **<u>如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</u>**

##### 1.3 通过std::make_shared初始化

通过C++提供的std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：

```c++
template< class T, class... Args >
shared_ptr<T> make_shared( Args&&... args );

T：模板参数的数据类型
Args&&... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定
```

测试代码如下:

```c++
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class Test
{
public:
    Test() 
    {
        cout << "construct Test..." << endl;
    }
    Test(int x) 
    {
        cout << "construct Test, x = " << x << endl;
    }
    Test(string str) 
    {
        cout << "construct Test, str = " << str << endl;
    }
    ~Test()
    {
        cout << "destruct Test ..." << endl;
    }
};

int main()
{
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr<int> ptr1 = make_shared<int>(520);
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;

    shared_ptr<Test> ptr2 = make_shared<Test>();
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;

    shared_ptr<Test> ptr3 = make_shared<Test>(520);
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;

    shared_ptr<Test> ptr4 = make_shared<Test>("我是要成为海贼王的男人!!!");
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;
    return 0;
}
```

**使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。<u>如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</u>**

##### 1.4 通过 reset方法初始化

共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：

```c++
void reset() noexcept;

template< class Y >
void reset( Y* ptr );

template< class Y, class Deleter >
void reset( Y* ptr, Deleter d );

template< class Y, class Deleter, class Alloc >
void reset( Y* ptr, Deleter d, Alloc alloc );

ptr：指向要取得所有权的对象的指针
d：指向要取得所有权的对象的指针
aloc：内部存储所用的分配器
```

测试代码如下：

```c++
#include <iostream>
#include <string>
#include <memory>
using namespace std;

int main()
{
    // 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1
    shared_ptr<int> ptr1 = make_shared<int>(520);
    shared_ptr<int> ptr2 = ptr1;
    shared_ptr<int> ptr3 = ptr1;
    shared_ptr<int> ptr4 = ptr1;
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;

    ptr4.reset();
    cout << "ptr1管理的内存引用计数: " << ptr1.use_count() << endl;
    cout << "ptr2管理的内存引用计数: " << ptr2.use_count() << endl;
    cout << "ptr3管理的内存引用计数: " << ptr3.use_count() << endl;
    cout << "ptr4管理的内存引用计数: " << ptr4.use_count() << endl;

    shared_ptr<int> ptr5;
    ptr5.reset(new int(250));
    cout << "ptr5管理的内存引用计数: " << ptr5.use_count() << endl;

    return 0;
}
```

测试代码输入的结果:

```
ptr1管理的内存引用计数: 4
ptr2管理的内存引用计数: 4
ptr3管理的内存引用计数: 4
ptr4管理的内存引用计数: 4
    
ptr1管理的内存引用计数: 3
ptr2管理的内存引用计数: 3
ptr3管理的内存引用计数: 3
ptr4管理的内存引用计数: 0
    
ptr5管理的内存引用计数: 1
```

**对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。**

##### 1.5 获取原始指针

通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的get()方法，其函数原型如下：

```c++
T* get() const noexcept;
```


测试代码如下:

```c++
#include <iostream>
#include <string>
#include <memory>
using namespace std;

int main()
{
    int len = 128;
    shared_ptr<char> ptr(new char[len]);
    // 得到指针的原始地址
    char* add = ptr.get();
    memset(add, 0, len);
    strcpy(add, "我是要成为海贼王的男人!!!");
    cout << "string: " << add << endl;
    
    shared_ptr<int> p(new int);
    *p = 100;
    cout << *p.get() << "  " << *p << endl;
    
    return 0;
}
```

#### 2. 指定删除器

当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。

```c++
#include <iostream>
#include <memory>
using namespace std;

// 自定义删除器函数，释放int型内存
void deleteIntPtr(int* p)
{
    delete p;
    cout << "int 型内存被释放了...";
}

int main()
{
    shared_ptr<int> ptr(new int(250), deleteIntPtr);
    return 0;
}
```

删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：

```c++
int main()
{
    shared_ptr<int> ptr(new int(250), [](int* p) {delete p; });
    return 0;
}

```

在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。

在C++11中使用shared_ptr管理动态数组时，需要指定删除器，因为std::shared_ptr的默认删除器不支持数组对象，具体的处理代码如下：

```c++
int main()
{
    shared_ptr<int> ptr(new int[10], [](int* p) {delete[]p; });
    return 0;
}

```

在删除数组内存时，除了自己编写删除器，也可以使用C++提供的std::default_delete<T>()函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：

```c++
int main()
{
    shared_ptr<int> ptr(new int[10], default_delete<int[]>());
    return 0;
}

```

另外，我们还可以自己封装一个make_shared_array方法来让shared_ptr支持数组，代码如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

template <typename T>
shared_ptr<T> make_share_array(size_t size)
{
    // 返回匿名对象
    return shared_ptr<T>(new T[size], default_delete<T[]>());
}

int main()
{
    shared_ptr<int> ptr1 = make_share_array<int>(10);
    cout << ptr1.use_count() << endl;
    shared_ptr<char> ptr2 = make_share_array<char>(128);
    cout << ptr2.use_count() << endl;
    return 0;
}
```

### (17) 独占的智能指针

#### 1.初始化

std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。

```c++
// 通过构造函数初始化对象
unique_ptr<int> ptr1(new int(10));
// error, 不允许将一个unique_ptr赋值给另一个unique_ptr
unique_ptr<int> ptr2 = ptr1;
```

std::unique_ptr不允许复制，但是可以通过函数返回给其他的std::unique_ptr，还可以通过std::move来转译给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。

```c++
#include <iostream>
#include <memory>
using namespace std;

unique_ptr<int> func()
{
    return unique_ptr<int>(new int(520));
}

int main()
{
    // 通过构造函数初始化
    unique_ptr<int> ptr1(new int(10));
    // 通过转移所有权的方式初始化
    unique_ptr<int> ptr2 = move(ptr1);
    unique_ptr<int> ptr3 = func();

    return 0;
}
```


unique_ptr独占智能指针类也有一个reset方法，函数原型如下：

```c++
void reset( pointer ptr = pointer() ) noexcept;
```

使用reset方法可以让unique_ptr解除对原始内存的管理，也可以用来初始化一个独占的智能指针。

```c++
int main()
{
    unique_ptr<int> ptr1(new int(10));
    unique_ptr<int> ptr2 = move(ptr1);

    ptr1.reset();
    ptr2.reset(new int(250));

    return 0;
}
```

* ptr1.reset();解除对原始内存的管理
* ptr2.reset(new int(250));重新指定智能指针管理的原始内存

如果想要获取独占智能指针管理的原始地址，可以调用get()方法，函数原型如下：

```
pointer get() const noexcept;
```

```c++
int main()
{
    unique_ptr<int> ptr1(new int(10));
    unique_ptr<int> ptr2 = move(ptr1);

    ptr2.reset(new int(250));
    cout << *ptr2.get() << endl;	// 得到内存地址中存储的实际数值 250

    return 0;
}
```

#### 2.删除器

unique_ptr指定删除器和shared_ptr指定删除器是有区别的，unique_ptr指定删除器的时候需要确定删除器的类型，所以不能像shared_ptr那样直接指定删除器，举例说明：

```c++
shared_ptr<int> ptr1(new int(10), [](int*p) {delete p; });	// ok
unique_ptr<int> ptr1(new int(10), [](int*p) {delete p; });	// error

int main()
{
    using func_ptr = void(*)(int*);
    unique_ptr<int, func_ptr> ptr1(new int(10), [](int*p) {delete p; });

    return 0;
}
```

在上面的代码中第7行，func_ptr的类型和lambda表达式的类型是一致的。在lambda表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：

```c++
int main()
{
    using func_ptr = void(*)(int*);
    unique_ptr<int, func_ptr> ptr1(new int(10), [&](int*p) {delete p; });	// error
    return 0;
}
```

上面的代码中错误原因是这样的，在lambda表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：

```c++
int main()
{
    using func_ptr = void(*)(int*);
    unique_ptr<int, function<void(int*)>> ptr1(new int(10), [&](int*p) {delete p; });
    return 0;
}
```

```c++
//独占的智能指针可以管理数组类型的地址，能够自动释放
unique_ptr<Test []>ptr5(new Test [3]);
//在c++11中shared ptr不支持下面的写法，c++11以后才支持的
shared_ptr<Test []>ptr5(new Test [3]);
```

### (18) 弱引用智能指针

#### 1. 基本使用方法

弱引用智能指针std::weak_ptr可以看做是shared_ptr的助手，它不管理shared_ptr内部的指针。std::weak_ptr没有重载操作符*和->，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，**<u>它的主要作用就是作为一个旁观者监视shared_ptr中管理的资源是否存在。</u>**

##### 1.1 初始化

```c++
// 默认构造函数
constexpr weak_ptr() noexcept;
// 拷贝构造
weak_ptr (const weak_ptr& x) noexcept;
template <class U> weak_ptr (const weak_ptr<U>& x) noexcept;
// 通过shared_ptr对象构造
template <class U> weak_ptr (const shared_ptr<U>& x) noexcept;
```

在C++11中，weak_ptr的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> sp(new int);

    weak_ptr<int> wp1;
    weak_ptr<int> wp2(wp1);
    weak_ptr<int> wp3(sp);
    weak_ptr<int> wp4;
    wp4 = sp;
    weak_ptr<int> wp5;
    wp5 = wp3;
    
    return 0;
}
/*
weak_ptr<int> wp1;构造了一个空weak_ptr对象
weak_ptr<int> wp2(wp1);通过一个空weak_ptr对象构造了另一个空weak_ptr对象
weak_ptr<int> wp3(sp);通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象
wp4 = sp;通过一个shared_ptr对象构造了一个可用的weak_ptr实例对象（这是一个隐式类型转换）
wp5 = wp3;通过一个weak_ptr对象构造了一个可用的weak_ptr实例对象
```

##### 1.2 其他常用方法

###### 1.2.1 use_count()

通过调用std::weak_ptr类提供的use_count()方法可以获得当前所观测资源的引用计数，函数原型如下：

```
// 函数返回所监测的资源的引用计数
long int use_count() const noexcept;

```

修改一下上面的测试程序，添加打印资源引用计数的代码：

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> sp(new int);

    weak_ptr<int> wp1;
    weak_ptr<int> wp2(wp1);
    weak_ptr<int> wp3(sp);
    weak_ptr<int> wp4;
    wp4 = sp;
    weak_ptr<int> wp5;
    wp5 = wp3;

    cout << "use_count: " << endl;
    cout << "wp1: " << wp1.use_count() << endl;
    cout << "wp2: " << wp2.use_count() << endl;
    cout << "wp3: " << wp3.use_count() << endl;
    cout << "wp4: " << wp4.use_count() << endl;
    cout << "wp5: " << wp5.use_count() << endl;
    return 0;
}

/*测试程序输出的结果为:
use_count:
wp1: 0
wp2: 0
wp3: 1
wp4: 1
wp5: 1
```

通过打印的结果可以知道，虽然弱引用智能指针wp3、wp4、wp5监测的资源是同一个，但是它的引用计数并没有发生任何的变化，**也进一步证明了weak_ptr只是监测资源，并不管理资源。**



###### 1.2.2 expired()

通过调用std::weak_ptr类提供的expired()方法来判断观测的资源是否已经被释放，函数原型如下：

```c++
// 返回true表示资源已经被释放, 返回false表示资源没有被释放
bool expired() const noexcept;
```

函数的使用方法如下:

```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> shared(new int(10));
    weak_ptr<int> weak(shared);
    cout << "1. weak " << (weak.expired() ? "is" : "is not") << " expired" << endl;

    shared.reset();
    cout << "2. weak " << (weak.expired() ? "is" : "is not") << " expired" << endl;

    return 0;
}
测试代码输出的结果:
1. weak is not expired
2. weak is expired
```

weak_ptr监测的就是shared_ptr管理的资源，当共享智能指针调用shared.reset();之后管理的资源被释放，因此weak.expired()函数的结果返回true，表示监测的资源已经不存在了。

###### 1.2.3 lock()

通过调用std::weak_ptr类提供的lock()方法来获取管理所监测资源的shared_ptr对象，函数原型如下：

```
shared_ptr<element_type> lock() const noexcept;
```

函数的使用方法如下:



```c++
#include <iostream>
#include <memory>
using namespace std;

int main()
{
    shared_ptr<int> sp1, sp2;
    weak_ptr<int> wp;
    sp1 = std::make_shared<int>(520);
    wp = sp1;
    sp2 = wp.lock();
    cout << "use_count: " << wp.use_count() << endl;

    sp1.reset();
    cout << "use_count: " << wp.use_count() << endl;

    sp1 = wp.lock();
    cout << "use_count: " << wp.use_count() << endl;

    cout << "*sp1: " << *sp1 << endl;
    cout << "*sp2: " << *sp2 << endl;

    return 0;
}
测试代码输出的结果为:

use_count: 2
use_count: 1
use_count: 2
*sp1: 520
*sp2: 520
```
* sp2 = wp.lock();通过调用lock()方法得到一个用于管理weak_ptr对象所监测的资源的共享智能指针对象，使用这个对象初始化sp2，此时所监测资源的引用计数为2
* sp1.reset();共享智能指针sp1被重置，weak_ptr对象所监测的资源的引用计数减1
* sp1 = wp.lock();sp1重新被初始化，并且管理的还是weak_ptr对象所监测的资源，因此引用计数加1
* 共享智能指针对象sp1和sp2管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是520



###### 1.2.4 reset()

通过调用std::weak_ptr类提供的reset()方法来清空对象，使其不监测任何资源，函数原型如下：

```
void reset() noexcept;
```

函数的使用是非常简单的，示例代码如下：



```c++
#include <iostream>
#include <memory>
using namespace std;

int main() 
{
    shared_ptr<int> sp(new int(10));
    weak_ptr<int> wp(sp);
        cout << "1. wp " << (wp.expired() ? "is" : "is not") << " expired" << endl;
    wp.reset();
    cout << "2. wp " << (wp.expired() ? "is" : "is not") << " expired" << endl;

    return 0;
}
测试代码输出的结果为:

1. wp is not expired
2. wp is expired
```


weak_ptr对象sp被重置之后wp.reset();变成了空对象，不再监测任何资源，因此wp.expired()返回true
#### 2. 返回管理this的shared_ptr

如果在一个类中编写了一个函数，通过这个得到管理当前对象的共享智能指针，我们可能会写出如下代码：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct Test
{
    shared_ptr<Test> getSharedPtr()
    {
        return shared_ptr<Test>(this);
    }
    ~Test()
    {
        cout << "class Test is disstruct ..." << endl;
    }
};

int main() 
{
    shared_ptr<Test> sp1(new Test);
    cout << "use_count: " << sp1.use_count() << endl;
    shared_ptr<Test> sp2 = sp1->getSharedPtr();
    cout << "use_count: " << sp1.use_count() << endl;
    return 0;
}
执行上面的测试代码，运行中会出现异常，在终端还是能看到对应的日志输出：

use_count: 1
use_count: 1
class Test is disstruct ...
class Test is disstruct ...
```



通过输出的结果可以看到**一个对象被析构了两次**，其原因是这样的：在这个例子中使用**同一个指针this构造了两个智能指针对象sp1和sp2**，这二者之间是没有任何关系的，因为sp2并不是通过sp1初始化得到的实例对象。在离开作用域之后this将被构造的两个智能指针各自析构，导致重复析构的错误。

这个问题可以通过**weak_ptr来解决，通过wek_ptr返回管理this资源的共享智能指针对象shared_ptr**。C++11中为我们提供了一个模板类叫做<u>std::enable_shared_from_this<T></u>，这个类中有一个方法叫做shared_from_this()，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用weak_ptr来监测this对象，并通过调用weak_ptr的lock()方法返回一个shared_ptr对象。

修改之后的代码为：

```c++
#include <iostream>
#include <memory>
using namespace std;

// 继承
struct Test : public enable_shared_from_this<Test>
{
    shared_ptr<Test> getSharedPtr()
    {
        //调用方法
        return shared_from_this();//weakptr，lock
    }
    ~Test()
    {
        cout << "class Test is disstruct ..." << endl;
    }
};

int main() 
{
    shared_ptr<Test> sp1(new Test);
    cout << "use_count: " << sp1.use_count() << endl;
    shared_ptr<Test> sp2 = sp1->getSharedPtr();
    cout << "use_count: " << sp1.use_count() << endl;
    return 0;
}

测试代码输出的结果为:

use_count: 1
use_count: 2
class Test is disstruct ...
```

最后需要强调一个细节：**在调用enable_shared_from_this类的shared_from_this()方法之前，必须要先初始化函数内部weak_ptr对象，否则该函数无法返回一个有效的shared_ptr对象（具体处理方法可以参考上面的示例代码）。**

#### 3. 解决循环引用（共享指针嵌套）问题

智能指针如果循环引用会导致内存泄露，比如下面的例子：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct TA;
struct TB;

struct TA
{
    shared_ptr<TB> bptr;
    ~TA()
    {
        cout << "class TA is disstruct ..." << endl;
    }
};

struct TB
{
    shared_ptr<TA> aptr;
    ~TB()
    {
        cout << "class TB is disstruct ..." << endl;
    }
};

void testPtr()
{
    shared_ptr<TA> ap(new TA);
    shared_ptr<TB> bp(new TB);
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

    ap->bptr = bp;
    bp->aptr = ap;
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

}

int main()
{
    testPtr();
    return 0;
}

测试程序输出的结果如下:（没有析构）

TA object use_count: 1
TB object use_count: 1
TA object use_count: 2
TB object use_count: 2
```

在测试程序中**，共享智能指针ap、bp对TA、TB实例对象的引用计数变为2**，在共**<u>享智能指针离开作用域之后引用计数只能减为1，这种情况下不会去删除智能指针管理的内存，导致类TA、TB的实例对象不能被析构，最终造成内存泄露</u>**。通过使用weak_ptr可以解决这个问题，只要将类TA或者TB的任意一个成员改为weak_ptr，修改之后的代码如下：

```c++
#include <iostream>
#include <memory>
using namespace std;

struct TA;
struct TB;

struct TA
{
    weak_ptr<TB> bptr;//修改任意一个为weakptr
    ~TA()
    {
        cout << "class TA is disstruct ..." << endl;
    }
};

struct TB
{
    shared_ptr<TA> aptr;
    ~TB()
    {
        cout << "class TB is disstruct ..." << endl;
    }
};

void testPtr()
{
    shared_ptr<TA> ap(new TA);
    shared_ptr<TB> bp(new TB);
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

    ap->bptr = bp;
    bp->aptr = ap;
    cout << "TA object use_count: " << ap.use_count() << endl;
    cout << "TB object use_count: " << bp.use_count() << endl;

}

int main()
{
    testPtr();
    return 0;
}

程序输出的结果:

TA object use_count: 1
TB object use_count: 1
TA object use_count: 2
TB object use_count: 1
class TB is disstruct ...
class TA is disstruct ...
```

通过输出的结果可以看到类TA或者TB的对象被成功析构了。

上面程序中，在对类TA成员赋值时**ap->bptr = bp;**由于**bptr是weak_ptr类型**，这个赋值操作并不会增加引用计数，所以bp的引用计数仍然为1，在离开作用域之后bp的引用计数减为0，类TB的实例对象被析构。

在类TB的实例对象被析构的时候，内部的aptr也被析构，其对TA对象的管理解除，内存的引用计数减为1，当共享智能指针ap离开作用域之后，对TA对象的管理也解除了，内存的引用计数减为0，类TA的实例对象被析构。

### (19) noexcept

#### 1. 异常

##### 1.1 基本语法

异常通常用于处理逻辑上可能发生的错误，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。

关于异常的基本语法如下：

![image-20240410075639853](/assets/image-20240410075639853.png)

```c++
int main()
{ 
    try
    {
        throw -1; 
    } 
    catch (int e)
    { 
        cout << "int exception, value: " << e << endl; 
    } 
    cout << "That's ok!" << endl; 
    return 0; 
}
```

**异常被抛出后，<u>从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构</u>。析构的顺序与构造的顺序相反。<u>这一过程称为栈的解旋</u>。**

##### 1.2 异常接口声明（三种书写方式）

为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，常用的有如下三种书写方式：

1. 显示指定可以抛出的异常类型

```c++
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) throw(MyException, int)
{
    if (b == 0)
    {
        throw MyException("division by zero!!!");
        // throw 100;
    }
    return a / b;
}

int main()
{
    try
    {	
        double v = divisionMethod(100, 0);
        cout << "value: " << v << endl;
    }
    catch (int e)
    {
        cout << "catch except: "  << e << endl;
    }
    catch (MyException e)
    {
        cout << "catch except: " << e.msg << endl;
    }
    return 0;
}
/*
第7行代码在divisionMethod函数后添加了throw异常接口声明，其参数表示可以抛出的异常类型，分别为int 和MyException 类型。
```

2. 抛出任意异常类型

```c++
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b)
{
    if (b == 0)
    {
        throw MyException("division by zero!!!");
        // throw 100;
    }
    return a / b;
}
/*
第7行代码在divisionMethod 没有添加异常接口声明，表示在该函数中可以抛出任意类型的异常。
```

3. 不抛出任何异常

```c++
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) throw()
{
    if (b == 0)
    {
        cout << "division by zero!!!" << endl;
    }
    return a / b;
}
/*
第7行代码在divisionMethod 函数后添加了throw异常接口声明，其参数列表为空，表示该函数不允许抛出异常。
```

#### 2. noexcept

上面的例子中，在 divisionMethod 函数声明之后，我们**定义了一个动态异常声明 throw(MyException, int)，该声明指出了divisionMethod可能抛出的异常的类型**。事实上，该特性很少被使用，因此在**C++11中被弃用了 ，而表示函数不会抛出异常的动态异常声明 throw() 也被新的 noexcept 异常声明所取代**。 
<u>noexcept 形如其名，表示其修饰的函数不会抛出异常</u> 。不过与 `throw()`动态异常声明不同的是，`在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些`。<u>这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象</u>。

因此对于不会抛出异常的函数我们可以这样写:

```c++
double divisionMethod(int a, int b) noexcept
{
    if (b == 0)
    {
        cout << "division by zero!!!" << endl;
        return -1;
    }
    return a / b;
}
```

从语法上讲，noexcept 修饰符有两种形式：

* 简单地在函数声明后加上 noexcept 关键字

* 可以接受一个常量表达式作为参数，如下所示∶

```c++
double divisionMethod(int a, int b) noexcept(常量表达式);
```

常量表达式的结果会被转换成一个bool类型的值：

* **值为 true，表示函数不会抛出异常**
* **值为 false，表示有可能抛出异常这里**
* **不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常。**

### (20) （重要—开发规范）POD类型

#### 1. POD 类型

POD是英文中 **Plain Old Data** 的缩写，翻译过来就是**普通的旧数据** 。POD在C++中是非常重要的一个概念，**<u>通常用于说明一个类型的属性，尤其是用户自定义类型的属性。</u>**

POD属性在C++11中往往又是构建其他C++概念的基础，事实上，在C++11标准中，POD出现的概率相当高。因此学习C++，尤其是在 C++11中，了解 POD的概念是非常必要的。

1. ==*Plain ：表示是个普通的类型*==
2. ==*Old ：体现了其与C的兼容性，支持标准C函数*==

在C++11中将 POD划分为两个基本概念的合集，即∶==平凡的（trivial）== 和==标准布局的（standard layout ） 。== 
#### 2. “平凡”类型

一个平凡的类或者结构体应该符合以下几点要求：

1. **拥有平凡的默认构造函数（trivial constructor）和析构函数（trivial destructor）。**

​	平凡的默认构造函数就是说==构造函数什么都不干==。

* 通常情况下，==不定义类的构造函数==，**编译器**就会为我们==生成一个平凡的默认构造函数。==

```C++
// 使用默认的构造函数
class Test {};

```

* ==一旦定义了构造函数==，即使构造函数不包含参数，函数体里也没有任何的代码，==那么该构造函数也不再是"平凡"的。==

```C++
class Test1 
{
    Test1();	// 程序猿定义的构造函数, 非默认构造
};
```

关于析构函数也和上面列举的构造函数类似，一旦被定义就不平凡了。但是这也并非无药可救，==使用=default关键字可以显式地声明默认的构造函数==，从而使得类型恢复 “平凡化”。

2. **拥有平凡的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）。**

* 平凡的拷贝构造函数基本上等同于使用memcpy 进行类型的构造。
* 同平凡的默认构造函数一样，不声明拷贝构造函数的话，编译器会帮程序员自动地生成。
* 可以显式地使用=default 声明默认拷贝构造函数。 
* 而平凡移动构造函数跟平凡的拷贝构造函数类似，只不过是用于移动语义。

3. **拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）。**

​	这基本上与平凡的拷贝构造函数和平凡的移动构造运算符类似。

4. **不包含虚函数以及虚基类。**

​	类中使用==virtual 关键字修饰的函数== 叫做虚函数

```C++
class Base 
{
public:
    Base() {}
    virtual void print() {}
};
```

虚基类是在==创建子类的时候在继承的基类前加virtual 关键字== 修饰

```
语法: class 派生类名：virtual  继承方式  基类名
```

示例代码：

```C++
    class Base 
    {
    public:
        Base() {}
    };
    // 子类Child，虚基类：Base
    class Child : virtual public Base 
    {
        Child() {}
    };
```

#### 3. “标准布局”类型

标准布局类型主要主要指的是==类或者结构体==的结构或者组合方式。

标准布局类型的类应该符合以下五点定义，==最重要的为前两条==：

1. 所有非静态成员有==相同== 的访问权限（public，private，protected）。

* 类成员拥有不同的访问权限（**非标准布局类型**）

```C++
class Base
{
public:
    Base() {}
    int a;
protected:
    int b;
private:
    int c;
};
```



* 类成员拥有相同的访问权限（**标准布局类型**）

```C++
class Base
{
public:
    Base() {}
    int a;
    int b;
    int c;
};
```

2. 在类或者结构体继承时，满足以下两种情况之一∶ 
   * **派生类中有非静态成员，基类中包含静态成员（或基类没有变量）。**
   * **基类有非静态成员，而派生类没有非静态成员。**

```C++
struct Base { static int a;};
struct Child: public Base{ int b;};          // ok
struct Base1 { int a;};
struct Child1: public Base1{ static int c;}; // ok
struct Child2:public Base, public Base1 { static int d;); // ok
struct Child3:public Base1{ int d;};         // error基类含有非静态成员，子类应该没有非静态成员才对
struct Child4:public Base1, public Child     // error，Child基类继承了Base，多重继承基类含静态和非静态成员，此时Child4应该没有任何成员才对
{
    static int num;
};
```



通过上述例子得到的结论：

* ==非静态成员只要同时出现在派生类和基类间，即不属于标准布局。==

* ==对于多重继承，一旦非静态成员出现在多个基类中，即使派生类中没有非静态成员变量，派生类也不属于标准布局。==

3. **子类中第一个非静态成员的类型与其基类不同。 **
   此处基于G++编译器讲解，如果使用VS的编译器和G++编译器得到的结果是不一样的。

```c++
struct Parent{};
struct Child : public Parent
{
    Parent p;	// 子类的第一个非静态成员
    int foo;
};
```

上面的例子中**Child不是一个标准布局类型**，因为它的第一个非静态成员变量p和父类的类型相同，改成下面这样子类就变成了一个标准布局类型：

```c++
struct Parent{};
struct Child1 : public Parent
{
    int foo;   // 子类的第一个非静态成员
    Parent p;	
};
```

这条规则对于我们来说是比较特别的，这样规定的目的主要是是节约内存，提高数据的读取效率。对于上面的两个子类Child和Child1来说它们的内存结构是不一样的，==在基类没有成员的情况下==：

* C++标准允许==标准布局类型（Child1）==派生类的==第一个成员foo与基类共享地址==，此时基类并没有占据任何的实际空间（可以节省一点数据）

* 对于子类==Child==而言，如果子类的第一个成员仍然是基类类型，C++标准要求类型相同的对象它们的地址必须不同（==基类地址不能和子类中的变量 p 类型相同==），此时需要分配额外的地址空间将二者的地址错开。

![image-20240410091514979](assets\image-20240410091514979.png)

4. **没有虚函数和虚基类。** 
5. **所有非静态数据成员均符合标准布局类型，其基类也符合标准布局，这是一个递归的定义。**



#### 4. 对 POD 类型的判断

如果我们想要判断某个数据类型是不是属于 POD 类型，可以使用C++11给我们提供的相关函数：

##### 4.1 对“平凡”类型判断

C++11提供的类模板叫做 ==is_trivial==，其定义如下：

```
template <class T> struct std::is_trivial;
```

==std::is_trivial== 的成员value 可以用于判断T的类型是否是一个平凡的类型（==value 函数返回值为布尔类型==）。除了类和结构体外，is_trivial还可以对内置的标准类型数据（比如int、float都属于平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。

关于类型的判断，示例程序如下：

```c++
#include <iostream>
#include <type_traits>
using namespace std;

class A {};
class B { B() {} };
class C : B {};
class D { virtual void fn() {} };
class E : virtual public A { };

int main() 
{
    cout << std::boolalpha;
    cout << "is_trivial:" << std::endl;
    cout << "int: " << is_trivial<int>::value << endl;
    cout << "A: " << is_trivial<A>::value << endl;
    cout << "B: " << is_trivial<B>::value << endl;
    cout << "C: " << is_trivial<C>::value << endl;
    cout << "D: " << is_trivial<D>::value << endl;
    cout << "E: " << is_trivial<E>::value << endl;
    return 0;
}
```

```c++
输出的结果：

is_trivial:
int: true
A: true
B: false
C: false
D: false
E: false
/*
int ：内置标准数据类型，属于 trivial 类型
A ：拥有默认的构造和析构函数，属于 trivial 类型
B ：自定义了构造函数，因此不属于 trivial 类型
C ：基类中自定义了构造函数，因此不属于 trivial 类型
D ：类成员函数中有虚函数，因此不属于 trivial 类型
E ：继承关系中有虚基类，因此不属于 trivial 类型
```



##### 4.2 对“标准布局”类型的判断

同样，在C++11中，我们可以使用模板类来帮助判断类型是否是一个标准布局的类型，其定义如下：

```c++
template <typename T> struct std::is_standard_layout;
```

通过 ==is_standard_layout==模板类的成员 value（==is_standard_layout<T>∶∶value==），我们可以在代码中打印出类型的标准布局属性，函数返回值为布尔类型。
示例程序，关于类型的判断，示例程序如下：

```c++
// pod.cpp
#include <iostream>
#include <type_traits>
using namespace std;

struct A { };
struct B : A { int j; };
struct C
{
public:
    int a;
private:
    int c;
};
struct D1 {  static int i; };
struct D2 {  int i; };
struct E1 { static int i; };
struct E2 { int i; };
struct D : public D1, public E1 { int a; };
struct E : public D1, public E2 { int a; };
struct F : public D2, public E2 { static int a; };
struct G : public A
{
    int foo;
    A a;
};
struct H : public A
{
    A a;
    int foo;
};

int main() 
{
    cout << std::boolalpha;
    cout << "is_standard_layout:" << std::endl;
    cout << "A: " << is_standard_layout<A>::value << endl;
    cout << "B: " << is_standard_layout<B>::value << endl;
    cout << "C: " << is_standard_layout<C>::value << endl;
    cout << "D: " << is_standard_layout<D>::value << endl;
    cout << "D1: " << is_standard_layout<D1>::value << endl;
    cout << "E: " << is_standard_layout<E>::value << endl;
    cout << "F: " << is_standard_layout<F>::value << endl;
    cout << "G: " << is_standard_layout<G>::value << endl;
    cout << "H: " << is_standard_layout<H>::value << endl;
    return 0;
}
```

```c++
VS2019输出的结果

is_standard_layout:
A: true
B: true
C: false
D: true
D1: true
E: false
F: false
G: false
H: false
```

G++ 编译输出的结果:

```
编译命令 $ g++ pod.cpp -std=c++11
```

输出的结果

```c++
is_standard_layout:
A: true
B: true
C: false
D: true
D1: true
E: false
F: false
G: true
H: false
```

关于输出的结果

```c++
/*
A ：没有虚基类和虚函数，属于 standard_layout 类型
B ：没有虚基类和虚函数，属于 standard_layout 类型
C ：所有非静态成员访问权限不一致，不属于 standard_layout 类型
D ：基类和子类没有同时出现非静态成员变量，属于 standard_layout 类型
D1 ：没有虚基类和虚函数，属于 standard_layout 类型
E ：基类和子类中同时出现了非静态成员变量，不属于 standard_layout 类型
F ：多重继承中在基类里同时出现了非静态成员变量，不属于 standard_layout 类型
G ：使用的编译器不同，得到的结果也不同。
H ：子类中第一个非静态成员的类型与其基类类型不能相同，不属于 standard_layout 类型
```

5. 总结

事实上，我们使用的很多内置类型默认都是 POD的。POD 最为复杂的地方还是在类或者结构体的判断。不过上面也给大家介绍了判断的方法，相信大家对 POD已经有所理解。那么，使用POD有什么好处呢？

1. 字节赋值，代码中我们可以安全地使用memset 和 memcpy 对 POD类型进行初始化和拷贝等操作。 
2. 提供对C内存布局兼容。C++程序可以与C 函数进行相互操作，因为POD类型的数据在C与C++ 间的操作总是安全的。 
3. 保证了静态初始化的安全有效。静态初始化在很多时候能够提高程序的性能，而POD类型的对象初始化往往更加简单。 

关于 POD 重在理解，我们在查阅资料的时候经常会看到引用POD的地方，所以建议大家花时间消化一下这个概念。

### (21) 默认函数控制 =default 与 =delete

#### 1. 类与默认函数

在C++中声明自定义的类，编译器会默认帮助程序员生成一些他们未自定义的成员函数。这样的函数版本被称为”默认函数”。这样的函数一共有六个，我们一起来看一下：

1. ==无参构造函数：创建类对象==
2. ==拷贝构造函数：拷贝类对象==
3. ==移动构造函数：拷贝类对象==
4. ==拷贝赋值函数：类对象赋值==
5. ==移动赋值函数：类对象赋值==

6. ==析构函数 ：销毁类对象==

**在C++语法规则中，一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。**

有时程序员会忘记上面提到的规则，最常见的是声明了带参数的构造，如果还需要无参构造函数，这时候必须定义出不带参数的版本。不过通过编译器的提示，这样的问题通常会得到更正。但更为严重的问题是，<u>==一旦声明了自定义版本的构造函数，则有可能导致我们定义的类型不再是*POD类型*==</u>，我们便不再能够享受POD类型为我们带来的便利。

对于上面提到的这些，我们无需过度担心，因为C++11非常贴心地为我们提供了解决方案，就是使用=default 。

#### 2. =default 和 =delete

在C++11标准中称= default修饰的函数为==显式默认【缺省】（explicit defaulted）函数==，而称=delete修饰的函数为==删除（deleted）函数或者显示删除函数。==

 C++11引入显式默认和显式删除是为了增强对类默认函数的控制，让程序员能够更加精细地控制默认版本的函数。

##### 2.1 =default

我们可以在类内部修饰满足条件的类函数为显示默认函数，也可以在类定义之外修饰成员函数为默认函数。下面举例说明：

###### 在类内部指定函数为默认函数

一般情况下，我们可以在定义类的时候直接在类内部指定默认函数，如下所示：

```c++
class Base
{
public:
    Base() = default;
    Base(const Base& obj) = default;
    Base(Base&& obj) = default;
    Base& operator= (const Base& obj) = default;
    Base& operator= (Base&& obj) = default;
    ~Base() = default;
};
/*
第4行：指定无参构造为默认函数
第5行：指定拷贝构造函数为默认函数
第6行：指定移动构造函数为默认函数
第7行：指定复制赋值操作符重载函数为默认函数
第8行：指定移动赋值操作符重载函数为默认函数
第9行：指定析构函数为默认函数
```

==使用 =defaut 指定的默认函数和类提供的默认函数是等价的==

###### 在类外部指定函数为默认函数

默认函数除了在类定义的内部指定，也可以在类的外部指定，如下所示：

```c++
// 类定义
class Base
{
public:
    Base();
    Base(const Base& obj);
    Base(Base&& obj);
    Base& operator= (const Base& obj);
    Base& operator= (Base&& obj);
    ~Base();
};
// 在类定义之外指定成员函数为默认函数
Base::Base() = default;
Base::Base(const Base& obj) = default;
Base::Base(Base&& obj) = default;
Base& Base::operator= (const Base& obj) = default;
Base& Base::operator= (Base&& obj) = default;
Base::~Base() = default;
```

定义默认函数的注意事项:

==如果程序猿对C++类提供的默认函数（上面提到的六个函数）进行了实现，那么可以通过 =default 将他们再次指定为默认函数，<u>不能使用 =default 修饰这六个函数以外的函数</u>。==

```c++
class Base
{
public:
    Base() = default;
    Base(const Base& obj) = default;
    Base(Base&& obj) = default;
    Base& operator= (const Base& obj) = default;
    Base& operator= (Base&& obj) = default;
    ~Base() = default;

    // 以下写法全部都是错误的
    Base(int a = 0) = default;
    Base(int a, int b) = default;
    void print() = default;
    bool operator== (const Base& obj) = default;
    bool operator>=(const Base& obj) = default;

};
/*
第12行：自定义带参构造，不允许使用 =default 修饰（即使有默认参数也不行）

第13行：自定义带参构造，不允许使用 =default 修饰

第14行：自定义函数，不允许使用 =default 修饰

第15、16行：不是移动、复制赋值运算符重载，不允许使用 =default 修饰
```

###### 浅拷贝、深拷贝

```c++
class MyClass {  
private:  
    int* ptr;  
  
public:  
    MyClass(int value) {  
        ptr = new int(value);  
    }  
  
    // 默认拷贝构造函数是浅拷贝  
    MyClass(const MyClass& other) {  
        ptr = other.ptr;  // 浅拷贝，两个对象现在共享同一个int  
    }  
  
    // 重载拷贝构造函数实现深拷贝  
    MyClass(const MyClass& other) : MyClass() {  // 调用默认构造函数初始化ptr  
        *ptr = *other.ptr;  // 复制int的值，现在每个对象都有自己的int  
    }  
  
    // 重载赋值运算符实现深拷贝  
    MyClass& operator=(const MyClass& other) {  
        if (this != &other) {  // 避免自赋值  
            delete ptr;  // 释放当前对象的资源  
            ptr = new int(*other.ptr);  // 分配新资源并复制值  
        }  
        return *this;  
    }  
  
    ~MyClass() {  
        delete ptr;  // 释放资源  
    }  
};
```



##### 2.2 =delete

=delete 表示显示删除，`显式删除可以避免用户使用一些不应该使用的类的成员函数`，使用这种方式可以有效的防止某些类型之间自动进行隐式类型转换产生的错误。下面举例说明：

###### 禁止使用默认生成的函数

```c++
class Base
{
public:
    Base() = default;
    Base(const Base& obj) = delete;
    Base& operator= (const Base& obj) = delete;
};

int main()
{
    Base b;
    Base tmp1(b);    // error
    Base tmp = b;    // error
    return 0;
}
/*
第5行：禁用拷贝构造函数
第6行：禁用 = 进行对象复制
第12行：拷贝构造函数已被显示删除，无法拷贝对象
第13行：复制对象的赋值操作符重载函数已被显示删除，无法复制对象
```



###### 禁止使用自定义函数

```c++
class Base
{
public:
    Base(int num) : m_num(num) {}
    Base(char c) = delete;
    void print(char c) = delete;
    void print()
    {
        cout << "num: " << m_num << endl;
    }
    void print(int num)
    {
        cout << "num: " << num << endl;
    }
private:
    int m_num;
};

int main()
{
    Base b(97);       // 'a' 对应的 acscii 值为97
    Base b1('a');     // error
    b.print();
    b.print(97);
    b.print('a');     // error
    return 0;
}
/*
第5行：禁用带 char类型参数的构造函数，防止隐式类型转换（char转int)
第6行：禁止使用带char类型的自定义函数，防止隐式类型转换（char转int)
第22行：对应的构造函数被禁用，因此无法使用该构造函数构造对象
第25行：对应的打印函数被禁用，因此无法给函数传递char类型参数

```

### (22) 扩展的 friend 语法

friend关键字在C++中是一个比较特别的存在。因为在大多数编程语言中是没有提供friend关键字的，比如Java。friend关键字用于声明类的友元，==友元可以无视类中成员的属性（ public、protected 或是 private ）==，友元类或友元函数都可以访问，这就==完全破坏了面向对象编程中封装性的概念==。但有的时候，friend关键字确实会让程序猿少写很多代码，因此 friend 还是在很多程序中被使用到。

#### 1. 语法改进

在 C++11 标准中对 friend关键字进行了一些改进，以保证其更加好用：
==声明一个类为另外一个类的友元时，不再需要使用class关键字，并且还可以使用类的别名（使用 typedef 或者 using 定义）。==

我们可以看看下面的例子：

```c++
#include <iostream>
using namespace std;

// 类声明
class Tom;
// 定义别名
using Honey = Tom;

// 定义两个测试类
class Jack
{
    // 声明友元
    // friend class Tom;    // C++98 标准语法
    friend Tom;             // C++11 标准语法 
    string name = "jack";   // 默认私有
    void print()            // 默认私有
    {
        cout << "my name is " << name << endl;
    }
};

class Lucy
{
protected:
    // 声明友元
    // friend class Tom;    // C++98 标准语法
    friend Honey;           // C++11 标准语法 
    string name = "lucy";
    void print()
    {
        cout << "my name is " << name << endl;
    }
};

class Tom
{
public:
    void print()
    {
        // 通过类成员对象访问其私有成员
        cout << "invoke Jack private member: " << jObj.name << endl;
        cout << "invoke Jack private function: " << endl;
        jObj.print();

       cout << "invoke Lucy private member: " << lObj.name << endl;
        cout << "invoke Lucy private function: " << endl;
        lObj.print();
}

private:
    string name = "tom";
    Jack jObj;
    Lucy lObj;
};

int main()
{
    Tom t;
    t.print();
    return 0;
}
```

在上面的例子中 Tom 类分别作为了Jack类和Lucy类的友元类，然后在Tom类中定义了Jack类和Lucy类的对象jObj和lObj，这样我们就可以在Tom类中通过这两个类对象直接访问它们各自的私有或者受保护的成员变量或者成员函数了。
#### 2. 为类模板声明友元

虽然在C++11标准中对友元的改进不大，却会带来应用的变化——程序员可以为类模板声明友元了，这在C++98中是无法做到的。使用方法如下：

```c++
class Tom;

template<typename T>  
class Person
{
    friend T;
};

int main()
{
    Person<Tom> p;
    Person<int> pp;
    return 0;
}
/*
第11行：Tom类是Person类的友元
第12行：对于int类型的模板参数，友元声明被忽略（第6行）
```

这样一来，我们就可以在模板实例化时才确定一个模板类是否有友元，以及谁是这个模板类的友元。

下面基于一个实际场景来讲解一下如何给模板类指定友元：

假设有一个矩形类，一个圆形类，我们在对其进行了一系列的操作之后，需要验证一下矩形的宽度和高度、圆形的半径是否满足要求，并且要求这个校验操作要在另一个类中完成。

```c++
template<typename T>  
class Rectangle
{
public:
    friend T;
    Rectangle(int w, int h) : width(w), height(h) {}
private:
    int width;
    int height;
};

template<typename T> 
class Circle
{
public:
    friend T;
    Circle(int r) : radius(r) {}
private:
    int radius;
};

// 校验类
class Verify
{
public:
    void verifyRectangle(int w, int h, Rectangle<Verify> &r)
    {
        if (r.width >= w && r.height >= h)
        {
            cout << "矩形的宽度和高度满足条件!" << endl;
        }
        else
        {
            cout << "矩形的宽度和高度不满足条件!" << endl;
        }
    }

    void verifyCircle(int r, Circle<Verify> &c)
    {
        if (r >= c.radius)
        {
            cout << "圆形的半径满足条件!" << endl;
        }
        else
        {
            cout << "圆形的半径不满足条件!" << endl;
        }
    }
};

int main()
{
    Verify v;
    Circle<Verify> circle(30);
    Rectangle<Verify> rect(90, 100);
    v.verifyCircle(60, circle);
    v.verifyRectangle(100, 100, rect);
    return 0;
}
/*
第28行：在Verify类中 访问了 Rectangle类 的私有成员变量
第40行：在Verify类中 访问了 Circle类 的私有成员变量
```

程序输出的结果：

> 圆形的半径满足条件!
> 矩形的宽度和高度不满足条件!

在上面的例子中我们定义了两个类模板Rectangle和Circle并且将其模板类型定义为了它们的友元（如果是模板类型是基础类型友元的定义就被忽略了）。在main()函数中测试的时候将Verify类指定为了两个模板类的实际友元类型。这样我们在Verify类中就可以通过Rectangle类和Circle类的实例对象访问它们内部的私有成员变量了。

补充说明：

1. 在上面的测试程序中Rectangle类和Circle类我们没有提供对应的set方法来设置私有成员的值，为了简化程序直接通过构造函数的初始化列表完成了它们的初始化。
2. 在上面的程序中也没有给Rectangle类和Circle类提供get方法，这样如果想要在类外部访问私有（或受保护）成员就只能使用友元了（此处这样处理完全了为了测试的需要）。

### (23) 强类型枚举

#### 1. 枚举

##### 1.1 枚举的使用

枚举类型是C及C++中一个基本的**内置类型**，不过也是一个有点”奇怪”的类型。从枚举的本意上来讲，就是要定义一个类别，并穷举同一类别下的个体以供代码中使用。由于枚举来源于C，所以出于设计上的简单的目的，枚举值常常是对应到整型数值的一些名字，比如：

```c++
// 匿名枚举
enum {Red, Green, Blue};
// 有名枚举
enum Colors{Red, Green, Blue};
```

==在枚举类型中的枚举值<u>编译器会默认从0开始赋值，而后依次向下递增</u>，也就是说Red=0，Green=1，Blue=2。==

##### 1.2 枚举的缺陷

C/C++的enum有个很”奇怪” 的设定，就是==具名（有名字）的enum类型的名字，以及 enum 的成员的名字都是全局可见的==。这<u>*与 C++中具名的 namespace、class/struct 及 union 必须通过名字::成员名的方式访问相比是格格不入的*</u>，编码过程中一不小心程序员就容易遇到问题。比如∶

```c++
enum China {Shanghai, Dongjing, Beijing, Nanjing};
enum Japan {Dongjing, Daban, Hengbin, Fudao};
```

上面定义的两个枚举在编译的时候，编译器会报错，具体信息如下：

```
error C2365: “Dongjing”: 重定义；以前的定义是“枚举数”
```

错误的原因上面也提到了，在这两个具名的枚举中**Dongjing是全局可见**的，所有编译器就会提示其重定义了。

另外，**由于C中枚举被设计为常量数值的”别名”的本性，所以枚举的成员<u>总是可以被隐式地转换为整型</u>**，但是很多时候我们并不想这样。

#### 2. 强类型枚举

##### 2.1 优势

针对枚举的缺陷，C++11标准引入了一种新的枚举类型，即==枚举类==，又称==强类型枚举（strong-typed enum）==。 声明强类型枚举非常简单，只需要在 ==enum 后加上关键字 class==。比如∶

```c++
// 定义强类型枚举
enum class Colors{Red, Green, Blue};
```

强类型枚举具有以下几点优势∶ 

* ==强作用域==，强类型**枚举成员的名称不会被输出到其父作用域空间**。
  * ==强类型枚举只能是有名枚举==，如果是匿名枚举会导致枚举值无法使用（因为没有作用域名称）。

* ==转换限制==，强类型**枚举成员的值不可以与整型隐式地相互转换**。 

* ==可以指定底层类型==。**强类型枚举默认的底层类型为 int**，但也可以**显式地指定底层类型， 具体方法为在枚举名称后面加上∶type，<u>其中 type 可以是除 wchar_t 以外的任何整型</u>**。比如:

```c++
enum class Colors :char { Red, Green, Blue };
```

> wchar_t 是什么?
>
> * 双字节类型，或宽字符类型，是C/C++的一种扩展的存储方式，一般为16位或32位，所能表示的字符数远超char型。
> * 主要用在国际化程序的实现中，但它不等同于 unicode 编码。unicode 编码的字符一般以wchar_t类型存储。

了解了强类型枚举的优势之后，我们再看一段程序：

```c++
enum class China { Shanghai, Dongjing, Beijing, Nanjing, };
enum class Japan:char { Dongjing, Daban, Hengbin, Fudao };
int main()
{
    int m = Shanghai;           // error
    int n = China::Shanghai;    // error
    if ((int)China::Beijing >= 2)
    {
    	cout << "ok!" << endl;
    }
    cout << "size1: " << sizeof(China::Dongjing) << endl;
    cout << "size2: " << sizeof(Japan::Dongjing) << endl;
    return 0;
}
```



```c++
/*
第5行：该行的代码有两处错误
    1. 强类型枚举属于强作用于类型，不能直接使用，枚举值前必须加枚举类型
    2. 强类型枚举不会进行隐式类型转换，因此枚举值不能直接给int行变量赋值（虽然强类型枚举的枚举值默认就是整形，但其不能作为整形使用）。
第6行：语法错误，将强类型枚举值作为整形使用，此处不会进行隐式类型转换
第7行：语法正确，强类型枚举值在和整数比较之前做了强制类型转换。
第11行：打印的结果为4，强类型枚举底层类型值默认为int，因此占用的内存是4个字节
第12行：打印的结果为1，显示指定了强类型枚举值的类型为char，因此占用的内存大小为1个字节，这样我们就可以节省更多的内存空间了。
```

##### 2.2 对原有枚举的扩展

相比于原来的枚举，强类型枚举更像是一个属于C++的枚举。但为了配合新的枚举类型，C++11还对原有枚举类型进行了扩展：

1. 原有枚举类型的底层类型在默认情况下，仍然由编译器来具体指定实现。但也可以跟强类型枚举类一样，显式地由程序员来指定。其指定的方式跟强类型枚举一样，都是枚举名称后面加上∶type，其中type 可以是除 wchar_t 以外的任何整型。比如∶

```c++
enum Colors : char { Red, Green, Blue };
```



2. 关于作用域，在C++11中，枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效。比如：

```c++
enum Colors : char { Red, Green, Blue };
int main()
{
    Colors c1 = Green;          // C++11以前的用法
    Colors c2 = Colors::Green;  // C++11的扩展语法
    return 0;
}

上面程序中第4、5行的写法都是合法的。
```

C++11中对原有枚举类型的这两个扩展都保留了向后兼容性，也方便了程序员在代码中同时操作两种枚举类型。此外，我们在声明强类型枚举的时候，也可以使用关键字enum struct。**实际上 enum struct 和enum class在语法上没有任何区别**（==enum class 的成员没有公有私有之分，也不会使用模板来支持泛化的声明== ）。

### (24) Union

在C++中，`union`是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。但是，`union`**不会为成员变量提供初始化**。因此，==当你为`union`的一个成员赋值时，其它成员变量的值会变得不确定，因为它们<u>共享相同的内存区域</u>==。

#### 1. 什么是非受限联合体

联合体又叫共用体，我将其称之为union，它的使用方式和结构体类似，程序猿可以在联合体内部定义多种不同类型的数据成员，但是这些数据会共享同一块内存空间（也就是如果对多个数据成员同时赋值会发生数据的覆盖）。在某些特定的场景下，通过这种特殊的数据结构我们就可以实现内存的复用，从而达到节省内存空间的目的。

在C++11之前我们使用的联合体是有局限性的，主要有以下三点：

1. 不允许联合体拥有==非POD类型==的成员
2. 不允许联合体拥有静态成员
3. 不允许联合体拥有引用类型的成员

在新的C++11标准中，取消了关于联合体对于数据成员类型的限定，==规定任何非引用类型都可以成为联合体的数据成员，这样的联合体称之为非受限联合体（Unrestricted Union）==

#### 2. 非受限联合体的使用

##### 2.1 静态类型的成员及Union详解

对于非受限联合体来说，静态成员有两种分别是==静态成员变量==和==静态成员函数==，我们来看一下下面的代码：

```c++
#include<iostream>
using namespace std;
union Test
{
	int age;
	long id;
	double score;
	// int& tmp = age; // error
	char a;
	//string str; //error
	char arr[10];
	static char c;
	static int print()
	{
		cout << "c value: " << c << endl;
		return 0;
	}
};
char Test::c;
// char Test::c = 'a';

int main()
{
	Test t;
	Test t1;
	t.c = 'b';
	t1.c = 'c';
	t1.age = 666;
	t1.id = 777;
	t1.score = 88.8;
	t1.a = 'a';
	for (int i = 0; i < 10; i++) {
		t1.arr[i] = i;
	}

	//t1.str = "i love you";
	cout << "t.c: " << t.c << endl;
	cout << "t1.c: " << t1.c << endl;
	cout << "t1.age: " << t1.age << endl;
	cout << "t1.id: " << t1.id << endl;
	cout << "t1.score: " << t1.score << endl;
	cout << "t1.a: " << t1.a << endl;
	cout << "t1.arr: " << t1.arr << endl;

	t.print();
	Test::print();
	return 0;
}
```

执行程序输出的结果如下:

> t.c: c
> t1.c: c
> t1.age: 50462976
> t1.id: 50462976
> t1.score: 7.94993e-275
> t1.a:
> t1.arr:
> c value: c
> c value: c
>
> 
>
> 分析
>
> 1. > ```c++
>    > t1.age = 666;
>    > t1.id = 777;
>    > ```
>    >
>    > 输出age和id都为777因为共享同一内存，t1.age和t1.id在内存中是重叠的。当你给t1.age赋值时，你也间接地更改了t1.id的值。
>
>    
>
>    
>
> 2. > ```c++
>    > 	t1.age = 666;
>    > 	t1.id = 777;
>    > 	t1.score = 88.8;
>    > ```
>    >
>    > 输出
>    > t1.age: 858993459
>    > t1.id: 858993459
>    > t1.score: 88.8
>    >
>    > 当你尝试访问 t1.age 和 t1.id 时，你实际上是在读取被 double 值覆盖后的内存内容。因为这些内存区域现在包含的是 double 类型的数据，所以当你将它们当作 int 或 long 来读取时，==你会得到一些无意义且很大的数值（这通常被称为“内存垃圾”或“未定义行为”）==。
>
>    
>
>    
>
> 3. >```c++
>    >t1.age = 666;
>    >t1.id = 777;
>    >t1.score = 88.8;
>    >t1.a = 'a';
>    >```
>    >
>    >输出
>    >t1.age: 858993459
>    >t1.id: 858993459
>    >t1.score: 88.8
>    >
>    >t1.a: a
>    >
>    >包含了一个**非静态成员 `char a`**。`union` 的特性确实是所有的非静态成员共享同一块内存区域。这意味着，当你给 `union` 的任何一个成员赋值时，都会覆盖同一块内存区域的内容，进而影响到其他成员的值。
>    >
>    >但是，在输出时，你看到的 `t1.a` 的值是 `'a'` 是因为你直接给 `t1.a` 赋了这个值。==由于 `char` 类型通常占用一个字节的内存，当你给 `t1.a` 赋值时，你只会覆盖 `union` 所占用的内存区域中的第一个字节==。**`union` 的其他成员（如 `age`、`id` 和 `score`）可能会占用更多的内存空间，它们的值取决于之前给这些成员赋的值以及它们的内存布局**。
>
> 4. > ```c++
>    > t1.age = 666;
>    > t1.id = 777;
>    > t1.score = 88.8;
>    > t1.a = 'a';
>    > for (int i = 0; i < 10; i++) {
>    > 	t1.arr[i] = i;
>    > }
>    > ```
>    >
>    > 输出
>    >
>    > t1.age: 50462976
>    > t1.id: 50462976
>    > t1.score: 7.94993e-275
>    > t1.a:
>    > t1.arr:
>    >
>    > 这是由于char arr[]数组不在是占一个字节，输出会被覆盖
>
> 5. ==`union` 不能直接定义 `std::string` 类型的主要原因是 `std::string` 是一个类类型==，它包含了一些用于管理字符串数据的成员变量（如指向字符数组的指针、表示字符串长度的变量等），以及成员函数。==`union` 只能包含原始数据类型（如 `int`、`char`、`double` 等）或其他 `union`、结构体（`struct`）或类的非静态数据成员。==
>
> 6. ==静态成员变量（如你示例中的`static char c`）是一个例外。静态成员变量不属于`union`的实例，而是属于类本身==。它们==存储在类的静态存储区中，与普通的非静态成员变量是分开的==。因此，静态成员变量不会与其他`union`成员共享内存。

##### 2.2 非POD类型成员

在 C++11标准中会默认删除一些非受限联合体的默认函数。比如，非受限联合体有一个==非 POD 的成员==，而该非 POD成员类型拥有 非平凡的构造函数，==那么非受限联合体的默认构造函数将被编译器删除==。其他的特殊成员函数，==例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将遵从此规则==。下面来举例说明：

```c++
union Student
{
    int id;
    string name;
};

int main()
{
    Student s;
    return 0;
}
```

编译程序会看到如下的错误提示:

```c++
warning C4624: “Student”: 已将析构函数隐式定义为“已删除”
error C2280: “Student::Student(void)”: 尝试引用已删除的函数
```

上面代码中的非受限联合体Student中拥有一个非PDO类型的成员==string name，string 类中有非平凡构造函数==，因此Student的构造函数被删除（通过警告信息可以得知它的析构函数也被删除了）导致对象无法被成功创建出来。**解决这个问题的办法就是由程序猿自己为非受限联合体定义构造函数**，在定义构造函数的时候我们需要用到==定位放置 new==操作。

###### placement new

一般情况下，使用new申请空间时，是从系统的堆（heap）中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做==placement new即定位放置 new。==

定位放置new操作的语法形式不同于普通的new操作：

* 使用new申请内存空间：==Base* ptr = new Base==;

* 使用定位放置new申请内存空间：

```c++
ClassName* ptr = new (定位的内存地址)ClassName;
```

我们来看下面的示例程序:

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    Base() {}
    ~Base() {}
    void print()
    {
        cout << "number value: " << number << endl;
    }
private:
    int number;
};

int main()
{
    int n = 100;
    Base* b = new (&n)Base;
    b->print();
    return 0;
}
```

程序运行输出的结果为:

```
number value: 100
```

在程序的第20行，使用定位放置的方式为指针b申请了一块内存，也就是说此时==指针 b指向的内存地址和变量 n对应的内存地址是同一块（栈内存）==，而在**Base类中成员变量 number的起始地址和Base对象的起始地址是相同的**，所以打印出 number 的值为100也就是整形变量 n 的值。

最后，给大家总结一下关于placement new的一些细节：

1. ==使用<u>定位放置new</u>操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象，这取决于<u>定位时指定的内存地址是在堆还是在栈上</u>。==
2. ==从表面上看，<u>定位放置new操作是申请空间</u>，其<u>本质是利用已经申请好的空间</u>，真正的申请空间的工作是在此之前完成的。==
3. ==使用<u>定位放置new 创建对象时会自动调用对应类的构造函数</u>，但是由于对象的空间不会自动释放，如果需要<u>释放堆内存必须显示调用类的析构函数</u>。==
4. ==使用定位放置new操作，我们*可以反复动态申请到同一块堆内存，这样可以避免内存的重复创建销毁，从而提高程序的执行效率*（比如网络通信中数据的接收和发送）。==

###### 自定义非受限联合体构造函数

掌握了placement new的使用，我们通过一段程序来演示一下如果在非受限联合体中自定义构造函数：

```c++
class Base
{
public:
    void setText(string str)
    {
        notes = str;
    }
    void print()
    {
        cout << "Base notes: " << notes << endl;
    }
private:
    string notes;
};

union Student
{
    Student()
    {
        new (&name)string;
    }
    ~Student() {}

    int id;
    Base tmp;
    string name;
};

int main()
{
    Student s;//31
    s.name = "蒙奇·D·路飞";
    s.tmp.setText("我是要成为海贼王的男人!");
    s.tmp.print();
    cout << "Student name: " << s.name << endl;
    return 0;
}
```

程序打印的结果如下：

```
Base notes: 我是要成为海贼王的男人!
Student name: 我是要成为海贼王的男人!
```

我们在上面的程序里边给非受限制联合体显示的**指定了构造函数和析构函数**，在程序的第31行需要创建一个非受限联合体对象，这时便调用了联合体内部的构造函数，在构造函数的第20行通过定位放置 new的方式将构造出的对象地址定位到了联合体的成员string name的地址上了，这样联合体内部其他非静态成员也就可以访问这块地址了（通过输出的结果可以看到对联合体内的tmp对象赋值，会覆盖name对象中的数据）。
匿名的非受限联合体

一般情况下我们使用的**非受限联合体都是具名的（有名字）**，但是我们**也可以定义匿名的非受限联合体**，一个比较实用的场景就是配合着类的定义使用。我们来设定一个场景：

```
木叶村要进行第99次人口普查，人员的登记方式如下：
    - 学生只需要登记所在学校的编号
    - 本村学生以外的人员需要登记其身份证号码
    - 本村外来人员需要登记户口所在地+联系方式
```

```c++
// 外来人口信息
struct Foreigner
{
    Foreigner(string s, string ph) : addr(s), phone(ph) {}
    string addr;
    string phone;
};

// 登记人口信息
class Person
{
public:
    enum class Category : char {Student, Local, Foreign};
    Person(int num) : number(num), type(Category::Student) {}
    Person(string id) : idNum(id), type(Category::Local) {}
    Person(string addr, string phone) : foreign(addr, phone), type(Category::Foreign) {}
    ~Person() {}

    void print()
    {
        cout << "Person category: " << (int)type << endl;
        switch (type)
        {
        case Category::Student:
            cout << "Student school number: " << number << endl;
            break;
        case Category::Local:
            cout << "Local people ID number: " << idNum << endl;
            break;
        case Category::Foreign:
            cout << "Foreigner address: " << foreign.addr
                << ", phone: " << foreign.phone << endl;
            break;
        default:
            break;
        }
    }

private:
    Category type;
    union
    {
        int number;
        string idNum;
        Foreigner foreign;
    };
};

int main()
{
    Person p1(9527);
    Person p2("1101122022X");
    Person p3("砂隐村村北", "1301810001");
    p1.print();
    p2.print();
    p3.print();
    return 0;
}
/*
程序输出的结果：

Person category: 0
Student school number: 9527
Person category: 1
Local people ID number: 1101122022X
Person category: 2
Foreigner address: 砂隐村村北, phone: 1301810001
```

根据需求我们将木叶村的人口分为了三类并通过枚举记录了下来，在**Person类中添加了一个匿名的非受限联合体用来存储人口信息**，仔细分析之后就会发现这种处理方式的优势非常明显：==尽可能地节省了内存空间==。

* Person类可以直接访问匿名非受限联合体内部的数据成员。

* 不使用匿名非受限联合体申请的内存空间等于 ==number、 idNum 、 foreign 三者内存之和。==

* 使用匿名非受限联合体之后==number、 idNum 、 foreign 三者共用同一块内存。==

## 5. 多线程

### (1) 线程

1. 线程概述

线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。

先从概念上了解一下线程和进程之间的区别：

```
进程有自己独立的地址空间, 多个线程共用同一个地址空间
    线程更加节省系统资源, 效率不仅可以保持的, 而且能够更高
    在一个地址空间中多个线程独享: 每个线程都有属于自己的栈区, 寄存器(内核中管理的)
    在一个地址空间中多个线程共享: 代码段, 堆区, 全局数据区, 打开的文件(文件描述符表)都是线程共享的

线程是程序的最小执行单位, 进程是操作系统中最小的资源分配单位
    每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片
    一个地址空间中可以划分出多个线程, 在有效的资源基础上, 能够抢更多的CPU时间片

CPU的调度和切换: 线程的上下文切换比进程要快的多

上下文切换：进程/线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存, 下次切换回这个任务的时候, 加载这个状态继续运行，任务从保存到再次加载这个过程就是一次上下文切换。

线程更加廉价, 启动速度更快, 退出也快, 对系统资源的冲击小。
```

在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好，如何控制线程的个数呢？

```
文件IO操作：文件IO对CPU是使用率不高, 因此可以分时复用CPU时间片, 线程的个数 = 2 * CPU核心数 (效率最高)

处理复杂的算法(主要是CPU进行运算, 压力大)，线程的个数 = CPU的核心数 (效率最高)
```

2. 创建线程
2.1 线程函数

每一个线程都有一个唯一的线程ID，ID类型为pthread_t，这个ID是一个无符号长整形数，如果想要得到当前线程的线程ID，可以调用如下函数：

pthread_t pthread_self(void);	// 返回当前线程的线程ID

在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。

#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a

```
参数:

    thread: 传出参数，是无符号长整形数，线程创建成功, 会将线程ID写入到这个指针指向的内存中

    attr: 线程的属性, 一般情况下使用默认属性即可, 写NULL

    start_routine: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。

    arg: 作为实参传递到 start_routine 指针指向的函数内部

返回值：线程创建成功返回0，创建失败返回对应的错误号
```

2.2 创建线程

下面是创建线程的示例代码，在创建过程中一定要保证编写的线程函数与规定的函数指针类型一致：void *(*start_routine) (void *):

// pthread_create.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

```
printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 休息, 休息一会儿...
// sleep(1);

return 0;
```
}

编译测试程序，会看到如下错误信息：

$ gcc pthread_create.c 
/tmp/cctkubA6.o: In function `main':
pthread_create.c:(.text+0x7f): undefined reference to `pthread_create'
collect2: error: ld returned 1 exit status

错误原因是因为编译器链接不到线程库文件（动态库），需要在编译的时候通过参数指定出来，动态库名为 libpthread.so需要使用的参数为 -l，根据规则掐头去尾最终形态应该写成：-lpthread（参数和参数值中间可以有空格）。正确的编译命令为：

# pthread_create 函数的定义在某一个库中, 编译的时候需要加库名 pthread
$ gcc pthread_create.c -lpthread
$ ./a.out 
子线程创建成功, 线程ID: 139712560109312
我是主线程, 线程ID: 139712568477440
i = 0
i = 1
i = 2

在打印的日志输出中为什么子线程处理函数没有执行完毕呢（只看到了子线程的部分日志输出）？
主线程一直在运行, 执行期间创建出了子线程，说明主线程有CPU时间片, 在这个时间片内将代码执行完毕了, 主线程就退出了。子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。

得到的结论：在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关。

目前的解决方案: 让子线程执行完毕, 主线程再退出, 可以在主线程中添加挂起函数 sleep();
3. 线程退出

在编写多线程程序的时候，如果想要让线程退出，但是不会导致虚拟地址空间的释放（针对于主线程），我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。

#include <pthread.h>
void pthread_exit(void *retval);

```
参数: 线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为NULL

下面是线程退出的示例代码，可以在任意线程的需要的位置调用该函数：
```

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    sleep(1);
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        if(i==6)
        {
            pthread_exit(NULL);	// 直接退出子线程
        } 
        printf("child == i: = %d\n", i);
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

```
printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 主线程调用退出函数退出, 地址空间不会被释放
pthread_exit(NULL);

return 0;
```
}

4. 线程回收
4.1 线程函数

线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做pthread_join()，这个函数是一个阻塞函数，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。

另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：

#include <pthread.h>
// 这是一个阻塞函数, 子线程在运行这个函数就阻塞
// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()
int pthread_join(pthread_t thread, void **retval);

```
参数:

    thread: 要被回收的子线程的线程ID

    retval: 二级指针, 指向一级指针的地址, 是一个传出参数, 这个地址中存储了pthread_exit() 传递出的数据，如果不需要这个参数，可以指定为NULL

返回值：线程回收成功返回0，回收失败返回错误号。
```

4.2 回收子线程数据

在子线程退出的时候可以使用pthread_exit()的参数将数据传出，在回收这个子线程的时候可以通过phread_join()的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来列举几种：
4.2.1 使用子线程栈

通过函数pthread_exit(void *retval);可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是void*类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：

// pthread_join.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 定义结构
struct Persion
{
    int id;
    char name[36];
    int age;
};

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            struct Persion p;
            p.age  =12;
            strcpy(p.name, "tom");
            p.id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(&p);
        }
    }
    return NULL;	// 代码执行不到这个位置就退出了
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

```
printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 阻塞等待子线程退出
void* ptr = NULL;
// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
// 这个内存地址就是pthread_exit() 参数指向的内存
pthread_join(tid, &ptr);
// 打印信息
struct Persion* pp = (struct Persion*)ptr;
printf("子线程返回数据: name: %s, age: %d, id: %d\n", pp->name, pp->age, pp->id);
printf("子线程资源被成功回收...\n");

return 0;
```
}

编译并执行测试程序:

# 编译代码
$ gcc pthread_join.c -lpthread
# 执行程序
$ ./a.out 
子线程创建成功, 线程ID: 140652794640128
我是主线程, 线程ID: 140652803008256
i = 0
i = 1
i = 2
我是子线程, 线程ID: 140652794640128
child == i: = 0
child == i: = 1
child == i: = 2
child == i: = 3
child == i: = 4
child == i: = 5
child == i: = 6
子线程返回数据: name: , age: 0, id: 0
子线程资源被成功回收...

通过打印的日志可以发现，在主线程中没有没有得到子线程返回的数据信息，具体原因是这样的：

如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。
4.2.2 使用全局变量

位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是可以共享全局数据区和堆区数据，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。在下面的例子中将数据存储到了全局变量中：

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 定义结构
struct Persion
{
    int id;
    char name[36];
    int age;
};

struct Persion p;	// 定义全局变量

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            // 使用全局变量
            p.age  =12;
            strcpy(p.name, "tom");
            p.id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(&p);
        }
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

```
printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 阻塞等待子线程退出
void* ptr = NULL;
// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
// 这个内存地址就是pthread_exit() 参数指向的内存
pthread_join(tid, &ptr);
// 打印信息
struct Persion* pp = (struct Persion*)ptr;
printf("name: %s, age: %d, id: %d\n", pp->name, pp->age, pp->id);
printf("子线程资源被成功回收...\n");

return 0;
```
}

4.2.3 使用主线程栈

虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区内存中：

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 定义结构
struct Persion
{
    int id;
    char name[36];
    int age;
};


// 子线程的处理代码
void* working(void* arg)
{
    struct Persion* p = (struct Persion*)arg;
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            // 使用主线程的栈内存
            p->age  =12;
            strcpy(p->name, "tom");
            p->id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(p);
        }
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;

```
struct Persion p;
// 主线程的栈内存传递给子线程
pthread_create(&tid, NULL, working, &p);

printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 阻塞等待子线程退出
void* ptr = NULL;
// ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
// 这个内存地址就是pthread_exit() 参数指向的内存
pthread_join(tid, &ptr);
// 打印信息
printf("name: %s, age: %d, id: %d\n", p.name, p.age, p.id);
printf("子线程资源被成功回收...\n");

return 0;
```
}

在上面的程序中，调用pthread_create()创建子线程，并将主线程中栈空间变量p的地址传递到了子线程中，在子线程中将要传递出的数据写入到了这块内存中。也就是说在程序的main()函数中，通过指针变量ptr或者通过结构体变量p都可以读出子线程传出的数据。
5. 线程分离

在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用pthread_join()只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。

在线程库函数中为我们提供了线程分离函数pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用pthread_join()就回收不到子线程资源了。

#include <pthread.h>
// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了
int pthread_detach(pthread_t thread);

下面的代码中，在主线程中创建子线程，并调用线程分离函数，实现了主线程和子线程的分离：

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

```
printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 设置子线程和主线程分离
pthread_detach(tid);

// 让主线程自己退出即可
pthread_exit(NULL);

return 0;
```
}

6. 其他线程函数
6.1 线程取消

线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：

```
在线程A中调用线程取消函数pthread_cancel，指定杀死线程B，这时候线程B是死不了的
在线程B中进程一次系统调用（从用户区切换到内核区），否则线程B可以一直运行。
```

这其实和七步断肠散、含笑半步癫的功效是一样的，吃了毒药不动或者不笑也没啥事儿

#include <pthread.h>
// 参数是子线程的线程ID
int pthread_cancel(pthread_t thread);

```
参数：要杀死的线程的线程ID
返回值：函数调用成功返回0，调用失败返回非0错误号。
```

在下面的示例代码中，主线程调用线程取消函数，只要在子线程中进行了系统调用，当子线程执行到这个位置就挂掉了。

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    int j=0;
    for(int i=0; i<9; ++i)
    {
        j++;
    }
    // 这个函数会调用系统函数, 因此这是个间接的系统调用
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf(" child i: %d\n", i);
    }

```
return NULL;
```
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

```
printf("子线程创建成功, 线程ID: %ld\n", tid);
// 2. 子线程不会执行下边的代码, 主线程执行
printf("我是主线程, 线程ID: %ld\n", pthread_self());
for(int i=0; i<3; ++i)
{
    printf("i = %d\n", i);
}

// 杀死子线程, 如果子线程中做系统调用, 子线程就结束了
pthread_cancel(tid);

// 让主线程自己退出即可
pthread_exit(NULL);

return 0;
```
}

关于系统调用有两种方式：

```
直接调用Linux系统函数
调用标准C库函数，为了实现某些功能，在Linux平台下标准C库函数会调用相关的系统函数
```

6.2 线程ID比较

在Linux中线程ID本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的ID，但是线程库是可以跨平台使用的，在某些平台上 pthread_t可能不是一个单纯的整形，这中情况下比较两个线程的ID必须要使用比较函数，函数原型如下：

#include <pthread.h>
int pthread_equal(pthread_t t1, pthread_t t2);

```
参数：t1 和 t2 是要比较的线程的线程ID
返回值：如果两个线程ID相等返回非0值，如果不相等返回0
```



### (2) 处理日期和时间的chrono库

C++11中提供了日期和时间相关的库chrono，通过chrono库可以很方便地处理日期和时间，为程序的开发提供了便利。chrono库主要包含三种类型的类：==时间间隔duration、时钟clocks、时间点time point。==

#### 1. 时间间隔duration

##### 1.1 常用类成员

==duration表示一段时间间隔==，用来记录时间长度，可以表示几秒、几分钟、几个小时的时间间隔。duration的原型如下：

```c++
// 定义于头文件 <chrono>
template<
    class Rep,
    class Period = std::ratio<1>

​	class duration;
```



> * Rep：这是一个数值类型，表示时钟数（周期）的类型（默认为整形）。若 Rep 是浮点数，则 duration 能使用小数描述时钟周期的数目。
>
> * Period：表示时钟的周期，它的原型如下：
>
>   ```c++
>   c++template<
>       std::intmax_t Num,
>       std::intmax_t Denom = 1
>   > class ratio;
>   ```
>
>   

==ratio类表示每个时钟周期的秒数==，其中==第一个模板参数Num代表分子，Denom代表分母，该分母值默认为1==，因此，==ratio代表的是一个分子除以分母的数值==，比如：ratio<2>代表一个时钟周期是2秒，ratio<60>代表一分钟，ratio<60*60>代表一个小时，ratio<60*60*24>代表一天。而ratio<1,1000>代表的是1/1000秒，也就是1毫秒，ratio<1,1000000>代表一微秒，ratio<1,1000000000>代表一纳秒。

> 为了方便使用，在标准库中定义了一些常用的时间间隔，比如：时、分、秒、毫秒、微秒、纳秒，它们都位于chrono命名空间下，定义如下：
>
> | 类型                            | 定义                                                         |
> | ------------------------------- | ------------------------------------------------------------ |
> | 纳秒：std::chrono::nanoseconds  | duration<Rep*/*至少 64 位的有符号整数类型*/*, std::nano>     |
> | 微秒：std::chrono::microseconds | duration<Rep*/*至少 55 位的有符号整数类型*/*, std::micro>    |
> | 毫秒：std::chrono::milliseconds | duration<Rep*/*至少 45 位的有符号整数类型*/*, std::milli>    |
> | 秒： std::chrono::seconds       | duration<Rep*/*至少 35 位的有符号整数类型*/*>                |
> | 分钟：std::chrono::minutes      | duration<Rep*/*至少 29 位的有符号整数类型*/*, std::ratio<60>> |
> | 小时：std::chrono::hours        | duration<Rep*/*至少 23 位的有符号整数类型*/*, std::ratio<3600>> |
>
> 注意：到 hours 为止的每个预定义时长类型至少涵盖 ±292 年的范围。

duration类的构造函数原型如下：

```c++
// 1. 拷贝构造函数
duration( const duration& ) = default;
// 2. 通过指定时钟周期的类型来构造对象
template< class Rep2 >
constexpr explicit duration( const Rep2& r );
// 3. 通过指定时钟周期类型，和时钟周期长度来构造对象
template< class Rep2, class Period2 >
constexpr duration( const duration<Rep2,Period2>& d );
```

为了更加方便的进行duration对象之间的操作，类内部进行了操作符重载：

| 操作符重载                                                   | 描述                                    |
| ------------------------------------------------------------ | --------------------------------------- |
| operator=                                                    | 赋值内容 (公开成员函数)                 |
| operator+<br/>operator-                                      | 实现一元 + 和一元 - (公开成员函数)      |
| operator++<br/>operator++(int)<br/>operator–<br/>operator–(int) | 递增或递减周期计数 (公开成员函数)       |
| operator+=<br/>operator-=<br/>operator*=<br/>operator/=<br/>operator%= | 实现二个时长间的复合赋值 (公开成员函数) |

duration类还提供了获取时间间隔的时钟周期数的方法count()，函数原型如下：

```c++
constexpr rep count() const;
```



##### 1.2 类的使用

通过构造函数构造事件间隔对象示例代码如下：

```c++
#include <chrono>
#include <iostream>
using namespace std;
int main()
{
    chrono::hours h(1);                          // 一小时
    chrono::milliseconds ms{ 3 };                // 3 毫秒
    chrono::duration<int, ratio<1000>> ks(3);    // 3000 秒

    // chrono::duration<int, ratio<1000>> d3(3.5);  // error
    chrono::duration<double> dd(6.6);               // 6.6 秒

    // 使用小数表示时钟周期的次数
    chrono::duration<double, std::ratio<1, 30>> hz(3.5);

}
```

> h(1)时钟周期为1小时，共有1个时钟周期，所以h表示的时间间隔为1小时
> ms(3)时钟周期为1毫秒，共有3个时钟周期，所以ms表示的时间间隔为3毫秒
> ks(3)时钟周期为1000秒，一共有三个时钟周期，所以ks表示的时间间隔为3000秒
> d3(3.5)时钟周期为1000秒，时钟周期数量只能用整形来表示，但是此处指定的是浮点数，因此语法错误
> dd(6.6)时钟周期为默认的1秒，共有6.6个时钟周期，所以dd表示的时间间隔为6.6秒
> hz(3.5)时钟周期为1/30秒，共有3.5个时钟周期，所以hz表示的时间间隔为1/30*3.5秒

chrono库中根据duration类封装了不同长度的时钟周期（也可以自定义），基于这个时钟周期再进行周期次数的设置就可以得到总的时间间隔了（==时钟周期 * 周期次数 = 总的时间间隔==）。

示例代码如下：

```c++
#include <chrono>
#include <iostream>
int main()
{
    std::chrono::milliseconds ms{3};         // 3 毫秒
    std::chrono::microseconds us = 2*ms;     // 6000 微秒
    // 时间间隔周期为 1/30 秒
    std::chrono::duration<double, std::ratio<1, 30>> hz(3.5);

    std::cout <<  "3 ms duration has " << ms.count() << " ticks\n"
              <<  "6000 us duration has " << us.count() << " ticks\n"
              <<  "3.5 hz duration has " << hz.count() << " ticks\n";       

}
```

输出的结果为：

> 3 ms duration has 3 ticks
> 6000 us duration has 6000 ticks
> 3.5 hz duration has 3.5 ticks
>
> 说明
>
> ms时间单位为毫秒，初始化操作ms{3}表示时间间隔为3毫秒，一共有3个时间周期，每个周期为1毫秒
> us时间单位为微秒，初始化操作2*ms表示时间间隔为6000微秒，一共有6000个时间周期，每个周期为1微秒
> hz时间单位为秒，初始化操作hz(3.5)表示时间间隔为1/30*3.5秒，一共有3.5个时间周期，每个周期为1/30秒

由于在duration类内部做了操作符重载，因此时间间隔之间可以直接进行算术运算，比如我们要计算两个时间间隔的差值，就可以在代码中做如下处理：

```c++
#include <iostream>
#include <chrono>
using namespace std;

int main()
{
    chrono::minutes t1(10);
    chrono::seconds t2(60);
    chrono::seconds t3 = t1 - t2;
    cout << t3.count() << " second" << endl;
}

程序输出的结果：

540 second
```

在上面的测试程序中，t1代表10分钟，t2代表60秒，t3是t1减去t2，也就是60*10-60=540，这个540表示的时钟周期，每个时钟周期是1秒，因此两个时间间隔之间的差值为540秒。

==注意事项：duration的加减运算有一定的规则，当两个duration时钟周期不相同的时候，会先统一成一种时钟，然后再进行算术运算，统一的规则如下：假设有ratio<x1,y1> 和 ratio<x2,y2>两个时钟周期，首先需要求出x1，x2的最大公约数X，然后求出y1，y2的最小公倍数Y，统一之后的时钟周期ratio为ratio<X,Y>==。

```c++
#include <iostream>
#include <chrono>
using namespace std;

int main()
{
    chrono::duration<double, ratio<9, 7>> d1(3);
    chrono::duration<double, ratio<6, 5>> d2(1);
    // d1 和 d2 统一之后的时钟周期
    chrono::duration<double, ratio<3, 35>> d3 = d1 - d2;
}
```

对于分子6,、9最大公约数为3，对于分母7、5最小公倍数为35，因此推导出的时钟周期为ratio<3,35>
#### 2. 时间点 time point

chrono库中提供了一个表示时间点的类time_point，该类的定义如下：

// 定义于头文件 <chrono>

```c++
template<
    class Clock,
    class Duration = typename Clock::duration

>class time_point;
```



它被实现成如同存储一个 Duration 类型的自 Clock 的纪元起始开始的时间间隔的值，通过这个类最终可以得到时间中的某一个时间点。

* ==Clock==：此时间点在此时钟上计量
* ==Duration==：用于计量从纪元起时间的 std::chrono::duration 类型

time_point类的构造函数原型如下：

```c++
// 1. 构造一个以新纪元(epoch，即：1970.1.1)作为值的对象，需要和时钟类一起使用，不能单独使用该无参构造函数
time_point();
// 2. 构造一个对象，表示一个时间点，其中d的持续时间从epoch开始，需要和时钟类一起使用，不能单独使用该构造函数
explicit time_point( const duration& d );
// 3. 拷贝构造函数，构造与t相同时间点的对象，使用的时候需要指定模板参数
template< class Duration2 >
time_point( const time_point<Clock,Duration2>& t );
```

在这个类中除了构造函数还提供了另外一个time_since_epoch()函数，用来获得1970年1月1日到time_point对象中记录的时间经过的时间间隔（duration），函数原型如下：

```c++
duration time_since_epoch() const;
```

> 除此之外，时间点time_point对象和时间段对象duration之间还支持直接进行算术运算（即加减运算），时间点对象之间可以进行逻辑运算，具体细节可以参考下面的表格：
>
> 其中 tp 和 tp2 是time_point 类型的对象， dtn 是duration类型的对象。

| 描述                              | 操作      | 返回值             |
| --------------------------------- | --------- | ------------------ |
| 复合赋值(成员函数) operator+=     | tp += dtn | *this              |
| 复合赋值(成员函数)  operator-=    | tp -= dtn | *this              |
| 算术运算符(非成员函数) operator+  | tp + dtn  | a time_point value |
| 算术运算符(非成员函数)  operator+ | dtn + tp  | a time_point value |
| 算术运算符(非成员函数) operator-  | tp - dtn  | a time_point value |
| 算术运算符(非成员函数) operator-  | tp - tp2  | a duration value   |
| 关系操作符(非成员函数) operator== | tp == tp2 | a bool value       |
| 关系操作符(非成员函数) operator!= | tp != tp2 | a bool value       |
| 关系操作符(非成员函数) operator<  | tp < tp2  | a bool value       |
| 关系操作符(非成员函数) operator>  | tp > tp2  | a bool value       |
| 关系操作符(非成员函数) operator>= | tp >= tp2 | a bool value       |
| 关系操作符(非成员函数) operator<= | tp <= tp2 | a bool value       |

由于该时间点类经常和下面要介绍的时钟类一起使用，所以在此先不举例，在时钟类的示例代码中会涉及到时间点类的使用，到此为止只需要搞明白时间点类的提供的这几个函数的作用就可以了。

#### 3. 时钟clocks

chrono库中提供了获取当前的系统时间的时钟类，包含的时钟一共有三种：

* ==system_clock==：系统的时钟，系统的时钟可以修改，甚至可以网络对时，因此使用系统时间计算时间差可能不准。
* ==steady_clock==：是固定的时钟，相当于秒表。开始计时后，时间只会增长并且不能修改，适合用于记录程序耗时
* ==high_resolution_clock==：和时钟类 steady_clock 是等价的（是它的别名）。

在这些时钟类的内部有time_point、duration、Rep、Period等信息，基于这些信息来获取当前时间，以及实现time_t和time_point之间的相互转换。

| 时钟类成员类型 | 描述                               |
| -------------- | ---------------------------------- |
| rep            | 表示时钟周期次数的有符号算术类型   |
| period         | 表示时钟计次周期的 std::ratio 类型 |
| duration       | 时间间隔，可以表示负时长           |
| time_point     | 表示在当前时钟里边记录的时间点     |

**在使用chrono提供的时钟类的时候，不需要创建类对象，直接调用类的静态方法就可以得到想要的时间了。**

##### 3.1 system_clock

具体来说，时钟类system_clock是一个系统范围的实时时钟。system_clock提供了对当前时间点time_point的访问，将得到时间点转换为time_t类型的时间对象，就可以基于这个时间对象获取到当前的时间信息了。

system_clock时钟类在底层源码中的定义如下：

```c++
struct system_clock { // wraps GetSystemTimePreciseAsFileTime/GetSystemTimeAsFileTime
    using rep                       = long long;
    using period                    = ratio<1, 10'000'000>; // 100 nanoseconds
    using duration                  = chrono::duration<rep, period>;
    using time_point                = chrono::time_point<system_clock>;
    static constexpr bool is_steady = false;

    _NODISCARD static time_point now() noexcept 
    { // get current time
        return time_point(duration(_Xtime_get_ticks()));
    }

    _NODISCARD static __time64_t to_time_t(const time_point& _Time) noexcept 
    { // convert to __time64_t
        return duration_cast<seconds>(_Time.time_since_epoch()).count();
    }

    _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept 
    { // convert from __time64_t
        return time_point{seconds{_Tm}};
    }

};
```



> 通过以上源码可以了解到在system_clock类中的一些细节信息：
>
> rep：时钟周期次数是通过整形来记录的long long
> period：一个时钟周期是100纳秒ratio<1, 10'000'000>
> duration：时间间隔为rep*period纳秒chrono::duration<rep, period>
> time_point：时间点通过系统时钟做了初始化chrono::time_point<system_clock>，里面记录了新纪元时间点
>
> 

另外还可以看到system_clock类一共提供了三个静态成员函数：

```c++
// 返回表示当前时间的时间点。
static std::chrono::time_point<std::chrono::system_clock> now() noexcept;
// 将 time_point 时间点类型转换为 std::time_t 类型
static std::time_t to_time_t( const time_point& t ) noexcept;
// 将 std::time_t 类型转换为 time_point 时间点类型
static std::chrono::system_clock::time_point from_time_t( std::time_t t ) noexcept;
```

比如，我们要获取当前的系统时间，并且需要将其以能够识别的方式打印出来，示例代码如下：

```c++
#include <chrono>
#include <iostream>
using namespace std;
using namespace std::chrono;
int main()
{
    // 新纪元1970.1.1时间
    system_clock::time_point epoch;

    duration<int, ratio<60*60*24>> day(1);
    // 新纪元1970.1.1时间 + 1天
    system_clock::time_point ppt(day);

    using dday = duration<int, ratio<60 * 60 * 24>>;
    // 新纪元1970.1.1时间 + 10天
    time_point<system_clock, dday> t(dday(10));

    // 系统当前时间
    system_clock::time_point today = system_clock::now();

    // 转换为time_t时间类型
    time_t tm = system_clock::to_time_t(today);
    cout << "今天的日期是:    " << ctime(&tm);

    time_t tm1 = system_clock::to_time_t(today+day);
    cout << "明天的日期是:    " << ctime(&tm1);

    time_t tm2 = system_clock::to_time_t(epoch);
    cout << "新纪元时间:      " << ctime(&tm2);

    time_t tm3 = system_clock::to_time_t(ppt);
    cout << "新纪元时间+1天:  " << ctime(&tm3);

    time_t tm4 = system_clock::to_time_t(t);
    cout << "新纪元时间+10天: " << ctime(&tm4);

}
/*
示例代码打印的结果为：

今天的日期是:    Thu Apr  8 11:09:49 2021
明天的日期是:    Fri Apr  9 11:09:49 2021
新纪元时间:      Thu Jan  1 08:00:00 1970
新纪元时间+1天:  Fri Jan  2 08:00:00 1970
新纪元时间+10天: Sun Jan 11 08:00:00 1970
```



##### 3.2 steady_clock

如果我们通过时钟不是为了获取当前的系统时间，而是进行程序耗时的时长，此时使用syetem_clock就不合适了，因为这个时间可以跟随系统的设置发生变化。在C++11中提供的时钟类steady_clock相当于秒表，只要启动就会进行时间的累加，并且不能被修改，非常适合于进行耗时的统计。

steady_clock时钟类在底层源码中的定义如下：

```c++
struct steady_clock { // wraps QueryPerformanceCounter
    using rep                       = long long;
    using period                    = nano;
    using duration                  = nanoseconds;
    using time_point                = chrono::time_point<steady_clock>;
    static constexpr bool is_steady = true;
    // get current time
    _NODISCARD static time_point now() noexcept 
    { 
        // doesn't change after system boot
        const long long _Freq = _Query_perf_frequency(); 
        const long long _Ctr  = _Query_perf_counter();
        static_assert(period::num == 1, "This assumes period::num == 1.");
        const long long _Whole = (_Ctr / _Freq) * period::den;
        const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;
        return time_point(duration(_Whole + _Part));
	}
};
```

通过以上源码可以了解到在steady_clock类中的一些细节信息：

> * rep：时钟周期次数是通过整形来记录的long long
> * period：一个时钟周期是1纳秒nano
> * duration：时间间隔为1纳秒nanoseconds
> * time_point：时间点通过系统时钟做了初始化
> * chrono::time_point<steady_clock>

另外，在这个类中也提供了一个静态的now()方法，用于得到当前的时间点，函数原型如下：

```c++
static std::chrono::time_point<std::chrono::steady_clock> now() noexcept;
```

假设要测试某一段程序的执行效率，可以计算它执行期间消耗的总时长，示例代码如下：

```c++
#include <chrono>
#include <iostream>
using namespace std;
using namespace std::chrono;
int main()
{
    // 获取开始时间点
    steady_clock::time_point start = steady_clock::now();
    // 执行业务流程
    cout << "print 1000 stars ...." << endl;
    for (int i = 0; i < 1000; ++i)
    {
        cout << "*";
    }
    cout << endl;
    // 获取结束时间点
    steady_clock::time_point last = steady_clock::now();
    // 计算差值
    auto dt = last - start;
    cout << "总共耗时: " << dt.count() << "纳秒" << endl;
}
```



##### 3.3 high_resolution_clock

==high_resolution_clock提供的时钟精度比system_clock要高==，它也是不可以修改的。在底层源码中，这个类其实是steady_clock类的别名。

```c++
using high_resolution_clock = steady_clock;
```

因此high_resolution_clock的使用方式和steady_clock是一样的，在此就不再过多进行赘述了。

#### 4. 转换函数

##### 4.1 duration_cast

duration_cast是chrono库提供的一个模板函数，这个函数不属于duration类。通过这个函数可以对duration类对象内部的时钟周期Period，和周期次数的类型Rep进行修改，该函数原型如下：

```c++
template <class ToDuration, class Rep, class Period>
  constexpr ToDuration duration_cast (const duration<Rep,Period>& dtn);
```

> 1. ==如果是对时钟周期进行转换：源时钟周期必须能够整除目的时钟周期（比如：小时到分钟）。==
> 2. ==如果是对时钟周期次数的类型进行转换：低等类型默认可以向高等类型进行转换（比如：int 转 double）。==
> 3. ==如果时钟周期和时钟周期次数类型都变了，根据第二点进行推导（也就是看时间周期次数类型）。==
> 4. ==以上条件都不满足，那么就需要使用 duration_cast 进行显示转换。==



我们可以修改一下上面测试程序执行时间的代码，在代码中修改duration对象的属性：

```c++
#include <iostream>
#include <chrono>
using namespace std;
using namespace std::chrono;

void f()
{
    cout << "print 1000 stars ...." << endl;
    for (int i = 0; i < 1000; ++i)
    {
        cout << "*";
    }
    cout << endl;
}

int main()
{
    auto t1 = steady_clock::now();
    f();
    auto t2 = steady_clock::now();

// 整数时长：时钟周期纳秒转毫秒，要求 duration_cast
auto int_ms = duration_cast<chrono::milliseconds>(t2 - t1);

// 小数时长：不要求 duration_cast
duration<double, ratio<1, 1000>> fp_ms = t2 - t1;

cout << "f() took " << fp_ms.count() << " ms, "
    << "or " << int_ms.count() << " whole milliseconds\n";

}

示例代码输出的结果：

print 1000 stars ....

****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************

f() took 40.2547 ms, or 40 whole milliseconds
```



##### 4.2 time_point_cast

time_point_cast也是chrono库提供的一个模板函数，这个函数不属于time_point类。函数的作用是对时间点进行转换，因为不同的时间点对象内部的时钟周期Period，和周期次数的类型Rep可能也是不同的，一般情况下它们之间可以进行隐式类型转换，也可以通过该函数显示的进行转换，函数原型如下：

```c++
template <class ToDuration, class Clock, class Duration>
time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration> &t);
```

关于函数的使用，示例代码如下：

```c++
#include <chrono>
#include <iostream>
using namespace std;

using Clock = chrono::high_resolution_clock;
using Ms = chrono::milliseconds;
using Sec = chrono::seconds;
template<class Duration>
using TimePoint = chrono::time_point<Clock, Duration>;

void print_ms(const TimePoint<Ms>& time_point)
{
    std::cout << time_point.time_since_epoch().count() << " ms\n";
}

int main()
{
    TimePoint<Sec> time_point_sec(Sec(6));
    // 无精度损失, 可以进行隐式类型转换
    TimePoint<Ms> time_point_ms(time_point_sec);
    print_ms(time_point_ms);    // 6000 ms

    time_point_ms = TimePoint<Ms>(Ms(6789));
    // error，会损失精度，不允许进行隐式的类型转换
    TimePoint<Sec> sec(time_point_ms);

    // 显示类型转换,会损失精度。6789 truncated to 6000
    time_point_sec = std::chrono::time_point_cast<Sec>(time_point_ms);
    print_ms(time_point_sec); // 6000 ms

}
```

==注意事项：关于时间点的转换如果没有没有精度的损失可以直接进行隐式类型转换，如果会损失精度只能通过显示类型转换，也就是调用time_point_cast函数来完成该操作。==

### (3) C++线程的使用

C++11之前，C++语言没有对并发编程提供语言级别的支持，这使得我们在编写可移植的并发程序时，存在诸多的不便。现在C++11中增加了线程以及线程相关的类，很方便地支持了并发编程，使得编写的多线程程序的可移植性得到了很大的提高。

C++11中提供的线程类叫做==std::thread==，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。我们首先来了解一下这个类提供的一些常用API：
#### 1. 构造函数

```c++
// ①
thread() noexcept;
// ②
thread( thread&& other ) noexcept;
// ③
template< class Function, class... Args >
explicit thread( Function&& f, Args&&... args );
// ④
thread( const thread& ) = delete;
```



> 构造函数①：==默认构造函==，构造一个线程对象，在这个线程中不执行任何处理动作
>
> 构造函数②：==移动构造函数==，将 other 的线程所有权转移给新的thread 对象。之后 other 不再表示执行线程。
>
> 构造函数③：==创建线程对象==，并在该线程中执行函数f中的业务逻辑，args是要传递给函数f的参数
>
> ​	任务函数f的可选类型有很多，具体如下：
> ​    	普通函数，类成员函数，匿名函数，仿函数（这些都是可调用对象类型）
> ​    	可以是可调用对象包装器类型，也可以是使用绑定器绑定之后得到的类型（仿函数）
>
> 构造函数④：使用===delete显示删除拷贝构造, 不允许线程对象之间的拷贝==

#### 2. 公共成员函数

##### 2.1 get_id()

应用程序启动之后默认只有一个线程，这个线程一般称之为==主线程或父线程==，通过线程类创建出的线程一般称之为==子线程==，每个被创建出的线程实例都对应一个线程ID，这个==ID是唯一==的，可以通过这个ID来区分和识别各个已经存在的线程实例，这个==获取线程ID的函数叫做get_id()==，函数原型如下：

```c++
std::thread::id get_id() const noexcept;
```

示例程序如下：

```c++
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void func(int num, string str)
{
    for (int i = 0; i < 10; ++i)
    {
        cout << "子线程: i = " << i << "num: " 
             << num << ", str: " << str << endl;
    }
}

void func1()
{
    for (int i = 0; i < 10; ++i)
    {
        cout << "子线程: i = " << i << endl;
    }
}

int main()
{
    cout << "主线程的线程ID: " << this_thread::get_id() << endl;
    thread t(func, 520, "i love you");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
}
```



> * **thread t(func, 520, "i love you");**：创建了子线程对象t，func()函数会在这个子线程中运行
>   * **func()是一个回调函数**，线程启动之后就会执行这个任务函数，程序猿只需要实现即可
>   * func()的参数是通过thread的参数进行传递的，520,i love you都是调用func()需要的实参
>   * **线程类的构造函数③是一个变参函数**，因此无需担心线程任务函数的参数个数问题
>   * **任务函数func()一般返回值指定为void**，因为子线程在调用这个函数的时候不会处理其返回值
> * thread t1(func1);：子线程对象t1中的任务函数func1()，没有参数，因此在线程构造函数中就无需指定了
> * 通过线程对象调用get_id()就可以知道这个子线程的线程ID了，t.get_id()，t1.get_id()。
> * 基于命名空间 this_thread 得到当前线程的线程ID

==在上面的示例程序中有一个bug，在主线程中依次创建出两个子线程，打印两个子线程的线程ID，最后主线程执行完毕就退出了（主线程就是执行main()函数的那个线程）。默认情况下，主线程销毁时会将与其关联的两个子线程也一并销毁，但是这时有可能子线程中的任务还没有执行完毕，最后也就得不到我们想要的结果了。==

当启动了一个线程（创建了一个thread对象）之后，在这个线程结束的时候（std::terminate()），我们如何去回收线程所使用的资源呢？thread库给我们两种选择：

* ==加入式（join()）==
* ==分离式（detach()）==

另外，我们必须要在线程对象销毁之前在二者之间作出选择，否则程序运行期间就会有bug产生。

##### 2.2 join()

**join()字面意思是连接一个线程**，意味着主动地等待线程的终止（线程阻塞）。在某个线程中通过子线程对象调用

join()函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后

join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。

再次强调，我们一定要搞清楚这个函数阻塞的是哪一个线程，**函数在哪个线程中被执行，那么函数就阻塞哪个线程**。该函数的函数原型如下：

```c++
void join();
```

有了这样一个线程阻塞函数之后，就可以解决在上面测试程序中的bug了，==如果要阻塞主线程的执行，只需要在主线程中通过子线程对象调用这个方法即可，当调用这个方法的子线程对象中的任务函数执行完毕之后，主线程的阻塞也就随之解除了==。修改之后的示例代码如下：

```
int main()
{
    cout << "主线程的线程ID: " << this_thread::get_id() << endl;
    thread t(func, 520, "i love you");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
    t.join();
    t1.join();
}
```

> 当主线程运行到第八行t.join();，根据子线程对象t的任务函数func()的执行情况，主线程会做如下处理：
>
> * 如果任务函数func()还没执行完毕，主线程阻塞，直到任务执行完毕，主线程解除阻塞，继续向下运行
> * 如果任务函数func()已经执行完毕，主线程不会阻塞，继续向下运行

同样，第9行的代码亦如此。

为了更好的理解join()的使用，再来给大家举一个例子，场景如下：

程序中一共有三个线程，其中两个子线程负责分段下载同一个文件，下载完毕之后，由主线程对这个文件进行下一步处理，那么示例程序就应该这么写：



```c++
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void download1()
{
    // 模拟下载, 总共耗时500ms，阻塞线程500ms
    this_thread::sleep_for(chrono::milliseconds(500));
    cout << "子线程1: " << this_thread::get_id() << ", 找到历史正文...." << endl;
}

void download2()
{
    // 模拟下载, 总共耗时300ms，阻塞线程300ms
    this_thread::sleep_for(chrono::milliseconds(300));
    cout << "子线程2: " << this_thread::get_id() << ", 找到历史正文...." << endl;
}

void doSomething()
{
    cout << "集齐历史正文, 呼叫罗宾...." << endl;
    cout << "历史正文解析中...." << endl;
    cout << "起航，前往拉夫德尔...." << endl;
    cout << "找到OnePiece, 成为海贼王, 哈哈哈!!!" << endl;
    cout << "若干年后，草帽全员卒...." << endl;
    cout << "大海贼时代再次被开启...." << endl;
}

int main()
{
    thread t1(download1);
    thread t2(download2);
    // 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行
    t1.join();
    t2.join();
    doSomething();
}
/*
示例程序输出的结果：

子线程2: 72540, 找到历史正文....
子线程1: 79776, 找到历史正文....
集齐历史正文, 呼叫罗宾....
历史正文解析中....
起航，前往拉夫德尔....
找到OnePiece, 成为海贼王, 哈哈哈!!!
若干年后，草帽全员卒....
大海贼时代再次被开启....
```

在上面示例程序中最核心的处理是在==主线程调用doSomething();==之前在第35、36行通过子线程对象调用了join()方法，这样就能够保证两个子线程的任务都执行完毕了，也就是文件内容已经全部下载完成，主线程再对文件进行后续处理，如果子线程的文件没有下载完毕，主线程就去处理文件，很显然从逻辑上讲是有问题的。

基于命名空间 this_thread 让当前线程休眠

##### 2.3 detach()

detach()函数的作用是==进行线程分离==，分离主线程和创建出的子线程。==在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。==（其实就是孩子翅膀硬了，和家里断绝关系，自己外出闯荡了，如果家里被诛九族还是会受牵连）。该函数函数原型如下：

```c++
void detach();
```

线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可，继续将上面的测试程序修改一下：

```
int main()
{
    cout << "主线程的线程ID: " << this_thread::get_id() << endl;
    thread t(func, 520, "i love you");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
    t.detach();
    t1.detach();
    // 让主线程休眠, 等待子线程执行完毕
    this_thread::sleep_for(chrono::seconds(5));
}
```

> ==注意事项：线程分离函数detach()不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或者调用get_id()获取子线程的线程ID。有利就有弊，鱼和熊掌不可兼得，建议使用join()。==

##### 2.5 joinable()

joinable()函数用于==判断主线程和子线程是否处理关联（连接）状态==，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：

* 返回值为true：主线程和子线程之间有关联（连接）关系
* 返回值为false：主线程和子线程之间没有关联（连接）关系



```c++
bool joinable() const noexcept;

示例代码如下：

#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void foo()
{
    this_thread::sleep_for(std::chrono::seconds(1));
}

int main()
{
    thread t;
    cout << "before starting, joinable: " << t.joinable() << endl;

    t = thread(foo);
    cout << "after starting, joinable: " << t.joinable() << endl;

    t.join();
    cout << "after joining, joinable: " << t.joinable() << endl;

    thread t1(foo);
    cout << "after starting, joinable: " << t1.joinable() << endl;
    t1.detach();
    cout << "after detaching, joinable: " << t1.joinable() << endl;

}
/*
示例代码打印的结果如下：

before starting, joinable: 0
after starting, joinable: 1
after joining, joinable: 0
after starting, joinable: 1
after detaching, joinable: 0
```

基于示例代码打印的结果可以得到以下结论：

> * ==在创建的子线程对象的时候，如果没有指定任务函数，那么子线程不会启动，主线程和这个子线程也不会进行连接==
> * ==在创建的子线程对象的时候，如果指定了任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功==
> * ==子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false==
> * ==在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。==

##### 2.6 operator=

==线程中的资源是不能被复制的==，因此通过**=操作符**进行赋值操作最终**并不会得到两个完全相同的对象**。

```c++
// move (1)	
thread& operator= (thread&& other) noexcept;
// copy [deleted] (2)	
thread& operator= (const other&) = delete;
```

通过以上=操作符的重载声明可以得知：

* 如果other是一个右值，会进行资源所有权的转移
* 如果other不是右值，禁止拷贝，该函数被显示删除（=delete），不可用

#### 3. 静态函数

thread线程类还提供了一个静态方法，用于获取当前计算机的CPU核心数，根据这个结果在程序中创建出数量相等的线程，==每个线程独自占有一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的==。

```c++
static unsigned hardware_concurrency() noexcept;
```

示例代码如下：

```c++
#include <iostream>
#include <thread>
using namespace std;

int main()
{
    int num = thread::hardware_concurrency();
    cout << "CPU number: " << num << endl;
}
```



#### 4. C线程库

C语言提供的线程库不论在window还是Linux操作系统中都是可以使用的，看明白了这些C语言中的线程函数之后会发现它和上面的C++线程类使用很类似（其实就是基于面向对象的思想进行了封装），但C++的线程类用起来更简单一些，链接奉上，感兴趣的可以一看。

### (4) 命名空间 - this_thread

在C++11中不仅添加了线程类，还添加了一个关于线程的命名空间==std::this_thread==，在这个命名空间中提供了四个公共的成员函数，通过这些成员函数就可以对当前线程进行相关的操作了。

#### 1. get_id()

调用命名空间std::this_thread中的get_id()方法可以得到当前线程的线程ID，函数原型如下：

```
thread::id get_id() noexcept;
```

关于函数使用对应的示例代码如下：

```
#include <iostream>
#include <thread>
using namespace std;

void func()
{
    cout << "子线程: " << this_thread::get_id() << endl;
}

int main()
{
    cout << "主线程: " << this_thread::get_id() << endl;
    thread t(func);
    t.join();
}
```

程序启动，开始执行main()函数，此时只有一个线程也就是主线程。当创建了子线程对象t之后，指定的函数func()会在子线程中执行，这时通过调用==this_thread::get_id()==就可以得到当前线程的线程ID了。

#### 2. sleep_for()

进程被创建后一共有五种状态

同样地线程被创建后也有这五种状态：==创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态)== ，关于状态之间的转换是一样的，请参考进程，在此不再过多的赘述。

线程和进程的执行有很多相似之处，在计算机中启动的多个线程都需要占用CPU资源，但是CPU的个数是有限的并且每个CPU在同一时间点不能同时处理多个任务。==为了能够实现并发处理，多个线程都是分时复用CPU时间片，快速的交替处理各个线程中的任务。因此多个线程之间需要争抢CPU时间片，抢到了就执行，抢不到则无法执行==（因为默认所有的线程优先级都相同，内核也会从中调度，不会出现某个线程永远抢不到CPU时间片的情况）。

命名空间this_thread中提供了一个休眠函数sleep_for()，调用这个函数的线程会马上==从运行态变成阻塞态==并在这种状态下休眠一定的时长，因为阻塞态的线程已经让出了CPU资源，代码也不会被执行，所以线程休眠过程中对CPU来说没有任何负担。这个函数是函数原型如下，参数需要指定一个休眠时长，是一个时间段：
**chrono库中的时间段类 duration 的使用**

```
template <class Rep, class Period>
  void sleep_for (const chrono::duration<Rep,Period>& rel_time);
```

示例程序如下：

```
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void func()
{
    for (int i = 0; i < 10; ++i)
    {
        this_thread::sleep_for(chrono::seconds(1));
        cout << "子线程: " << this_thread::get_id() << ", i = " << i << endl;
    }
}

int main()
{
    thread t(func);
    t.join();
}
```

在func()函数的for循环中使用了==this_thread::sleep_for(chrono::seconds(1))==;之后，**每循环一次程序都会阻塞1秒钟**，也就是说每隔1秒才会进行一次输出。需要注意的是：==程序休眠完成之后，会从阻塞态重新变成就绪态，就绪态的线程需要再次争抢CPU时间片，抢到之后才会变成运行态，这时候程序才会继续向下运行。==

#### 3. sleep_until()

命名空间this_thread中提供了另一个休眠函数sleep_until()，和sleep_for()不同的是它的参数类型不一样

* sleep_until()：指定线程阻塞到某一个指定的==时间点time_point类型==，之后解除阻塞
* sleep_for()：指定线程阻塞一定的==时间长度duration 类型==，之后解除阻塞

**chrono库中的时间点类 time_point 的使用**

该函数的函数原型如下：

```
template <class Clock, class Duration>
  void sleep_until (const chrono::time_point<Clock,Duration>& abs_time);
```

示例程序如下：

```
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void func()
{
    for (int i = 0; i < 10; ++i)
    {
        // 获取当前系统时间点
        auto now = chrono::system_clock::now();
        // 时间间隔为2s
        chrono::seconds sec(2);
        // 当前时间点之后休眠两秒
        this_thread::sleep_until(now + sec);
        cout << "子线程: " << this_thread::get_id() << ", i = " << i << endl;
    }
}

int main()
{
    thread t(func);
    t.join();
}
```

==sleep_until()和sleep_for()函数的功能是一样的，只不过前者是基于时间点去阻塞线程，后者是基于时间段去阻塞线程==，项目开发过程中根据实际情况选择最优的解决方案即可。

#### 4. yield()

命名空间this_thread中提供了一个非常绅士的函数yield()，在线程中调用这个函数之后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了。使用这个函数的时候需要注意一点，==线程调用了yield()之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题==。

```
void yield() noexcept;
```

函数对应的示例程序如下：

```
#include <iostream>
#include <thread>
using namespace std;

void func()
{
    for (int i = 0; i < 100000000000; ++i)
    {
        cout << "子线程: " << this_thread::get_id() << ", i = " << i << endl;
        this_thread::yield();
    }
}

int main()
{
    thread t(func);
    thread t1(func);
    t.join();
    t1.join();
}
```

在上面的程序中，执行func()中的for循环会占用大量的时间，在极端情况下，如果当前线程占用CPU资源不释放就会导致其他线程中的任务无法被处理，或者该线程每次都能抢到CPU时间片，导致其他线程中的任务没有机会被执行。解决方案就是每执行一次循环，让该线程主动放弃CPU资源，重新和其他线程再次抢夺CPU时间片，如果其他线程抢到了CPU时间片就可以执行相应的任务了。

> 结论：
>
> 1. ==std::this_thread::yield() 的目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降==
> 2. ==std::this_thread::yield() 是让当前线程主动放弃了当前自己抢到的CPU资源，但是在下一轮还会继续抢==



### (5) call_once

在某些特定情况下，某些函数只能在多线程环境下调用一次，比如：要初始化某个对象，而这个对象只能被初始化一次，就可以使用==std::call_once()来保证函数在多线程环境下只能被调用一次==。使用call_once()的时候，需要一个once_flag作为call_once()的传入参数，该函数的原型如下：

```
// 定义于头文件 <mutex>
template< class Callable, class... Args >
void call_once( std::once_flag& flag, Callable&& f, Args&&... args );
```

* flag：once_flag类型的对象，要保证这个对象能够被多个线程同时访问到
* f：回调函数，可以传递一个有名函数地址，也可以指定一个匿名函数
* args：作为实参传递给回调函数

多线程操作过程中，std::call_once()内部的回调函数只会被执行一次，示例代码如下：

```
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

once_flag g_flag;
void do_once(int a, string b)
{
    cout << "name: " << b << ", age: " << a << endl;
}

void do_something(int age, string name)
{
    static int num = 1;
    call_once(g_flag, do_once, 19, "luffy");
    cout << "do_something() function num = " << num++ << endl;
}

int main()
{
    thread t1(do_something, 20, "ace");
    thread t2(do_something, 20, "sabo");
    thread t3(do_something, 19, "luffy");
    t1.join();
    t2.join();
    t3.join();

​	return 0;

}
/*
示例程序输出的结果：

name: luffy, age: 19
do_something() function num = 1
do_something() function num = 2
do_something() function num = 3
```

通过输出的结果可以看到，虽然运行的**三个线程中都执行了任务函数do_something()但是call_once()中指定的回调函数只被执行了一次**，我们的目的也达到了。

### (6) [线程同步](https://subingwen.cn/linux/thread-sync/#1-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5)

1. 线程同步概念

假设有4个线程A、B、C、D，当前一个线程A对内存中的共享资源进行访问的时候，其他线程B, C, D都不可以对这块内存进行操作，直到线程A对这块内存访问完毕为止，B，C，D中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。
1.1 为什么要同步

```
在研究线程同步之前，先来看一个两个线程交替数数（每个线程数50个数，交替数到100）的例子：
```

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <pthread.h>

#define MAX 50
// 全局变量
int number;

// 线程处理函数
void* funcA_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        printf("Thread A, id = %lu, number = %d\n", pthread_self(), number);
    }

```
return NULL;
```
}

void* funcB_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        int cur = number;
        cur++;
        number = cur;
        printf("Thread B, id = %lu, number = %d\n", pthread_self(), number);
        usleep(5);
    }

```
return NULL;
```
}

int main(int argc, const char* argv[])
{
    pthread_t p1, p2;

```
// 创建两个子线程
pthread_create(&p1, NULL, funcA_num, NULL);
pthread_create(&p2, NULL, funcB_num, NULL);

// 阻塞，资源回收
pthread_join(p1, NULL);
pthread_join(p2, NULL);

return 0;
```
}

编译并执行上面的测试程序，得到如下结果：

$ ./a.out 
Thread B, id = 140504473724672, number = 1
Thread B, id = 140504473724672, number = 2
Thread A, id = 140504482117376, number = 2
Thread B, id = 140504473724672, number = 3
Thread A, id = 140504482117376, number = 4
Thread B, id = 140504473724672, number = 5
Thread A, id = 140504482117376, number = 6
Thread B, id = 140504473724672, number = 7
Thread B, id = 140504473724672, number = 8
Thread A, id = 140504482117376, number = 7
Thread B, id = 140504473724672, number = 8
Thread B, id = 140504473724672, number = 9
Thread A, id = 140504482117376, number = 8
Thread B, id = 140504473724672, number = 9
Thread A, id = 140504482117376, number = 9
Thread B, id = 140504473724672, number = 10
Thread B, id = 140504473724672, number = 11
Thread A, id = 140504482117376, number = 10
Thread B, id = 140504473724672, number = 11
Thread A, id = 140504482117376, number = 11
Thread B, id = 140504473724672, number = 12
Thread A, id = 140504482117376, number = 13
Thread B, id = 140504473724672, number = 14
Thread A, id = 140504482117376, number = 15
Thread B, id = 140504473724672, number = 16
Thread B, id = 140504473724672, number = 17
Thread B, id = 140504473724672, number = 18
Thread B, id = 140504473724672, number = 19
Thread A, id = 140504482117376, number = 17
Thread B, id = 140504473724672, number = 18
Thread B, id = 140504473724672, number = 19
Thread A, id = 140504482117376, number = 19
Thread B, id = 140504473724672, number = 20
Thread A, id = 140504482117376, number = 20
Thread B, id = 140504473724672, number = 21
Thread A, id = 140504482117376, number = 21
Thread B, id = 140504473724672, number = 22
Thread A, id = 140504482117376, number = 22
Thread B, id = 140504473724672, number = 23
Thread A, id = 140504482117376, number = 23
Thread B, id = 140504473724672, number = 24
Thread A, id = 140504482117376, number = 24
Thread B, id = 140504473724672, number = 25
Thread A, id = 140504482117376, number = 25
Thread B, id = 140504473724672, number = 26
Thread A, id = 140504482117376, number = 26
Thread B, id = 140504473724672, number = 27
Thread A, id = 140504482117376, number = 27
Thread B, id = 140504473724672, number = 28
Thread A, id = 140504482117376, number = 28
Thread B, id = 140504473724672, number = 29
Thread A, id = 140504482117376, number = 29
Thread B, id = 140504473724672, number = 30
Thread A, id = 140504482117376, number = 30
Thread B, id = 140504473724672, number = 31
Thread A, id = 140504482117376, number = 31
Thread B, id = 140504473724672, number = 32
Thread A, id = 140504482117376, number = 32
Thread B, id = 140504473724672, number = 33
Thread A, id = 140504482117376, number = 33
Thread B, id = 140504473724672, number = 34
Thread A, id = 140504482117376, number = 34
Thread B, id = 140504473724672, number = 35
Thread A, id = 140504482117376, number = 35
Thread B, id = 140504473724672, number = 36
Thread A, id = 140504482117376, number = 36
Thread B, id = 140504473724672, number = 37
Thread A, id = 140504482117376, number = 37
Thread B, id = 140504473724672, number = 38
Thread A, id = 140504482117376, number = 38
Thread B, id = 140504473724672, number = 39
Thread A, id = 140504482117376, number = 39
Thread A, id = 140504482117376, number = 40
Thread B, id = 140504473724672, number = 41
Thread B, id = 140504473724672, number = 42
Thread A, id = 140504482117376, number = 42
Thread A, id = 140504482117376, number = 43
Thread B, id = 140504473724672, number = 44
Thread B, id = 140504473724672, number = 45
Thread A, id = 140504482117376, number = 45
Thread B, id = 140504473724672, number = 46
Thread A, id = 140504482117376, number = 46
Thread B, id = 140504473724672, number = 47
Thread A, id = 140504482117376, number = 47
Thread B, id = 140504473724672, number = 48
Thread A, id = 140504482117376, number = 48
Thread B, id = 140504473724672, number = 49
Thread A, id = 140504482117376, number = 50
Thread B, id = 140504473724672, number = 51
Thread A, id = 140504482117376, number = 51
Thread B, id = 140504473724672, number = 52
Thread A, id = 140504482117376, number = 53
Thread A, id = 140504482117376, number = 54
Thread A, id = 140504482117376, number = 55
Thread A, id = 140504482117376, number = 56
Thread A, id = 140504482117376, number = 57
Thread A, id = 140504482117376, number = 58
Thread A, id = 140504482117376, number = 59
Thread A, id = 140504482117376, number = 60
Thread A, id = 140504482117376, number = 61
robin@OS:~/abc/b$ 

通过对上面例子的测试，可以看出虽然每个线程内部循环了50次每次数一个数，但是最终没有数到100，通过输出的结果可以看到，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了数据的混乱。

两个线程在数数的时候需要分时复用CPU时间片，并且测试程序中调用了sleep()导致线程的CPU时间片没用完就被迫挂起了，这样就能让CPU的上下文切换（保存当前状态, 下一次继续运行的时候需要加载保存的状态）更加频繁，更容易再现数据混乱的这个现象。

CPU对应寄存器、一级缓存、二级缓存、三级缓存是独占的，用于存储处理的数据和线程的状态信息，数据被CPU处理完成需要再次被写入到物理内存中，物理内存数据也可以通过文件IO操作写入到磁盘中。

在测试程序中两个线程共用全局变量number当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到CPU进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。

如果线程A执行这个过程期间就失去了CPU时间片，线程A被挂起了最新的数据没能更新到物理内存。线程B变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去CPU时间片挂起。线程A得到CPU时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程B已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。
1.2 同步方式

对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：互斥锁、读写锁、条件变量、信号量。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为临界资源。

image-20200106092600543

找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为临界区。确定好临界区（临界区越小越好）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的：

```
在临界区代码的上边，添加加锁函数，对临界区加锁。
    哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。
在临界区代码的下边，添加解锁函数，对临界区解锁。
    出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。
通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变为串行访问了。
```

2. 互斥锁
2.1 互斥锁函数

互斥锁是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块, 被锁定的这个代码块, 所有的线程只能顺序执行(不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。

在Linux中互斥锁的类型为pthread_mutex_t，创建一个这种类型的变量就得到了一把互斥锁：

pthread_mutex_t  mutex;

在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。一般情况下，每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。

```
Linux 提供的互斥锁操作函数如下，如果函数调用成功会返回0，调用失败会返回相应的错误号：
```

// 初始化互斥锁
// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);
// 释放互斥锁资源            
int pthread_mutex_destroy(pthread_mutex_t *mutex);

```
参数:
    mutex: 互斥锁变量的地址
    attr: 互斥锁的属性, 一般使用默认属性即可, 这个参数指定为NULL
```

// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中
int pthread_mutex_lock(pthread_mutex_t *mutex);

这个函数被调用, 首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:

```
没有被锁定, 是打开的, 这个线程可以加锁成功, 这个这个锁中会记录是哪个线程加锁成功了
如果被锁定了, 其他线程加锁就失败了, 这些线程都会阻塞在这把锁上
当这把锁被解开之后, 这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞
```

// 尝试加锁
int pthread_mutex_trylock(pthread_mutex_t *mutex);

调用这个函数对互斥锁变量加锁还是有两种情况:

```
如果这把锁没有被锁定是打开的，线程加锁成功
如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号
```

// 对互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);

不是所有的线程都可以对互斥锁解锁，哪个线程加的锁, 哪个线程才能解锁成功。
2.1 互斥锁使用

我们可以将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <pthread.h>

#define MAX 100
// 全局变量
int number;

// 创建一把互斥锁
// 全局变量, 多个线程共享
pthread_mutex_t mutex;

// 线程处理函数
void* funcA_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        // 如果线程A加锁成功, 不阻塞
        // 如果B加锁成功, 线程A阻塞
        pthread_mutex_lock(&mutex);
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        pthread_mutex_unlock(&mutex);
        printf("Thread A, id = %lu, number = %d\n", pthread_self(), number);
    }

```
return NULL;
```
}

void* funcB_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        // a加锁成功, b线程访问这把锁的时候是锁定的
        // 线程B先阻塞, a线程解锁之后阻塞解除
        // 线程B加锁成功了
        pthread_mutex_lock(&mutex);
        int cur = number;
        cur++;
        number = cur;
        pthread_mutex_unlock(&mutex);
        printf("Thread B, id = %lu, number = %d\n", pthread_self(), number);
        usleep(5);
    }

```
return NULL;
```
}

int main(int argc, const char* argv[])
{
    pthread_t p1, p2;

```
// 初始化互斥锁
pthread_mutex_init(&mutex, NULL);

// 创建两个子线程
pthread_create(&p1, NULL, funcA_num, NULL);
pthread_create(&p2, NULL, funcB_num, NULL);

// 阻塞，资源回收
pthread_join(p1, NULL);
pthread_join(p2, NULL);

// 销毁互斥锁
// 线程销毁之后, 再去释放互斥锁
pthread_mutex_destroy(&mutex);

return 0;
```
}

3. 死锁

当多个线程访问共享资源, 需要加锁, 如果锁使用不当, 就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。

造成死锁的场景有如下几种：

```
加锁之后忘记解锁
```

// 场景1
void func()
{
    for(int i=0; i<6; ++i)
    {
        // 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了
        // 其余的线程也被阻塞
    	pthread_mutex_lock(&mutex);
    	....
    	.....
        // 忘记解锁
    }
}

// 场景2
void func()
{
    for(int i=0; i<6; ++i)
    {
        // 当前线程A加锁成功
        // 其余的线程被阻塞
    	pthread_mutex_lock(&mutex);
    	....
    	.....
        if(xxx)
        {
            // 函数退出, 没有解锁（解锁函数无法被执行了）
            return ;
        }
        
```
    pthread_mutex_lock(&mutex);
}
```
}

重复加锁, 造成死锁

void func()
{
    for(int i=0; i<6; ++i)
    {
        // 当前线程A加锁成功
        // 其余的线程阻塞
    	pthread_mutex_lock(&mutex);
        // 锁被锁住了, A线程阻塞
        pthread_mutex_lock(&mutex);
    	....
    	.....
        pthread_mutex_unlock(&mutex);
    }
}

// 隐藏的比较深的情况
void funcA()
{
    for(int i=0; i<6; ++i)
    {
        // 当前线程A加锁成功
        // 其余的线程阻塞
    	pthread_mutex_lock(&mutex);
    	....
    	.....
        pthread_mutex_unlock(&mutex);
    }
}

void funcB()
{
    for(int i=0; i<6; ++i)
    {
        // 当前线程A加锁成功
        // 其余的线程阻塞
    	pthread_mutex_lock(&mutex);
        funcA();		// 重复加锁
    	....
    	.....
        pthread_mutex_unlock(&mutex);
    }
}

在程序中有多个共享资源, 因此有很多把锁，随意加锁，导致相互被阻塞

```
场景描述:
  1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B
     - 线程A访问资源X, 加锁A
     - 线程B访问资源Y, 加锁B
  2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞
     - 线程A被锁B阻塞了, 无法打开A锁
     - 线程B被锁A阻塞了, 无法打开B锁
```

在使用多线程编程的时候，如何避免死锁呢？

```
避免多次锁定, 多检查

对共享资源访问完毕之后, 一定要解锁，或者在加锁的使用 trylock

如果程序中有多把锁, 可以控制对锁的访问顺序(顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。

项目程序中可以引入一些专门用于死锁检测的模块
```

4. 读写锁
4.1 读写锁函数

读写锁是互斥锁的升级版, 在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。

读写锁是一把锁，锁的类型为pthread_rwlock_t，有了类型之后就可以创建一把互斥锁了：

pthread_rwlock_t rwlock;

之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。为了方便理解，可以大致认为在这把锁中记录了这些信息：

```
锁的状态: 锁定/打开
锁定的是什么操作: 读操作/写操作，使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。
哪个线程将这把锁锁上了
```

读写锁的使用方式也互斥锁的使用方式是完全相同的：找共享资源, 确定临界区，在临界区的开始位置加锁（读锁/写锁），临界区的结束位置解锁。

因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：

```
使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。
使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。
使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为写锁比读锁的优先级高。
```

如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。

```
Linux提供的读写锁操作函数原型如下，如果函数调用成功返回0，失败返回对应的错误号：
```

#include <pthread.h>
pthread_rwlock_t rwlock;
// 初始化读写锁
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
           const pthread_rwlockattr_t *restrict attr);
// 释放读写锁占用的系统资源
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

```
参数:
    rwlock: 读写锁的地址，传出参数
    attr: 读写锁属性，一般使用默认属性，指定为NULL
```

// 在程序中对读写锁加读锁, 锁定的是读操作
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。

// 这个函数可以有效的避免死锁
// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。

// 在程序中对读写锁加写锁, 锁定的是写操作
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。

// 这个函数可以有效的避免死锁
// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。

// 解锁, 不管锁定了读还是写都可用解锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

4.2 读写锁使用

题目要求：8个线程操作同一个全局变量，3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 全局变量
int number = 0;

// 定义读写锁
pthread_rwlock_t rwlock;

// 写的线程的处理函数
void* writeNum(void* arg)
{
    while(1)
    {
        pthread_rwlock_wrlock(&rwlock);
        int cur = number;
        cur ++;
        number = cur;
        printf("++写操作完毕, number : %d, tid = %ld\n", number, pthread_self());
        pthread_rwlock_unlock(&rwlock);
        // 添加sleep目的是要看到多个线程交替工作
        usleep(rand() % 100);
    }

```
return NULL;
```
}

// 读线程的处理函数
// 多个线程可以如果处理动作相同, 可以使用相同的处理函数
// 每个线程中的栈资源是独享
void* readNum(void* arg)
{
    while(1)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("--全局变量number = %d, tid = %ld\n", number, pthread_self());
        pthread_rwlock_unlock(&rwlock);
        usleep(rand() % 100);
    }
    return NULL;
}

int main()
{
    // 初始化读写锁
    pthread_rwlock_init(&rwlock, NULL);

```
// 3个写线程, 5个读的线程
pthread_t wtid[3];
pthread_t rtid[5];
for(int i=0; i<3; ++i)
{
    pthread_create(&wtid[i], NULL, writeNum, NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_create(&rtid[i], NULL, readNum, NULL);
}

// 释放资源
for(int i=0; i<3; ++i)
{
    pthread_join(wtid[i], NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_join(rtid[i], NULL);
}

// 销毁读写锁
pthread_rwlock_destroy(&rwlock);

return 0;
```
}

5. 条件变量
5.1 条件变量函数

严格意义上来说，条件变量的主要作用不是处理线程同步, 而是进行线程的阻塞。如果在多线程程序中只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：

```
假设有A-Z 26个线程，这26个线程共同访问同一把互斥锁，如果线程A加锁成功，那么其余B-Z线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区
条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。
```

一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为pthread_cond_t，这样就可以定义一个条件变量类型的变量了：

pthread_cond_t cond;

被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。

```
条件变量操作函数函数原型如下：
```

#include <pthread.h>
pthread_cond_t cond;
// 初始化
int pthread_cond_init(pthread_cond_t *restrict cond,
      const pthread_condattr_t *restrict attr);
// 销毁释放资源        
int pthread_cond_destroy(pthread_cond_t *cond);

```
参数:

    cond: 条件变量的地址

    attr: 条件变量属性, 一般使用默认属性, 指定为NULL
```

// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);

通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：

```
在阻塞线程时候，如果线程已经对互斥锁mutex上锁，那么会将这把锁打开，这样做是为了避免死锁
当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个mutex互斥锁锁上，继续向下访问临界区
```

// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示
struct timespec {
	time_t tv_sec;      /* Seconds */
	long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */
};
// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);

这个函数的前两个参数和pthread_cond_wait函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：struct timespec这个结构体中记录的时间是从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。因此赋值方式相对要麻烦一点：

time_t mytim = time(NULL);	// 1970.1.1 0:0:0 到当前的总秒数
struct timespec tmsp;
tmsp.tv_nsec = 0;
tmsp.tv_sec = time(NULL) + 100;	// 线程阻塞100s

// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞
int pthread_cond_signal(pthread_cond_t *cond);
// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞
int pthread_cond_broadcast(pthread_cond_t *cond);

调用上面两个函数中的任意一个，都可以换线被pthread_cond_wait或者pthread_cond_timedwait阻塞的线程，区别就在于pthread_cond_signal是唤醒至少一个被阻塞的线程（总个数不定），pthread_cond_broadcast是唤醒所有被阻塞的线程。
5.2 生产者和消费者

生产者和消费者模型的组成：

```
生产者线程 -> 若干个
    生产商品或者任务放入到任务队列中
    任务队列满了就阻塞, 不满的时候就工作
    通过一个生产者的条件变量控制生产者线程阻塞和非阻塞
消费者线程 -> 若干个
    读任务队列, 将任务或者数据取出
    任务队列中有数据就消费，没有数据就阻塞
    通过一个消费者的条件变量控制消费者线程阻塞和非阻塞
队列 -> 存储任务/数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存
    可以是数组、链表，也可以使用stl容器：queue / stack / list / vector
```

1564644834918

```
场景描述：使用条件变量实现生产者和消费者模型，生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点。
```

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 链表的节点
struct Node
{
    int number;
    struct Node* next;
};

// 定义条件变量, 控制消费者线程
pthread_cond_t cond;
// 互斥锁变量
pthread_mutex_t mutex;
// 指向头结点的指针
struct Node * head = NULL;

// 生产者的回调函数
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 创建一个链表的新节点
        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
        // 节点初始化
        pnew->number = rand() % 1000;
        // 节点的连接, 添加到链表的头部, 新节点就新的头结点
        pnew->next = head;
        // head指针前移
        head = pnew;
        printf("+++producer, number = %d, tid = %ld\n", pnew->number, pthread_self());
        pthread_mutex_unlock(&mutex);

```
    // 生产了任务, 通知消费者消费
    pthread_cond_broadcast(&cond);

    // 生产慢一点
    sleep(rand() % 3);
}
return NULL;
```
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 一直消费, 删除链表中的一个节点
//        if(head == NULL)   // 这样写有bug
        while(head == NULL)
        {
            // 任务队列, 也就是链表中已经没有节点可以消费了
            // 消费者线程需要阻塞
            // 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开
            // 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==> 死锁
            // 这函数会自动将线程拥有的锁解开
            pthread_cond_wait(&cond, &mutex);
            // 当消费者线程解除阻塞之后, 会自动将这把锁锁上
            // 这时候当前这个线程又重新拥有了这把互斥锁
        }
        // 取出链表的头结点, 将其删除
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        free(pnode);
        pthread_mutex_unlock(&mutex);        

```
    sleep(rand() % 3);
}
return NULL;
```
}

int main()
{
    // 初始化条件变量
    pthread_cond_init(&cond, NULL);
    pthread_mutex_init(&mutex, NULL);

```
// 创建5个生产者, 5个消费者
pthread_t ptid[5];
pthread_t ctid[5];
for(int i=0; i<5; ++i)
{
    pthread_create(&ptid[i], NULL, producer, NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_create(&ctid[i], NULL, consumer, NULL);
}

// 释放资源
for(int i=0; i<5; ++i)
{
    // 阻塞等待子线程退出
    pthread_join(ptid[i], NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_join(ctid[i], NULL);
}

// 销毁条件变量
pthread_cond_destroy(&cond);
pthread_mutex_destroy(&mutex);

return 0;
```
}

代码分析

void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 一直消费, 删除链表中的一个节点
        if(head == NULL)   // 这样写有bug
        {
            pthread_cond_wait(&cond, &mutex);
        }
        // 取出链表的头结点, 将其删除
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        free(pnode);
        pthread_mutex_unlock(&mutex);        

```
    sleep(rand() % 3);
}
return NULL;
```
}

/*
为什么在第7行使用if 有bug:
    当任务队列为空, 所有的消费者线程都会被这个函数阻塞 pthread_cond_wait(&cond, &mutex);
    也就是阻塞在代码的第9行
	
```
当生产者生产了1个节点, 调用 pthread_cond_broadcast(&cond); 唤醒了所有阻塞的线程
  - 有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞
  - 加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁
  - 没有加锁成功的线程解除阻塞继续抢这把锁, 另外一个子线程加锁成功
  - 但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点的时候就会出现段错误
解决方案:
  - 需要循环的对链表是否为空进行判断, 需要将if 该成 while
```
*/

6. 信号量
6.1 信号量函数

信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A，B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。

信号量（信号灯）与互斥锁和条件变量的主要不同在于”灯”的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程, 不能完全保证线程安全，如果要保证线程安全, 需要信号量和互斥锁一起使用。

信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为sem_t对应的头文件为<semaphore.h>：

#include <semaphore.h>
sem_t sem;

```
Linux提供的信号量操作函数原型如下：
```

#include <semaphore.h>
// 初始化信号量/信号灯
int sem_init(sem_t *sem, int pshared, unsigned int value);
// 资源释放, 线程销毁之后调用这个函数即可
// 参数 sem 就是 sem_init() 的第一个参数            
int sem_destroy(sem_t *sem);

```
参数:
    sem：信号量变量地址
    pshared：
        0：线程同步
        非0：进程同步
    value：初始化当前信号量拥有的资源数（>=0），如果资源数为0，线程就会被阻塞了。
```

// 参数 sem 就是 sem_init() 的第一个参数  
// 函数被调用sem中的资源就会被消耗1个, 资源数-1
int sem_wait(sem_t *sem);

当线程调用这个函数，并且sem中的资源数>0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，直到sem中的资源数减为0时，资源被耗尽，因此线程也就被阻塞了。

// 参数 sem 就是 sem_init() 的第一个参数  
// 函数被调用sem中的资源就会被消耗1个, 资源数-1
int sem_trywait(sem_t *sem);

当线程调用这个函数，并且sem中的资源数>0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，直到sem中的资源数减为0时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。

// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示
struct timespec {
	time_t tv_sec;      /* Seconds */
	long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */
};
// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。
// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);

该函数的参数abs_timeout和pthread_cond_timedwait的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且sem中的资源数>0，线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，直到sem中的资源数减为0时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。

// 调用该函数给sem中的资源数+1
int sem_post(sem_t *sem);

调用该函数会将sem中的资源数+1，如果有线程在调用sem_wait、sem_trywait、sem_timedwait时因为sem中的资源数为0被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。

// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中
// sval是一个传出参数
int sem_getvalue(sem_t *sem, int *sval);

通过这个函数可以查看sem中现在拥有的资源个数，通过第二个参数sval将数据传出，也就是说第二个参数的作用和返回值是一样的。
6.2 生产者和消费者

由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的，在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。

// 生产者线程 
sem_t psem;
// 消费者线程
sem_t csem;

// 信号量初始化
sem_init(&psem, 0, 5);    // 5个生产者可以同时生产
sem_init(&csem, 0, 0);    // 消费者线程没有资源, 因此不能消费

// 生产者线程
// 在生产之前, 从信号量中取出一个资源
sem_wait(&psem);	
// 生产者商品代码, 有商品了, 放到任务队列
......	 
......
......
// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞
sem_post(&csem);
	
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// 消费者线程
// 消费者需要等待生产, 默认启动之后应该阻塞
sem_wait(&csem);
// 开始消费
......
......
......
// 消费完成, 通过生产者生产，给生产者信号量添加资源
sem_post(&psem);

通过上面的代码可以知道，初始化信号量的时候没有消费者分配资源，消费者线程启动之后由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。
6.3 信号量使用

```
场景描述：使用信号量实现生产者和消费者模型，生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点。
```

6.3.1 总资源数为1

如果生产者和消费者线程使用的信号量对应的总资源数为1，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <semaphore.h>
#include <pthread.h>

// 链表的节点
struct Node
{
    int number;
    struct Node* next;
};

// 生产者线程信号量
sem_t psem;
// 消费者线程信号量
sem_t csem;

// 互斥锁变量
pthread_mutex_t mutex;
// 指向头结点的指针
struct Node * head = NULL;

// 生产者的回调函数
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        // 生产者拿一个信号灯
        sem_wait(&psem);
        // 创建一个链表的新节点
        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
        // 节点初始化
        pnew->number = rand() % 1000;
        // 节点的连接, 添加到链表的头部, 新节点就新的头结点
        pnew->next = head;
        // head指针前移
        head = pnew;
        printf("+++producer, number = %d, tid = %ld\n", pnew->number, pthread_self());

```
    // 通知消费者消费, 给消费者加信号灯
    sem_post(&csem);
```


```
    // 生产慢一点
    sleep(rand() % 3);
}
return NULL;
```
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        sem_wait(&csem);
        // 取出链表的头结点, 将其删除
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        free(pnode);
        // 通知生产者生成, 给生产者加信号灯
        sem_post(&psem);

```
    sleep(rand() % 3);
}
return NULL;
```
}

int main()
{
    // 初始化信号量
    // 生产者和消费者拥有的信号灯的总和为1
    sem_init(&psem, 0, 1);  // 生成者线程一共有1个信号灯
    sem_init(&csem, 0, 0);  // 消费者线程一共有0个信号灯

```
// 创建5个生产者, 5个消费者
pthread_t ptid[5];
pthread_t ctid[5];
for(int i=0; i<5; ++i)
{
    pthread_create(&ptid[i], NULL, producer, NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_create(&ctid[i], NULL, consumer, NULL);
}

// 释放资源
for(int i=0; i<5; ++i)
{
    pthread_join(ptid[i], NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_join(ctid[i], NULL);
}

sem_destroy(&psem);
sem_destroy(&csem);

return 0;
```
}

通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。
6.3.2 总资源数大于1

如果生产者和消费者线程使用的信号量对应的总资源数为大于1，这种场景下出现的情况就比较多了：

```
多个生产者线程同时生产
多个消费者同时消费
生产者线程和消费者线程同时生产和消费
```

以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，处理代码如下：

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <semaphore.h>
#include <pthread.h>

// 链表的节点
struct Node
{
    int number;
    struct Node* next;
};

// 生产者线程信号量
sem_t psem;
// 消费者线程信号量
sem_t csem;

// 互斥锁变量
pthread_mutex_t mutex;
// 指向头结点的指针
struct Node * head = NULL;

// 生产者的回调函数
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        // 生产者拿一个信号灯
        sem_wait(&psem);
        // 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁
        pthread_mutex_lock(&mutex);
        // 创建一个链表的新节点
        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
        // 节点初始化
        pnew->number = rand() % 1000;
        // 节点的连接, 添加到链表的头部, 新节点就新的头结点
        pnew->next = head;
        // head指针前移
        head = pnew;
        printf("+++producer, number = %d, tid = %ld\n", pnew->number, pthread_self());
        pthread_mutex_unlock(&mutex);

```
    // 通知消费者消费
    sem_post(&csem);
    
    // 生产慢一点
    sleep(rand() % 3);
}
return NULL;
```
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        sem_wait(&csem);
        pthread_mutex_lock(&mutex);
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        // 取出链表的头结点, 将其删除
        free(pnode);
        pthread_mutex_unlock(&mutex);
        // 通知生产者生成, 给生产者加信号灯
        sem_post(&psem);

```
    sleep(rand() % 3);
}
return NULL;
```
}

int main()
{
    // 初始化信号量
    sem_init(&psem, 0, 5);  // 生成者线程一共有5个信号灯
    sem_init(&csem, 0, 0);  // 消费者线程一共有0个信号灯
    // 初始化互斥锁
    pthread_mutex_init(&mutex, NULL);

```
// 创建5个生产者, 5个消费者
pthread_t ptid[5];
pthread_t ctid[5];
for(int i=0; i<5; ++i)
{
    pthread_create(&ptid[i], NULL, producer, NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_create(&ctid[i], NULL, consumer, NULL);
}

// 释放资源
for(int i=0; i<5; ++i)
{
    pthread_join(ptid[i], NULL);
}

for(int i=0; i<5; ++i)
{
    pthread_join(ctid[i], NULL);
}

sem_destroy(&psem);
sem_destroy(&csem);
pthread_mutex_destroy(&mutex);

return 0;
```
}

在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：

// 消费者
sem_wait(&csem);
pthread_mutex_lock(&mutex);

// 生产者
sem_wait(&csem);
pthread_mutex_lock(&mutex);

这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁，下面来分析一种死锁的场景：

void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 生产者拿一个信号灯
        sem_wait(&psem);
		......
        ......
        // 通知消费者消费
        sem_post(&csem);
        pthread_mutex_unlock(&mutex);
        
```
    // 生产慢一点
    sleep(rand() % 3);
}
return NULL;
```
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        sem_wait(&csem);
		......
        ......
        // 通知生产者生成, 给生产者加信号灯
        sem_post(&psem);
        pthread_mutex_unlock(&mutex);

```
    sleep(rand() % 3);
}
return NULL;
```
}

int main()
{
    // 初始化信号量
    sem_init(&psem, 0, 5);  // 生成者线程一共有5个信号灯
    sem_init(&csem, 0, 0);  // 消费者线程一共有0个信号灯
	......
	......
    return 0;
}

在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用pthread_mutex_lock(&mutex);对互斥锁加锁成功，然后调用sem_wait(&csem);由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用pthread_mutex_lock(&mutex);，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。








### (7) C++线程同步之互斥锁

进行多线程编程，如果多个线程需要对同一块内存进行操作，比如：==同时读、同时写、同时读写==对于**后两种情况来说**，**如果不做任何的人为干涉就会出现各种各样的错误数据**。这是因为线程在运行的时候需要**先得到CPU时间片**，时间片用完之后需要放弃已获得的CPU资源，就**这样线程频繁地在就绪态和运行态之间切换**，**更复杂一点还可以在就绪态、运行态、挂起态之间切换**，这样就会导致线程的执行顺序并不是有序的，而是随机的混乱的，就如同下图中的这个例子一样，理想很丰满现实却很残酷。

解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，在C++11中一共提供了四种互斥锁：

* ==std::mutex：独占的互斥锁，不能递归使用==
* ==std::timed_mutex：带超时的独占互斥锁，不能递归使用==
* ==std::recursive_mutex：递归互斥锁，不带超时功能==
* ==std::recursive_timed_mutex：带超时的递归互斥锁==

互斥锁在有些资料中也被称之为互斥量，二者是一个东西。

如果对线程同步还一无所知，建议先看一下这篇文章：

[多线程编程导致数据错乱的原因剖析，以及线程同步基本常识](https://subingwen.cn/linux/thread-sync/#1-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5)

#### 1. std::mutex

不论是在C还是C++中，进行线程同步的处理流程基本上是一致的，C++的mutex类提供了相关的API函数：

##### 1.1 成员函数

lock()函数==用于给临界区加锁，并且<u>*只能有一个线程*</u>获得锁的所有权==，它有阻塞线程的作用，函数原型如下：

```
void lock();
```

独占互斥锁对象有两种状态：**锁定和未锁定**。如果互斥锁是打开的，调用lock()函数的线程会得到互斥锁的所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被lock()函数阻塞。当拥有互斥锁所有权的线程将互斥锁解锁，此时被lock()阻塞的线程解除阻塞，抢到互斥锁所有权的线程加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。

除了使用lock()还可以使用try_lock()获取互斥锁的所有权并对互斥锁加锁，函数原型如下：

```
bool try_lock();
```

二者的区别在于try_lock()不会阻塞线程，lock()会阻塞线程：

* 如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回true
* 如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回false

当互斥锁被锁定之后可以通过==unlock()进行解锁==，但是需要注意的是只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。该函数的函数原型如下：

```
void unlock();
```

通过介绍以上三个函数，使用互斥锁进行线程同步的大致思路差不多就能搞清楚了，主要分为以下几步：

1. ==找到多个线程操作的共享资源（全局变量、堆内存、类成员变量等），也可以称之为临界资源==
2. ==找到和共享资源有关的上下文代码，也就是临界区（下图中的黄色代码部分）==
3. ==在临界区的上边调用互斥锁类的lock()方法==
4. ==在临界区的下边调用互斥锁的unlock()方法==

**<u>*线程同步的目的是让多线程按照顺序依次执行临界区代码*，这样做线程对共享资源的访问就从并行访问变为了线性访问，访问效率降低了，但是保证了数据的正确性。</u>**

> ==当线程对互斥锁对象加锁，并且执行完临界区代码之后，一定要使用这个线程对互斥锁解锁，否则最终会造成线程的死锁。死锁之后当前应用程序中的所有线程都会被阻塞，并且阻塞无法解除，应用程序也无法继续运行。==

##### 1.2 线程同步

举个栗子，我们让两个线程共同操作同一个全局变量，二者交替数数，将数值存储到这个全局变量里边并打印出来。

```
#include <iostream>
#include <chrono>
#include <thread>
#include <mutex>
using namespace std;

int g_num = 0;  // 为 g_num_mutex 所保护
mutex g_num_mutex;

void slow_increment(int id)
{
    for (int i = 0; i < 3; ++i) 
    {
        g_num_mutex.lock();
        ++g_num;
        cout << id << " => " << g_num << endl;
        g_num_mutex.unlock();

        this_thread::sleep_for(chrono::seconds(1));

    }

}

int main()
{
    thread t1(slow_increment, 0);
    thread t2(slow_increment, 1);
    t1.join();
    t2.join();
}
```

在上面的示例程序中，两个子线程执行的任务的一样的（其实也可以不一样，不同的任务中也可以对共享资源进行读写操作），在任务函数中把与全局变量相关的代码加了锁，两个线程只能顺序访问这部分代码（如果不进行线程同步打印出的数据是混乱且无序的）。另外需要强调一点：

1. ==在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。==
2. ==互斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。==

#### 2. std::lock_guard

lock_guard是C++11新增的一个模板类，使用这个类，可以==简化互斥锁lock()和unlock()的写法==，同时也更安全。这个模板类的定义和常用的构造函数原型如下：

```
// 类的定义，定义于头文件 <mutex>
template< class Mutex >
class lock_guard;

// 常用构造函数
explicit lock_guard( mutex_type& m );
```

lock_guard在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。==<u>lock_guard使用了RAII技术，就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放</u>==。

使用lock_guard对上面的例子进行修改，代码如下：

```
void slow_increment(int id)
{
    for (int i = 0; i < 3; ++i) 
    {
        // 使用哨兵锁管理互斥锁
        lock_guard<mutex> lock(g_num_mutex);
        ++g_num;
        cout << id << " => " << g_num << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }
}
```

通过修改发现代码被精简了，而且不用担心因为忘记解锁而造成程序的死锁，但是==这种方式也有弊端，在上面的示例程序中整个for循环的体都被当做了临界区，多个线程是线性的执行临界区代码的==，因此**临界区越大程序效率越低**，还是需要根据实际情况选择最优的解决方案。

#### 3. std::recursive_mutex

==递归互斥锁std::recursive_mutex允许同一线程多次获得互斥锁==，可以用来解决同一线程需要多次获取互斥量时死锁的问题，在下面的例子中使用独占非递归互斥量会发生死锁：

```
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

struct Calculate
{
    Calculate() : m_i(6) {}

    void mul(int x)
    {
        lock_guard<mutex> locker(m_mutex);
        m_i *= x;
    }

    void div(int x)
    {
        lock_guard<mutex> locker(m_mutex);
        m_i /= x;
    }

    void both(int x, int y)
    {
        lock_guard<mutex> locker(m_mutex);
        mul(x);
        div(y);
    }

    int m_i;
    mutex m_mutex;

};

int main()
{
    Calculate cal;
    cal.both(6, 3);
    return 0;
}
```

上面的程序中**执行了cal.both(6, 3);调用之后，程序就会发生死锁**，在<u>both()中已经对互斥锁加锁</u>了，继续调用mult()函数，==已经得到互斥锁所有权的线程再次获取这个互斥锁的所有权就会造成死锁==（在C++中程序会异常退出，使用C库函数会导致这个互斥锁永远无法被解锁，最终阻塞所有的线程）。要解决这个死锁的问题，一个简单的办法就是使用递归互斥锁std::recursive_mutex，它允许一个线程多次获得互斥锁的所有权。修改之后的代码如下：

```
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

struct Calculate
{
    Calculate() : m_i(6) {}

    void mul(int x)
    {
        lock_guard<recursive_mutex> locker(m_mutex);
        m_i *= x;
    }

    void div(int x)
    {
        lock_guard<recursive_mutex> locker(m_mutex);
        m_i /= x;
    }

    void both(int x, int y)
    {
        lock_guard<recursive_mutex> locker(m_mutex);
        mul(x);
        div(y);
    }

    int m_i;
    recursive_mutex m_mutex;

};

int main()
{
    Calculate cal;
    cal.both(6, 3);
    cout << "cal.m_i = " << cal.m_i << endl;
    return 0;
}
```

虽然递归互斥锁可以解决同一个互斥锁频繁获取互斥锁资源的问题，但是还是建议少用，主要原因如下：

1. ==使用递归互斥锁的场景往往都是可以简化的，使用递归互斥锁很容易放纵复杂逻辑的产生，从而导致bug的产生==
2. ==递归互斥锁比非递归互斥锁效率要低一些。==
3. ==递归互斥锁虽然允许同一个线程多次获得同一个互斥锁的所有权，但最大次数并未具体说明，一旦超过一定的次数，就会抛出std::system错误。==

#### 4. std::timed_mutex

==std::timed_mutex是超时独占互斥锁==，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。

```
std::timed_mutex比std::_mutex多了两个成员函数：try_lock_for()和try_lock_until()：

void lock();
bool try_lock();
void unlock();

// std::timed_mutex比std::_mutex多出的两个成员函数
template <class Rep, class Period>
  bool try_lock_for (const chrono::duration<Rep,Period>& rel_time);

template <class Clock, class Duration>
  bool try_lock_until (const chrono::time_point<Clock,Duration>& abs_time);
```



* ==try_lock_for函数==是当**线程获取不到互斥锁资源**的时候，让线程<u>阻塞一定的时间长度</u>
* ==try_lock_until函数==是当**线程获取不到互斥锁资源**的时候，让线程<u>阻塞到某一个指定的时间点</u>
* 关于两个函数的返回值：当得到互斥锁的所有权之后，函数会马上解除阻塞，返回true，如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回false

下面的示例程序中为大家演示了std::timed_mutex的使用：

```c++
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

timed_mutex g_mutex;

void work()
{
    chrono::seconds timeout(1);
    while (true)
    {
        // 通过阻塞一定的时长来争取得到互斥锁所有权
        if (g_mutex.try_lock_for(timeout))
        {
            cout << "当前线程ID: " << this_thread::get_id() 
                << ", 得到互斥锁所有权..." << endl;
            // 模拟处理任务用了一定的时长
            this_thread::sleep_for(chrono::seconds(10));
            // 互斥锁解锁
            g_mutex.unlock();
            break;
        }
        else
        {
            cout << "当前线程ID: " << this_thread::get_id() 
                << ", 没有得到互斥锁所有权..." << endl;
            // 模拟处理其他任务用了一定的时长
            this_thread::sleep_for(chrono::milliseconds(50));
        }
    }
}

int main()
{
    thread t1(work);
    thread t2(work);

    t1.join();
    t2.join();

    return 0;

}
/*
示例代码输出的结果：

当前线程ID: 125776, 得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 没有得到互斥锁所有权...
当前线程ID: 112324, 得到互斥锁所有权...
```

在上面的例子中，通过一个**while循环**不停的去获取超时互斥锁的所有权，如果得不到就**阻塞1秒钟**，**1秒之后如果还是得不到阻塞50毫秒**，然后再次继续尝试，直到获得互斥锁的所有权，跳出循环体。

关于递归超时互斥锁==std::recursive_timed_mutex==的使用方式和std::timed_mutex是一样的，只不过它==可以允许一个线程多次获得互斥锁所有权==，而==std::timed_mutex只允许线程获取一次互斥锁所有权==。另外，**递归超时互斥锁std::recursive_timed_mutex也拥有和std::recursive_mutex一样的弊端**，不建议频繁使用。

### (8) C++线程同步之条件变量

==条件变量是C++11提供的另外一种用于等待的<u>同步机制</u>==，它能***阻塞一个或多个线程***，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来使用，C++11提供了两种条件变量：

* ==condition_variable==：需要配合**std::unique_lock<std::mutex>**进行wait操作，也就是阻塞线程的操作。
* ==condition_variable_any==：可以和任意带有lock()、unlock()语义的mutex搭配使用，也就是说有四种：
  * std::mutex：独占的非递归互斥锁
  * std::timed_mutex：带超时的独占非递归互斥锁
  * std::recursive_mutex：不带超时功能的递归互斥锁
  * std::recursive_timed_mutex：带超时的递归互斥锁

条件变量通常用于生产者和消费者模型，大致使用过程如下：

1. 拥有条件变量的线程获取互斥量

2. 循环检查某个条件，如果条件不满足阻塞当前线程，否则线程继续向下执行
       * 产品的数量达到上限，生产者阻塞，否则生产者一直生产。。。

       * 产品的数量为零，消费者阻塞，否则消费者一直消费。。。

3. 条件满足之后，可以==调用notify_one()或者notify_all()唤醒==一个或者所有被阻塞的线程
       * 由消费者唤醒被阻塞的生产者，生产者解除阻塞继续生产。。。

       * 由生产者唤醒被阻塞的消费者，消费者解除阻塞继续消费。。。

#### 1. condition_variable

##### 1.1 成员函数

condition_variable的成员函数主要分为两部分：==线程等待（阻塞）函数 和线程通知（唤醒）函数==，这些函数被定义于头文件 <condition_variable>。

* 等待函数

​	调用wait()函数的线程会被阻塞

```
// ①
void wait (unique_lock<mutex>& lck);
// ②
template <class Predicate>
void wait (unique_lock<mutex>& lck, Predicate pred);
```

> 函数①：调用该函数的线程直接被阻塞
>
> 函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数
>     ==该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数
>     表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行==
>
> 独占的互斥锁对象不能直接传递给wait()函数，需要通过模板类unique_lock进行二次处理，通过得到的对象仍然可以对独占的互斥锁对象做如下操作，使用起来更灵活。



| 公共成员函数   | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| lock           | 锁定关联的互斥锁                                             |
| try_lock       | 尝试锁定关联的互斥锁，若无法锁定，函数直接返回               |
| try_lock_for   | 试图锁定关联的可定时锁定互斥锁，若互斥锁在给定时长中仍不能被锁定，函数返回 |
| try_lock_until | 试图锁定关联的可定时锁定互斥锁，若互斥锁在给定的时间点后仍不能被锁定，函数返回 |
| unlock         | 将互斥锁解锁                                                 |

* ==如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行==（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。



wait_for()函数和wait()的功能是一样的，只不过==多了一个阻塞时长==，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。

```
template <class Rep, class Period>
cv_status wait_for (unique_lock<mutex>& lck,
                    const chrono::duration<Rep,Period>& rel_time);
	
template <class Rep, class Period, class Predicate>
bool wait_for(unique_lock<mutex>& lck,
               const chrono::duration<Rep,Period>& rel_time, Predicate pred);
```

wait_until()函数和wait_for()的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当==到达指定的时间点==之后，线程就会自动解除阻塞，继续向下执行。

```
template <class Clock, class Duration>
cv_status wait_until (unique_lock<mutex>& lck,
                      const chrono::time_point<Clock,Duration>& abs_time);

template <class Clock, class Duration, class Predicate>
bool wait_until (unique_lock<mutex>& lck,
                 const chrono::time_point<Clock,Duration>& abs_time, Predicate pred);
```


通知函数

```
void notify_one() noexcept;
void notify_all() noexcept;
```

* ==notify_one()：唤醒一个被当前条件变量阻塞的线程==
* ==notify_all()：唤醒全部被当前条件变量阻塞的线程==

##### 1.2 生产者和消费者模型

我们可以使用条件变量来实现一个同步队列，这个队列作为生产者线程和消费者线程的共享资源，示例代码如下：


​    
```
#include <iostream>
#include <thread>
#include <mutex>
#include <list>
#include <functional>
#include <condition_variable>
using namespace std;

class SyncQueue
{
public:
    SyncQueue(int maxSize) : m_maxSize(maxSize) {}
    
    void put(const int& x)
    {
        unique_lock<mutex> locker(m_mutex);
        // 判断任务队列是不是已经满了
        while (m_queue.size() == m_maxSize)
        {
            cout << "任务队列已满, 请耐心等待..." << endl;
            // 阻塞线程
            m_notFull.wait(locker);
        }
        // 将任务放入到任务队列中
        m_queue.push_back(x);
        cout << x << " 被生产" << endl; 
        // 通知消费者去消费
        m_notEmpty.notify_one();
    }

    int take()
    {
        unique_lock<mutex> locker(m_mutex);
        while (m_queue.empty())
        {
            cout << "任务队列已空，请耐心等待。。。" << endl;
            m_notEmpty.wait(locker);
        }
        // 从任务队列中取出任务(消费)
        int x = m_queue.front();
        m_queue.pop_front();
        // 通知生产者去生产
        m_notFull.notify_one();
        cout << x << " 被消费" << endl;
        return x;
    }

    bool empty()
    {
        lock_guard<mutex> locker(m_mutex);
        return m_queue.empty();
    }

    bool full()
    {
        lock_guard<mutex> locker(m_mutex);
        return m_queue.size() == m_maxSize;
    }

    int size()
    {
        lock_guard<mutex> locker(m_mutex);
        return m_queue.size();
    }

private:
    list<int> m_queue;     // 存储队列数据
    mutex m_mutex;         // 互斥锁
    condition_variable m_notEmpty;   // 不为空的条件变量
    condition_variable m_notFull;    // 没有满的条件变量
    int m_maxSize;         // 任务队列的最大任务个数
};

int main()
{
    SyncQueue taskQ(50);
    auto produce = bind(&SyncQueue::put, &taskQ, placeholders::_1);
    auto consume = bind(&SyncQueue::take, &taskQ);
    thread t1[3];
    thread t2[3];
    for (int i = 0; i < 3; ++i)
    {
        t1[i] = thread(produce, i+100);
        t2[i] = thread(consume);
    }

    for (int i = 0; i < 3; ++i)
    {
        t1[i].join();
        t2[i].join();
    }

    return 0;
}
```



条件变量**condition_variable**类的**wait()**还有一个重载的方法，**可以接受一个条件，这个条件也可以是一个返回值为布尔类型的函数，条件变量会先检查判断这个条件是否满足，如果满足条件（布尔值为true）**，**则当前线程重新获得互斥锁的所有权，结束阻塞，继续向下执行；如果不满足条件（布尔值为false）**，<u>当前线程会释放互斥锁（解锁）同时被阻塞，等待被唤醒。</u>

上面示例程序中的put()、take()函数可以做如下修改：

put()函数


```
void put(const int& x)
{
    unique_lock<mutex> locker(m_mutex);
    // 根据条件阻塞线程
    m_notFull.wait(locker, [this]() {
        return m_queue.size() != m_maxSize;
    });
    // 将任务放入到任务队列中
    m_queue.push_back(x);
    cout << x << " 被生产" << endl;
    // 通知消费者去消费
    m_notEmpty.notify_one();
}
```



take()函数

```
int take()
{
    unique_lock<mutex> locker(m_mutex);
    m_notEmpty.wait(locker, [this]() {
        return !m_queue.empty();
    });
    // 从任务队列中取出任务(消费)
    int x = m_queue.front();
    m_queue.pop_front();
    // 通知生产者去生产
    m_notFull.notify_one();
    cout << x << " 被消费" << endl;
    return x;
}
```

**修改之后可以发现，程序变得更加精简了，而且执行效率更高了**，因为在这两个函数中的while循环被删掉了，但是最终的效果是一样的，==推荐使用这种方式的wait()进行线程的阻塞。==

#### 2. condition_variable_any

##### 2.1 成员函数

condition_variable_any的成员函数也是分为两部分：==线程等待（阻塞）函数 和线程通知（唤醒）函数==，这些函数被定义于头文件 <condition_variable>。

等待函数

```
// ①
template <class Lock> void wait (Lock& lck);
// ②
template <class Lock, class Predicate>
void wait (Lock& lck, Predicate pred);
```



> * 函数①：调用该函数的线程直接被阻塞
> * 函数②：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数
>   * ​    ==该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数==
>   * ​    ==表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行==
> * 可以直接传递给wait()函数的互斥锁类型有四种，分别是：
>   * ​    ==std::mutex、std::timed_mutex、std::recursive_mutex、std::recursive_timed_mutex==
> * ==如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行==（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。

**wait_for()函数和wait()的功能是一样的**，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。

```
template <class Lock, class Rep, class Period>
cv_status wait_for (Lock& lck, const chrono::duration<Rep,Period>& rel_time);
	
template <class Lock, class Rep, class Period, class Predicate>
bool wait_for (Lock& lck, const chrono::duration<Rep,Period>& rel_time, Predicate pred);
```

**wait_until()函数和wait_for()的功能是一样的**，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。

```
template <class Lock, class Clock, class Duration>
cv_status wait_until (Lock& lck, const chrono::time_point<Clock,Duration>& abs_time);

template <class Lock, class Clock, class Duration, class Predicate>
bool wait_until (Lock& lck, 
                 const chrono::time_point<Clock,Duration>& abs_time, 
                 Predicate pred);
```


通知函数

```
void notify_one() noexcept;
void notify_all() noexcept;
```

* notify_one()：唤醒一个被当前条件变量阻塞的线程
* notify_all()：唤醒全部被当前条件变量阻塞的线程

##### 2.2 生产者和消费者模型

使用条件变量condition_variable_any同样可以实现上面的生产者和消费者的例子，代码只有个别细节上有所不同：

```
#include <iostream>
#include <thread>
#include <mutex>
#include <list>
#include <functional>
#include <condition_variable>
using namespace std;

class SyncQueue
{
public:
    SyncQueue(int maxSize) : m_maxSize(maxSize) {}

    void put(const int& x)
    {
        lock_guard<mutex> locker(m_mutex);
        // 根据条件阻塞线程
        m_notFull.wait(m_mutex, [this]() {
            return m_queue.size() != m_maxSize;
        });
        // 将任务放入到任务队列中
        m_queue.push_back(x);
        cout << x << " 被生产" << endl;
        // 通知消费者去消费
        m_notEmpty.notify_one();
    }

    int take()
    {
        lock_guard<mutex> locker(m_mutex);
        m_notEmpty.wait(m_mutex, [this]() {
            return !m_queue.empty();
        });
        // 从任务队列中取出任务(消费)
        int x = m_queue.front();
        m_queue.pop_front();
        // 通知生产者去生产
        m_notFull.notify_one();
        cout << x << " 被消费" << endl;
        return x;
    }

    bool empty()
    {
        lock_guard<mutex> locker(m_mutex);
        return m_queue.empty();
    }

    bool full()
    {
        lock_guard<mutex> locker(m_mutex);
        return m_queue.size() == m_maxSize;
    }

    int size()
    {
        lock_guard<mutex> locker(m_mutex);
        return m_queue.size();
    }

private:
    list<int> m_queue;     // 存储队列数据
    mutex m_mutex;         // 互斥锁
    condition_variable_any m_notEmpty;   // 不为空的条件变量
    condition_variable_any m_notFull;    // 没有满的条件变量
    int m_maxSize;         // 任务队列的最大任务个数
};

int main()
{
    SyncQueue taskQ(50);
    auto produce = bind(&SyncQueue::put, &taskQ, placeholders::_1);
    auto consume = bind(&SyncQueue::take, &taskQ);
    thread t1[3];
    thread t2[3];
    for (int i = 0; i < 3; ++i)
    {
        t1[i] = thread(produce, i + 100);
        t2[i] = thread(consume);
    }

    for (int i = 0; i < 3; ++i)
    {
        t1[i].join();
        t2[i].join();
    }

    return 0;
}
```



==总结：以上介绍的两种条件变量各自有各自的特点，condition_variable 配合 unique_lock 使用更灵活一些，可以在在任何时候自由地释放互斥锁，而condition_variable_any 如果和lock_guard 一起使用必须要等到其生命周期结束才能将互斥锁释放。但是，condition_variable_any 可以和多种互斥锁配合使用，应用场景也更广，而 condition_variable 只能和独占的非递归互斥锁（mutex）配合使用，有一定的局限性==

### (9) c++线程同步之原子变量 atomic

​	C++11提供了一个原子类型==std::atomic<T>==，通过这个原子类型管理的内部变量就可以称之为原子变量，我们可以给==原子类型指定bool、char、int、long、指针等类型作为模板参数（不支持浮点类型和复合类型）==。

​	原子指的是一系列不可被CPU上下文交换的机器指令，这些指令组合在一起就形成了原子操作。在多核CPU下，当某个CPU核心开始运行原子操作时，会先暂停其它CPU内核对内存的操作，以保证原子操作不会被其它CPU内核所干扰。

​	由于原子操作是通过指令提供的支持，因此它的性能相比锁和消息传递会好很多。相比较于锁而言，原子类型不需要开发者处理加锁和释放锁的问题，同时支持修改，读取等操作，还具备较高的并发性能，几乎所有的语言都支持原子类型。

​	可以看出原子类型是无锁类型，但是无锁不代表无需等待，因为原子类型内部使用了CAS循环，当大量的冲突发生时，该等待还是得等待！但是总归比锁要好。

​	C++11内置了整形的原子变量，这样就可以更方便的使用原子变量了。在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁。因为对原子变量进行的操作只能是一个==原子操作（atomic operation），原子操作指的是不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何的上下文切换==。多线程同时访问共享资源造成数据混乱的原因就是因为CPU的上下文切换导致的，使用原子变量解决了这个问题，因此互斥锁的使用也就不再需要了。

> CAS全称是Compare and swap, 它通过一条指令读取指定的内存地址，然后判断其中的值是否等于给定的前置值，如果相等，则将其修改为新的值

#### 1. atomic 类成员

##### 类定义

```
// 定义于头文件 <atomic>
template< class T >
struct atomic;
```

通过定义可得知：在使用这个模板类的时候，一定要指定模板类型。
构造函数



```
// ①
atomic() noexcept = default;
// ②
constexpr atomic( T desired ) noexcept;
// ③
atomic( const atomic& ) = delete;
```

* 构造函数①：默认无参构造函数。
* 构造函数②：使用 desired 初始化原子变量的值。
* 构造函数③：使用=delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝

##### 公共成员函数

原子类型在类内部重载了=操作符，并且不允许在类的外部使用 =进行对象的拷贝。

```
T operator=( T desired ) noexcept;
T operator=( T desired ) volatile noexcept;

atomic& operator=( const atomic& ) = delete;
atomic& operator=( const atomic& ) volatile = delete;
```

原子地以 desired 替换当前值。按照 order 的值影响内存。

```
void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept;
void store( T desired, std::memory_order order = std::memory_order_seq_cst ) volatile noexcept;
```


* desired：存储到原子变量中的值
* order：强制的内存顺序

原子地加载并返回原子变量的当前值。按照 order 的值影响内存。直接访问原子对象也可以得到原子变量的当前值。

```
T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;
T load( std::memory_order order = std::memory_order_seq_cst ) const volatile noexcept;
```

##### 特化成员函数

复合赋值运算符重载，主要包含以下形式：

| 模板类型T为整形 | T operator+= (T val) volatile noexcept; <br>T operator+= (T val) noexcept; <br>T operator-= (T val) volatile noexcept;<br/>T operator-= (T val) noexcept;<br/>T operator&= (T val) volatile noexcept;<br/>T operator&= (T val) noexcept;<br/>T operator\|= (T val) volatile noexcept;<br>T operator\|= (T val) noexcept;<br>T operator^= (T val) volatile noexcept;<br/>T operator^= (T val) noexcept; |
| --------------- | ------------------------------------------------------------ |
| 模板类型T为整形 | T operator+= (ptrdiff_t val) volatile noexcept;<br/><br/>T operator+= (ptrdiff_t val) noexcept;<br/><br/>T operator-= (ptrdiff_t val) volatile noexcept;<br/><br/>T operator-= (ptrdiff_t val) noexcept; <br/> |

以上各个 operator 都会有对应的 fetch_* 操作，详细见下表：

| 操作符 | 操作符重载函数      | 等级的成员函数    | 整形 | 指针 | 其他 |
| ------ | ------------------- | ----------------- | ---- | ---- | ---- |
| +      | atomic::operator+=  | atomic::fetch_add | 是   | 是   | 否   |
| -      | atomic::operator-=  | atomic::fetch_sub | 是   | 是   | 否   |
| &      | atomic::operator&=  | atomic::fetch_and | 是   | 否   | 否   |
| \|     | atomic::operator\|= | =                 |      |      | 否   |
| ^      | atomic::operator^=  | atomic::fetch_xor | 是   | 否   | 否   |

##### 内存顺序约束

通过上面的 API 函数我们可以看出，在调用 atomic类提供的 API 函数的时候，需要指定原子顺序，在C++11给我们提供的 API 中使用枚举用作执行原子操作的函数的实参，以指定如何同步不同线程上的其他操作。

```
定义如下:

typedef enum memory_order {
    memory_order_relaxed,   // relaxed
    memory_order_consume,   // consume
    memory_order_acquire,   // acquire
    memory_order_release,   // release
    memory_order_acq_rel,   // acquire/release
    memory_order_seq_cst    // sequentially consistent
} memory_order;
```



> * memory_order_relaxed， 这是最宽松的规则，它对编译器和CPU不做任何限制，可以乱序
>
> * memory_order_release 释放，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面
>
> * memory_order_acquire 获取, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和Release在不同线程中联合使用
>
> * memory_order_consume：改进版的memory_order_acquire ，开销更小
>
> * memory_order_acq_rel，它是Acquire 和 Release 的结合，同时拥有它们俩提供的保证。比如你要对一个 atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序
>
> * memory_order_seq_cst 顺序一致性， memory_order_seq_cst 就像是
>
>   memory_order_acq_rel的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到memory_order_seq_cst 的原子操作，线程中该memory_order_seq_cst 操作前的数据操作绝对不会被重新排在该memory_order_seq_cst 操作之后，且该memory_order_seq_cst 操作后的数据操作也绝对不会被重新排在memory_order_seq_cst 操作前。

##### C++20新增成员

![image-20240411152242940](assets\image-20240411152242940.png)

#### 2. 原子变量的使用

假设我们要制作一个多线程交替数数的计数器，我们使用互斥锁和原子变量的方式分别进行实现，对比一下二者的差异：

##### 2.1 互斥锁版本

```
#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>
#include <functional>
using namespace std;

struct Counter
{
    void increment()
    {
        for (int i = 0; i < 10; ++i)
        {
            lock_guard<mutex> locker(m_mutex);
            m_value++;
            cout << "increment number: " << m_value 
                << ", theadID: " << this_thread::get_id() << endl;
            this_thread::sleep_for(chrono::milliseconds(100));
        }
    }

    void decrement()
    {
        for (int i = 0; i < 10; ++i)
        {
            lock_guard<mutex> locker(m_mutex);
            m_value--;
            cout << "decrement number: " << m_value 
                << ", theadID: " << this_thread::get_id() << endl;
            this_thread::sleep_for(chrono::milliseconds(100));
        }
    }

    int m_value = 0;
    mutex m_mutex;
};

int main()
{
    Counter c;
    auto increment = bind(&Counter::increment, &c);
    auto decrement = bind(&Counter::decrement, &c);
    thread t1(increment);
    thread t2(decrement);

    t1.join();
    t2.join();

    return 0;
}
```



##### 2.2 原子变量版本

```
#include <iostream>
#include <thread>
#include <atomic>
#include <functional>
using namespace std;

struct Counter
{
    void increment()
    {
        for (int i = 0; i < 10; ++i)
        {
            m_value++;
            cout << "increment number: " << m_value
                << ", theadID: " << this_thread::get_id() << endl;
            this_thread::sleep_for(chrono::milliseconds(500));
        }
    }

    void decrement()
    {
        for (int i = 0; i < 10; ++i)
        {
            m_value--;
            cout << "decrement number: " << m_value
                << ", theadID: " << this_thread::get_id() << endl;
            this_thread::sleep_for(chrono::milliseconds(500));
        }
    }
    // atomic<int> == atomic_int
    atomic_int m_value = 0;
};

int main()
{
    Counter c;
    auto increment = bind(&Counter::increment, &c);
    auto decrement = bind(&Counter::decrement, &c);
    thread t1(increment);
    thread t2(decrement);

    t1.join();
    t2.join();

    return 0;
}
```

通过代码的对比可以看出，使用了原子变量之后，就不需要再定义互斥量了，在使用上更加简便，并且这两种方式都能保证在多线程操作过程中数据的正确性，不会出现数据的混乱。

原子类型atomic<T> 可以封装原始数据最终得到一个原子变量对象，操作原子对象能够得到和操作原始数据一样的效果，当然也可以通过store()和load()来读写原子对象内部的原始数据。

### (10) 多线程异步操作

#### 1. std::future

C++11中增加的线程类，使得我们能够非常方便的创建和使用线程，但有时会有些不方便，比如需要获取线程返回的结果，就不能通过join()得到结果，只能通过一些额外手段获得，比如：定义一个全局变量，在子线程中赋值，在主线程中读这个变量的值，整个过程比较繁琐。C++提供的线程库中提供了一些类用于访问异步操作的结果。

那么，什么叫做异步呢？

![image-20240411152442439](assets\image-20240411152442439.png)

我们去星巴克买咖啡，因为都是现磨的，所以需要等待，但是我们付完账后不会站在柜台前死等，而是去找个座位坐下来玩玩手机打发一下时间，当店员把咖啡磨好之后，就会通知我们过去取，这就叫做异步。

* 顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客去做别的事情了，有两条时间线（异步）
* 顾客（主线程）发起一个任务（子线程磨咖啡），磨咖啡的过程中顾客没去做别的事情而是死等，这时就只有一条时间线（同步），此时效率相对较低。

因此多线程程序中的任务大都是异步的，主线程和子线程分别执行不同的任务，如果想要在主线中得到某个子线程任务函数返回的结果可以使用==C++11提供的std:future类==，这个类需要和其他类或函数搭配使用，先来介绍一下这个类的API函数：

##### 类的定义

通过类的定义可以得知，future是一个模板类，也就是这个类可以存储任意指定类型的数据。



```
// 定义于头文件 <future>
template< class T > class future;
template< class T > class future<T&>;
template<>          class future<void>;
```

构造函数

```
// ①
future() noexcept;
// ②
future( future&& other ) noexcept;
// ③
future( const future& other ) = delete;
```



> 构造函数①：默认无参构造函数
> 构造函数②：移动构造函数，转移资源的所有权
> 构造函数③：使用=delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝

##### 常用成员函数（public)

一般情况下使用=进行赋值操作就进行对象的拷贝，但是future对象不可用复制，因此会根据实际情况进行处理：

* 如果other是右值，那么转移资源的所有权
* 如果other是非右值，不允许进行对象之间的拷贝（该函数被显示删除禁止使用）

```
future& operator=( future&& other ) noexcept;
future& operator=( const future& other ) = delete;
```

取出future对象内部保存的数据，其中void get()是为future<void>准备的，此时对象内部类型就是void，该函数是一个阻塞函数，当子线程的数据就绪后解除阻塞就能得到传出的数值了。

```
T get();
T& get();
void get();
```

因为future对象内部存储的是异步线程任务执行完毕后的结果，是在调用之后的将来得到的，因此可以通过调用wait()方法，阻塞当前线程，等待这个子线程的任务执行完毕，任务执行完毕当前线程的阻塞也就解除了。

```
void wait() const;
```

如果当前线程wait()方法就会死等，直到子线程任务执行完毕将返回值写入到future对象中，调用wait_for()只会让线程阻塞一定的时长，但是这样并不能保证对应的那个子线程中的任务已经执行完毕了。

wait_until()和wait_for()函数功能是差不多，前者是阻塞到某一指定的时间点，后者是阻塞一定的时长。

```
template< class Rep, class Period >
std::future_status wait_for( const std::chrono::duration<Rep,Period>& timeout_duration ) const;

template< class Clock, class Duration >
std::future_status wait_until( const std::chrono::time_point<Clock,Duration>& timeout_time ) const;
```

当wait_until()和wait_for()函数返回之后，并不能确定子线程当前的状态，因此我们需要判断函数的返回值，这样就能知道子线程当前的状态了：

常量 	                                                     解释
future_status::deferred 	子线程中的任务函仍未启动
future_status::ready 		  子线程中的任务已经执行完毕，结果已就绪
future_status::timeout 	  子线程中的任务正在执行中，指定等待时长已用完

#### 2. std::promise

std::promise是一个协助线程赋值的类，它能够将数据和future对象绑定起来，为获取线程函数中的某个值提供便利。

##### 2.1 类成员函数

###### 类定义

通过std::promise类的定义可以得知，这也是一个模板类，我们要在线程中传递什么类型的数据，模板参数就指定为什么类型。

```
// 定义于头文件 <future>
template< class R > class promise;
template< class R > class promise<R&>;
template<>          class promise<void>;
```



###### 构造函数

```
// ①
promise();
// ②
promise( promise&& other ) noexcept;
// ③
promise( const promise& other ) = delete;
```



> 构造函数①：默认构造函数，得到一个空对象
> 构造函数②：移动构造函数
> 构造函数③：使用=delete显示删除拷贝构造函数, 不允许进行对象之间的拷贝

###### 公共成员函数

在std::promise类内部管理着一个future类对象，调用get_future()就可以得到这个future对象了

```
std::future<T> get_future();
```

存储要传出的 value 值，并立即让状态就绪，这样数据被传出其它线程就可以得到这个数据了。重载的第四个函数是为promise<void>类型的对象准备的。

```
void set_value( const R& value );
void set_value( R&& value );
void set_value( R& value );
void set_value();
```

存储要传出的 value 值，但是不立即令状态就绪。在当前线程退出时，子线程资源被销毁，再令状态就绪。

void set_value_at_thread_exit( const R& value );
void set_value_at_thread_exit( R&& value );
void set_value_at_thread_exit( R& value );
void set_value_at_thread_exit();

##### 2.2 promise的使用

通过promise传递数据的过程一共分为5步：

1. 在主线程中创建std::promise对象
2. 将这个std::promise对象通过引用的方式传递给子线程的任务函数
3. 在子线程任务函数中给std::promise对象赋值
4. 在主线程中通过std::promise对象取出绑定的future实例对象
5. 通过得到的future对象取出子线程任务函数中返回的值。

子线程任务函数执行==期间==，让状态就绪

```
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    promise<int> pr;
    thread t1([](promise<int> &p) {
        p.set_value(100);
        this_thread::sleep_for(chrono::seconds(3));
        cout << "睡醒了...." << endl;
    }, ref(pr));

    future<int> f = pr.get_future();
    int value = f.get();
    cout << "value: " << value << endl;

    t1.join();
    return 0;
}
/*
示例程序输出的结果：

value: 100
睡醒了....
```



示例程序的中子线程的任务函数指定的是一个匿名函数，在这个匿名的任务函数执行期间通过p.set_value(100);传出了数据并且激活了状态，数据就绪后，**外部主线程中的int value = f.get();解除阻塞**，并将得到的数据打印出来，5秒钟之后子线程休眠结束，匿名的任务函数执行完毕。

子线程任务函数执行==结束==，让状态就绪

```
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    promise<int> pr;
    thread t1([](promise<int> &p) {
        p.set_value_at_thread_exit(100);
        this_thread::sleep_for(chrono::seconds(3));
        cout << "睡醒了...." << endl;
    }, ref(pr));

    future<int> f = pr.get_future();
    int value = f.get();
    cout << "value: " << value << endl;

    t1.join();
    return 0;
}
/*
示例程序输出的结果：

睡醒了....
value: 100
```


在示例程序中，子线程的这个匿名的任务函数中通过==p.set_value_at_thread_exit(100);==在执行完毕并退出之后才会传出数据并激活状态，数据就绪后，==外部主线程中的int value = f.get();解除阻塞，==并将得到的数据打印出来，因此子线程在休眠5秒钟之后主线程中才能得到传出的数据。

另外，在这两个实例程序中有一个知识点需要强调，在外部主线程中创建的promise对象必须要通过引用的方式传递到子线程的任务函数中，==在实例化子线程对象的时候，如果任务函数的参数是引用类型，那么实参一定要放到std::ref()函数中，表示要传递这个实参的引用到任务函数中。==
#### 3. std::packaged_task

std::packaged_task类包装了一个可调用对象包装器类对象（可调用对象包装器包装的是可调用对象，可调用对象都可以作为函数来使用），恶补一下可调用对象和可调用对象包装器

这个类可以将内部包装的函数和future类绑定到一起，以便进行后续的异步调用，它和std::promise有点类似，std::promise内部保存一个共享状态的值，而std::packaged_task保存的是一个函数。

##### 3.1 类成员函数

###### 类的定义

通过类的定义可以看到这也是一个模板类，模板类型和要在线程中传出的数据类型是一致的。

```
// 定义于头文件 <future>
template< class > class packaged_task;
template< class R, class ...Args >
class packaged_task<R(Args...)>;
```

###### 构造函数



```
// ①
packaged_task() noexcept;
// ②
template <class F>
explicit packaged_task( F&& f );
// ③
packaged_task( const packaged_task& ) = delete;
// ④
packaged_task( packaged_task&& rhs ) noexcept;
```



> 构造函数①：无参构造，构造一个无任务的空对象
> 构造函数②：通过一个可调用对象，构造一个任务对象
> 构造函数③：显示删除，不允许通过拷贝构造函数进行对象的拷贝
> 构造函数④：移动构造函数

###### 常用公共成员函数

通过调用任务对象内部的get_future()方法就可以得到一个future对象，基于这个对象就可以得到传出的数据了。

```
std::future<R> get_future();
```

##### 3.2 packaged_task的使用

packaged_task其实就是对子线程要执行的任务函数进行了包装，和可调用对象包装器的使用方法相同，包装完毕之后直接将包装得到的任务对象传递给线程对象就可以了。

```
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    packaged_task<int(int)> task([](int x) {
        return x += 100;
    });

    thread t1(ref(task), 100);

    future<int> f = task.get_future();
    int value = f.get();
    cout << "value: " << value << endl;

    t1.join();
    return 0;

}
```

在上面的示例代码中，通过packaged_task类包装了一个匿名函数作为子线程的任务函数，最终的得到的这个任务对象需要通过引用的方式传递到子线程内部，这样才能在主线程的最后通过任务对象得到future对象，再通过这个future对象取出子线程通过返回值传递出的数据。
#### 4. std::async

**std::async函数比前面提到的std::promise和packaged_task更高级一些**，因为通过这函数可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个future对象中，当需要获取异步任务的结果时，只需要调用future 类的get()方法即可，如果不关注异步任务的结果，只是简单地等待任务完成的话，**可以调用future 类的wait()或者wait_for()方法**。该函数的函数原型如下：

```
// 定义于头文件 <future>
// ①
template< class Function, class... Args>
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( Function&& f, Args&&... args );

// ②
template< class Function, class... Args >
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>>
    async( std::launch policy, Function&& f, Args&&... args );
```

可以看到这是一个模板函数，在C++11中这个函数有两种调用方式：

* 函数①：直接调用传递到函数体内部的可调用对象，返回一个future对象
* 函数②：通过指定的策略调用传递到函数内部的可调用对象，返回一个future对象

函数参数:

* f：可调用对象，这个对象在子线程中被作为任务函数使用

* Args：传递给 f 的参数（实参）

* policy：可调用对象·f的执行策略

策略 	                                        说明
std::launch::async 			 调用async函数时创建新的线程执行任务函数
std::launch::deferred 	    调用async函数时不执行任务函数，直到调用了future的get()或者wait()时才执行任务（这种方式不会创建新的线程）



关于std::async()函数的使用，对应的示例代码如下：

##### 4.1 方式1

调用async()函数直接创建线程执行任务

```
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    cout << "主线程ID: " << this_thread::get_id() << endl;
    // 调用函数直接创建线程执行任务
    future<int> f = async([](int x) {
        cout << "子线程ID: " << this_thread::get_id() << endl;
        this_thread::sleep_for(chrono::seconds(5));
        return x += 100;
    }, 100);

    future_status status;
    do {
        status = f.wait_for(chrono::seconds(1));
        if (status == future_status::deferred)
        {
            cout << "线程还没有执行..." << endl;
            f.wait();
        }
        else if (status == future_status::ready)
        {
            cout << "子线程返回值: " << f.get() << endl;
        }
        else if (status == future_status::timeout)
        {
            cout << "任务还未执行完毕, 继续等待..." << endl;
        }
    } while (status != future_status::ready);

    return 0;
}
/*
示例程序输出的结果为：

主线程ID: 8904
子线程ID: 25036
任务还未执行完毕, 继续等待...
任务还未执行完毕, 继续等待...
任务还未执行完毕, 继续等待...
任务还未执行完毕, 继续等待...
任务还未执行完毕, 继续等待...
子线程返回值: 200
```



调用async()函数时不指定策略就是直接创建线程并执行任务，示例代码的主线程中做了如下操**作status = f.wait_for(chrono::seconds(1))**;其实直接调用f.get()就能得到子线程的返回值。这里为了给大家演示wait_for()的使用，所以写的复杂了些。

##### 4.2 方式2

调用async()函数不创建线程执行任务

```
#include <iostream>
#include <thread>
#include <future>
using namespace std;

int main()
{
    cout << "主线程ID: " << this_thread::get_id() << endl;
    // 调用函数直接创建线程执行任务
    future<int> f = async(launch::deferred, [](int x) {
        cout << "子线程ID: " << this_thread::get_id() << endl;
        return x += 100;
    }, 100);

    this_thread::sleep_for(chrono::seconds(5));
    cout << f.get();

    return 0;
}
/*
示例程序输出的结果：

主线程ID: 24760
主线程开始休眠5秒...
子线程ID: 24760
200
```



由于指定了launch::deferred 策略，因此调用async()函数并不会创建新的线程执行任务，当使用future类对象调用了get()或者wait()方法后才开始执行任务（==此处一定要注意调用wait_for()函数是不行的==）。

通过测试程序输出的结果可以看到，两次输出的线程ID是相同的，任务函数是在主线程中被延迟（主线程休眠了5秒）调用了。

最终总结：

1. ==使用async()函数，是多线程操作中最简单的一种方式，不需要自己创建线程对象，并且可以得到子线程函数的返回值。==
2. ==使用std::promise类，在子线程中可以传出返回值也可以传出其他数据，并且可选择在什么时机将数据从子线程中传递出来，使用起来更灵活。==
3. ==使用std::packaged_task类，可以将子线程的任务函数进行包装，并且可以得到子线程的返回值。==

