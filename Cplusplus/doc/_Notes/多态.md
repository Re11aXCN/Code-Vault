# C++ 多态编程：CRTP、虚函数与 C++23 显式对象参数

下面我将使用 C++23 分别实现静态多态（CRTP）、动态多态（虚函数）以及 C++23 新增的显式对象参数特性，并提供详细的对比分析。

## 1. CRTP (Curiously Recurring Template Pattern) - 静态多态

### 示例：

```cpp
#include <iostream>
#include <memory>

// CRTP 基类模板
template <typename Derived>
class ShapeCRTP {
public:
    void draw() const {
        // 静态多态：编译时确定调用哪个实现
        static_cast<const Derived*>(this)->draw_impl();
    }
    
    double area() const {
        return static_cast<const Derived*>(this)->area_impl();
    }
};

// 圆形实现
class CircleCRTP : public ShapeCRTP<CircleCRTP> {
private:
    double radius;
    
    friend class ShapeCRTP<CircleCRTP>;
    
    void draw_impl() const {
        std::cout << "Drawing Circle with radius: " << radius << std::endl;
    }
    
    double area_impl() const {
        return 3.14159 * radius * radius;
    }
    
public:
    explicit CircleCRTP(double r) : radius(r) {}
};

// 矩形实现
class RectangleCRTP : public ShapeCRTP<RectangleCRTP> {
private:
    double width, height;
    
    friend class ShapeCRTP<RectangleCRTP>;
    
    void draw_impl() const {
        std::cout << "Drawing Rectangle: " << width << " x " << height << std::endl;
    }
    
    double area_impl() const {
        return width * height;
    }
    
public:
    RectangleCRTP(double w, double h) : width(w), height(h) {}
};

// 使用 CRTP 的示例
void demo_crtp() {
    std::cout << "=== CRTP (Static Polymorphism) ===" << std::endl;
    
    CircleCRTP circle(5.0);
    RectangleCRTP rectangle(4.0, 6.0);
    
    // 静态多态 - 编译时确定调用
    circle.draw();
    rectangle.draw();
    
    std::cout << "Circle area: " << circle.area() << std::endl;
    std::cout << "Rectangle area: " << rectangle.area() << std::endl;
    
    // 不能将不同CRTP类型放入同一容器
    // std::vector<ShapeCRTP> shapes; // 错误
    
    std::cout << std::endl;
}
```

### CRTP 的好处

1. **静态多态**

   CRTP 实现静态多态，无需使用虚函数，静态绑定，无运行时开销。

2. **类型安全**

   CRTP 提供了类型安全的多态性。通过模板参数传递具体的子类类型，编译器能够确保类型匹配，避免了传统向下转换可能引发的类型错误。

3. **灵活的接口设计**

   CRTP 允许父类定义公共接口，并要求子类实现具体的操作。这使得基类能够提供通用的接口，而具体的实现细节留给派生类。其实也就是说多态了。

## 2. 虚函数 - 动态多态

### 虚函数调用顺序

```c++
class A {
public:
  A(){cout<<"Hello, "<<name()<<endl;}
  virtual ~A(){}
  virtual string name(){ return "A";}
};
class B : public A{
public:
  virtual string name(){ return "B";}
};

int main(int argc, wchar_t* argv[])
{
  B b;
  return 0;
}

输出 "Hello, A"
```

**关键点：在基类的构造函数中，调用的虚函数是基类自己的版本，而不是派生类的版本。**

1. **构造顺序**：
   - 创建 `B` 对象时，首先调用基类 `A` 的构造函数
   - 在 `A` 的构造函数执行时，`B` 对象中的 `A` 部分已经构造完成，但 `B` 特有的部分**还未构造**
2. **虚函数表的变化**：
   - 在 `A` 的构造函数中，虚函数表（vtable）指向的是 `A` 的虚函数表
   - `B` 的虚函数表只有在 `B` 的构造函数执行时才会被设置
   - 因此，在 `A::A()` 中调用 `name()` 时，虚函数机制解析到的是 `A::name()`，而不是 `B::name()`

原因：

当创建派生类对象时，基类的构造函数先被调用。在基类的构造函数执行期间，派生类部分还没有被初始化（即派生类的成员变量还没有初始化，派生类的虚函数表也还没有被设置为指向派生类的实现）。因此，在基类构造函数中调用虚函数，不会多态地调用派生类的重写版本，而是调用基类自己的版本。这是为了确保在基类构造函数执行期间，对象处于一个确定的状态。

所以，在A的构造函数中，name()调用的是A::name()，返回"A"，因此输出"Hello, A"。

注意：析构函数也有类似的情况。在基类的析构函数中，调用虚函数也会调用基类版本，因为派生类部分已经被析构了。

#### 总结

不能在构造函数中直接通过虚函数实现多态，如果非要使用多态功能，建议使用**模板 + 依赖注入**（CRTP）的形式

示例：

```C++
#include <iostream>
#include <string>
using namespace std;

// 基类模板
template <typename Derived>
class Animal {
public:
  Animal() {
    // 通过static_cast将this转换为派生类指针，调用派生类的实现
    cout << "Hello, " << static_cast<Derived*>(this)->name() << endl;
  }
  
  // 接口方法，强制派生类实现
  string name() {
    return static_cast<Derived*>(this)->name();
  }
};

// 派生类 - 继承自特化的基类模板
class Cat : public Animal<Cat> {
public:
  string name() { return "Cat"; }
};

class Dog : public Animal<Dog> {
public:
  string name() { return "Dog"; }
};

int main() {
  Cat cat;  // 输出: Hello, Cat
  Dog dog;  // 输出: Hello, Dog
  return 0;
}
```



### 多态实现

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 虚函数基类
class ShapeVirtual {
public:
    virtual ~ShapeVirtual() = default;
    
    virtual void draw() const = 0;
    virtual double area() const = 0;
};

// 圆形实现
class CircleVirtual : public ShapeVirtual {
private:
    double radius;
    
public:
    explicit CircleVirtual(double r) : radius(r) {}
    
    void draw() const override {
        std::cout << "Drawing Circle with radius: " << radius << std::endl;
    }
    
    double area() const override {
        return 3.14159 * radius * radius;
    }
};

// 矩形实现
class RectangleVirtual : public ShapeVirtual {
private:
    double width, height;
    
public:
    RectangleVirtual(double w, double h) : width(w), height(h) {}
    
    void draw() const override {
        std::cout << "Drawing Rectangle: " << width << " x " << height << std::endl;
    }
    
    double area() const override {
        return width * height;
    }
};

// 使用虚函数的示例
void demo_virtual() {
    std::cout << "=== Virtual Functions (Dynamic Polymorphism) ===" << std::endl;
    
    std::vector<std::unique_ptr<ShapeVirtual>> shapes;
    shapes.push_back(std::make_unique<CircleVirtual>(5.0));
    shapes.push_back(std::make_unique<RectangleVirtual>(4.0, 6.0));
    
    // 动态多态 - 运行时确定调用
    for (const auto& shape : shapes) {
        shape->draw();
        std::cout << "Area: " << shape->area() << std::endl;
    }
    
    std::cout << std::endl;
}
```

## 3. C++23 显式对象参数 (Deducing this) - 静态多态

```cpp
#include <iostream>
#include <memory>
#include <vector>

// 使用 C++23 显式对象参数的基类
class ShapeDeducingThis {
public:
    void draw(this auto&& self) {
        // 静态多态：编译时确定调用
        self.draw_impl();
    }

    double area(this auto&& self) {
        return self.area_impl();
    }
};

// 圆形实现
class CircleDeducingThis : public ShapeDeducingThis {
private:
    double radius;
    
    void draw_impl() {
        std::cout << "Drawing Circle with radius: " << radius << std::endl;
    }
    
    double area_impl() const {
        return 3.14159 * radius * radius;
    }
    
public:
    explicit CircleDeducingThis(double r) : radius(r) {}
};

// 矩形实现
class RectangleDeducingThis : public ShapeDeducingThis {
private:
    double width, height;
    
    void draw_impl() {
        std::cout << "Drawing Rectangle: " << width << " x " << height << std::endl;
    }
    
    double area_impl() const {
        return width * height;
    }
    
public:
    RectangleDeducingThis(double w, double h) : width(w), height(h) {}
};

// 使用显式对象参数的示例
void demo_deducing_this() {
    std::cout << "=== Deducing this (C++23 Static Polymorphism) ===" << std::endl;
    
    CircleDeducingThis circle(5.0);
    RectangleDeducingThis rectangle(4.0, 6.0);
    
    // 静态多态 - 编译时确定调用
    circle.draw();
    rectangle.draw();
    
    std::cout << "Circle area: " << circle.area() << std::endl;
    std::cout << "Rectangle area: " << rectangle.area() << std::endl;
    
    // 可以将不同对象放入同一容器（通过基类指针）
    std::vector<ShapeDeducingThis*> shapes;
    shapes.push_back(&circle);
    shapes.push_back(&rectangle);
    
    for (auto shape : shapes) {
        shape->draw(); // 静态分派，调用正确的实现
        // shape->area(); // 注意：这里会有问题，因为area返回double
    }
    
    std::cout << std::endl;
}
```

## 4. 综合示例与对比

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <chrono>

// 性能测试函数
template <typename Func>
void measure_performance(const std::string& name, Func func, int iterations = 1000000) {
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < iterations; ++i) {
        func();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    std::cout << name << " took " << duration.count() << " microseconds for " 
              << iterations << " iterations" << std::endl;
}

// 主函数
int main() {
    // 演示三种多态技术
    demo_crtp();
    demo_virtual();
    demo_deducing_this();
    
    // 性能对比
    std::cout << "=== Performance Comparison ===" << std::endl;
    
    // CRTP 性能测试
    CircleCRTP crtp_circle(5.0);
    measure_performance("CRTP", [&]() {
        return crtp_circle.area();
    });
    
    // 虚函数性能测试
    CircleVirtual virtual_circle(5.0);
    measure_performance("Virtual", [&]() {
        return virtual_circle.area();
    });
    
    // Deducing this 性能测试
    CircleDeducingThis deducing_circle(5.0);
    measure_performance("Deducing this", [&]() {
        return deducing_circle.area();
    });
    
    return 0;
}
```

## 5. 三种多态技术的对比分析

| 特性             | CRTP (静态多态)                | 虚函数 (动态多态)            | C++23 显式对象参数 (静态多态)   |
| ---------------- | ------------------------------ | ---------------------------- | ------------------------------- |
| **多态类型**     | 静态 (编译时)                  | 动态 (运行时)                | 静态 (编译时)                   |
| **性能**         | 最高 (无运行时开销)            | 较低 (虚表查找开销)          | 高 (编译时多态，无虚表)         |
| **内存使用**     | 最小 (无虚表指针)              | 较高 (每个对象有虚表指针)    | 最小 (无虚表指针)               |
| **二进制兼容性** | 好 (模板实例化)                | 好 (ABI稳定)                 | 好 (模板实例化)                 |
| **代码膨胀**     | 可能较高 (每个类型单独实例化)  | 低 (单一实现)                | 可能较高 (每个类型单独实例化)   |
| **对象存储**     | 不能存储异构对象               | 可以存储异构对象             | 可以存储异构对象 (通过基类指针) |
| **实现复杂度**   | 较高 (需要模板元编程知识)      | 低 (传统OOP方式)             | 中等 (需要理解新语法)           |
| **调试难度**     | 较高 (模板错误复杂)            | 低 (传统调试方式)            | 中等 (模板错误但相对清晰)       |
| **C++版本要求**  | C++98/11                       | C++98                        | C++23                           |
| **适用场景**     | 性能关键代码，不需要运行时多态 | 需要运行时多态，对象类型未知 | 需要静态多态但希望简化CRTP语法  |

## 6. 使用场景建议

### CRTP 适用场景：
- 性能极其关键的代码
- 不需要运行时多态的情况
- 实现混合类 (mixin classes)
- 静态接口实现

### 虚函数适用场景：
- 需要运行时多态
- 对象类型在编译时未知
- 需要将不同派生类对象存储在统一容器中
- 框架和库设计，需要扩展性

### C++23 显式对象参数适用场景：
- 需要静态多态但希望语法更简洁
- 希望避免 CRTP 的模板复杂性
- 需要将静态多态对象存储在统一容器中
- 新项目，可以要求 C++23 支持

## 总结

C++23 的显式对象参数特性为静态多态提供了一种新的实现方式，它结合了 CRTP 的性能优势和虚函数的语法简洁性。这三种多态技术各有优缺点，适用于不同的场景：

1. **CRTP** 提供最高的性能，但语法较为复杂
2. **虚函数** 提供最大的灵活性，但有运行时开销
3. **显式对象参数** 提供了静态多态的简洁语法，同时保持了高性能

在实际项目中，应根据具体需求选择合适的多态技术。对于性能关键且不需要运行时多态的代码，CRTP 或显式对象参数是更好的选择；对于需要运行时灵活性的场景，虚函数仍然是不可替代的解决方案。