# Intel SIMD 指令集指南

## 头文件包含关系

| Header          | 指令集扩展                          | 说明                        |
| --------------- | ----------------------------------- | --------------------------- |
| `<mmintrin.h>`  | MMX                                 | 多媒体扩展（64位整数运算）  |
| `<xmmintrin.h>` | SSE                                 | 流式SIMD扩展（单精度浮点）  |
| `<emmintrin.h>` | SSE2                                | SSE2（双精度浮点和整数）    |
| `<pmmintrin.h>` | SSE3                                | SSE3（水平运算等）          |
| `<tmmintrin.h>` | SSSE3                               | 补充SSE3                    |
| `<smmintrin.h>` | SSE4.1                              | SSE4.1（点积、插入提取等）  |
| `<nmmintrin.h>` | SSE4.2                              | SSE4.2（字符串处理、CRC32） |
| `<wmmintrin.h>` | AES                                 | AES-NI加密指令              |
| `<immintrin.h>` | AVX, AVX2, FMA, BMI, POPCNT, AVX512 | 所有现代扩展的聚合头文件    |
| `<x89intrin.h>` | Auto                                | GCC编译器自动包含           |
| `<intrin.h>`    | Auto                                | MSVC编译器自动包含          |

> **重要**：`<immintrin.h>` 自动包含所有之前列出的头文件

## SIMD 内置函数命名规则

### 基本格式
```
_mm{宽度}_{操作}_{类型}[_修饰符]
└┬┘ └┬┘  └┬┘  └┬┘   └┬┘
 │   │    │    │     └─ 可选修饰符
 │   │    │    └─ 数据类型
 │   │    └─ 操作名称
 │   └─ 寄存器宽度（可选）
 └─ 前缀
```

### 各部分详解

#### 1. **前缀** (`_mm` / `_mm256` / `_mm512`)
- `_mm` - 128位寄存器（SSE/AVX）
- `_mm256` - 256位寄存器（AVX/AVX2）
- `_mm512` - 512位寄存器（AVX-512）

#### 2. **宽度标识**（可选）
- 无 - 默认128位
- `256` - 256位
- `512` - 512位

#### 3. **操作名称**
- `add`, `sub`, `mul`, `div` - 算术运算
- `set` - 设置寄存器值
- `load` - 从内存加载
- `store` - 存储到内存
- `cmp` - 比较
- `shuffle` - 重排元素
- `blend` - 混合
- `and`, `or`, `xor` - 逻辑运算

#### 4. **数据类型后缀**

##### **浮点类型**
- `ps` - **Packed Single-precision** (打包单精度浮点)
  - 多个单精度浮点数（通常4个）
- `ss` - **Scalar Single-precision** (标量单精度浮点)
  - 仅操作最低位的单精度浮点数
- `pd` - **Packed Double-precision** (打包双精度浮点)
- `sd` - **Scalar Double-precision** (标量双精度浮点)

##### **整数类型**
- `epi8/epi16/epi32/epi64` - 有符号整数
  - `epi8` = 8位有符号整数
  - `epi16` = 16位有符号整数
  - `epi32` = 32位有符号整数
  - `epi64` = 64位有符号整数
- `epu8/epu16/epu32/epu64` - 无符号整数
- `si128/si256/si512` - 未指定类型的128/256/512位整数

##### **特殊类型**
- `m128/m128d/m128i` - 128位数据
- `m256/m256d/m256i` - 256位数据

### 示例解析

#### 示例 1: `_mm_set_ss(float a)`
- `_mm` - 128位寄存器
- `set` - 设置操作
- `ss` - 标量单精度浮点
- **功能**: 将最低32位设为`a`，其他位清零
- **结果**: `[a, 0.0, 0.0, 0.0]`

#### 示例 2: `_mm_setr_ps(float z, float y, float x, float w)`
- `_mm` - 128位寄存器
- `set` - 设置操作
- `r` - **Reverse** (反向顺序)
- `ps` - 打包单精度浮点
- **功能**: 按参数顺序反向设置寄存器
- **结果**: `[w, x, y, z]` (参数顺序与寄存器顺序相反)

#### 示例 3: `_mm_set_ps(float w, float x, float y, float z)`
- `_mm` - 128位寄存器
- `set` - 设置操作
- `ps` - 打包单精度浮点
- **功能**: 按参数顺序设置寄存器
- **结果**: `[z, y, x, w]` (注意顺序!)

## 内存顺序：大端 vs 小端

### **Intel x86/x64 使用小端序**
- **小端序 (Little-endian)**: 最低有效字节存储在最低内存地址
- **内存布局示例**: 0x12345678 在内存中存储为 `78 56 34 12`

### SIMD 寄存器的元素顺序

对于 `_mm_set_ps(w, x, y, z)`:

```
寄存器布局（内存视图，从低地址到高地址）：
低地址 → 高地址
[元素0, 元素1, 元素2, 元素3]

_mm_set_ps(w, x, y, z) 的结果：
低地址：z (元素0)
        y (元素1)
        x (元素2)
高地址：w (元素3)
```

### 函数对比表

| 函数                      | 参数顺序   | 寄存器布局（低→高） | 说明       |
| ------------------------- | ---------- | ------------------- | ---------- |
| `_mm_set_ps(w, x, y, z)`  | w, x, y, z | `[z, y, x, w]`      | 自然顺序   |
| `_mm_setr_ps(z, y, x, w)` | z, y, x, w | `[w, x, y, z]`      | 反向顺序   |
| `_mm_set_ss(a)`           | a          | `[a, 0, 0, 0]`      | 仅设置标量 |

### 重要提示

1. **参数顺序**与**内存顺序**是相反的：
   - 函数参数：从左到右（w, x, y, z）
   - 内存布局：从低到高（z, y, x, w）

2. **元素索引**：
   ```c
   __m128 v = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);
   // 元素索引：v[0]=1.0f, v[1]=2.0f, v[2]=3.0f, v[3]=4.0f
   // 内存地址：低地址存1.0f，高地址存4.0f
   ```

3. **使用建议**：
   - `_mm_set_ps()`：当你知道元素的最终位置时使用
   - `_mm_setr_ps()`：当你想按参数顺序设置时使用（更直观）
   - 加载连续数据时，注意内存中的数据排列方式

## 常用函数速查

```c
// 设置函数
__m128  v1 = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);  // [1,2,3,4]
__m128  v2 = _mm_setr_ps(1.0f, 2.0f, 3.0f, 4.0f); // [4,3,2,1]
__m128  v3 = _mm_set_ss(5.0f);                     // [5,0,0,0]
__m128  v4 = _mm_set1_ps(7.0f);                    // [7,7,7,7] 全部相同
__m128  v5 = _mm_setzero_ps();                     // [0,0,0,0]

// 加载/存储
__m128  v6 = _mm_load_ps(float* ptr);    // 对齐加载
__m128  v7 = _mm_loadu_ps(float* ptr);   // 未对齐加载
_mm_store_ps(float* ptr, __m128 v);      // 对齐存储

// 算术运算
__m128  v8 = _mm_add_ps(a, b);           // a + b
__m128  v9 = _mm_mul_ps(a, b);           // a * b
__m128 v10 = _mm_sqrt_ps(a);             // sqrt(a)
```

这个命名规则和内存顺序的理解对于正确使用SIMD指令至关重要。记住Intel是小端架构，且函数参数顺序与内存顺序相反，可以避免常见的混淆。