我们有两种主要的方法来检查在OpenGL中的错误，其中个叫glGetError,它是一个我们可以调用的函数，它从一开始就一直在OpenGL中，它兼容所有版本，原理：基本上每次我们调用openGL函数，如果发生错误，在OpenGL内存中，有一个标志会被内部设置，那基本上就是说发生了什么类型的错误，并目当我们调用gIGetError时，它会返回一个标志

https://docs.gl/gl4/glDebugMessageCallback

glDebugMessageCallback比gIGetError好，gIGetError需要不断的询问OpenGL是否正常，然后while获取所有error

本期cherno主讲gIGetError，因为兼容所有版本



```cpp
static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);
}
static void GLCheckError()
{
	while (uint32_t error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << ")" << std::endl;
	}
}

//错误测试：
    
glDrawElements(GL_TRIANGLES, 6, GL_INT,nullptr);
```

![image-20240701184516755](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240701184516755.png)

1280十六进制0x000000500

![image-20240701184701781](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240701184701781.png)



### 如果我们想要出错的时候程序能够中断以便我们修改，可以设置断言

```cpp
// __debugbreak是MSVC特有的在CLang以及其他编译器不管用
#define ASSERT(x) if(!(x)) __debugbreak()

static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);
}
static bool GLLogError()
{
	while (uint32_t error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << ")" << std::endl;
		return false;
	}
	return true;
}

// main方法中

	while (!glfwWindowShouldClose(window))
	{
		glClear(GL_COLOR_BUFFER_BIT);
		GLClearError();
		glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr);
		ASSERT(GLLogCall());

		glfwSwapBuffers(window);

		glfwPollEvents();
	}
```

#### 更好的做法

```cpp
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall())

while (!glfwWindowShouldClose(window))
	{
		glClear(GL_COLOR_BUFFER_BIT);
    
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

		glfwSwapBuffers(window);

		glfwPollEvents();
	}

```

#### 更详细的输出

```cpp
#define ASSERT(x) if(!(x)) __debugbreak()
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall(#x, __FILE__, __LINE__))

static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);
}
static bool GLLogCall(const char* function, const char* file, int line)
{
	while (uint32_t error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << "): " << function <<
			" " << file << ":" << line << std::endl;
		return false;
	}
	return true;
}
```



#### 完整代码

```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

#define ASSERT(x) if(!(x)) __debugbreak()
#define GLCall(x) GLClearError();\
	x;\
	ASSERT(GLLogCall(#x, __FILE__, __LINE__))

static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);
}
static bool GLLogCall(const char* function, const char* file, int line)
{
	while (uint32_t error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << "): " << function <<
			" " << file << ":" << line << std::endl;
		return false;
	}
	return true;
}

// 定义一个结构体，用于存储顶点着色器和片段着色器的源代码  
struct ShaderProgramSource
{
	std::string VertexSource;  // 顶点着色器的源代码  
	std::string FragmentSource; // 片段着色器的源代码  
};

// 定义一个静态函数，用于从文件路径中解析并读取着色器源代码  
static ShaderProgramSource ParseShader(const std::string& filepath)
{
	// 使用文件流打开指定的文件  
	std::ifstream stream(filepath);

	// 定义一个枚举类，用于表示着色器的类型  
	enum class ShaderType
	{
		NONE = -1,     // 无类型（初始值）  
		VERTEX = 0,    // 顶点着色器  
		FRAGMENT = 1   // 片段着色器  
	};

	// 定义一个字符串变量，用于存储从文件中读取的每一行  
	std::string line;

	// 定义一个字符串流数组，用于分别存储顶点着色器和片段着色器的源代码  
	// 注意：这里使用数组而非两个独立的字符串流，是为了与ShaderType枚举相对应  
	std::stringstream ss[2];

	// 初始化着色器类型为NONE  
	ShaderType type = ShaderType::NONE;

	// 逐行读取文件内容  
	while (getline(stream, line))
	{
		// 检查当前行是否包含"#shader"字符串  
		if (line.find("#shader") != std::string::npos)
		{
			// 如果当前行同时包含"vertex"字符串，则将着色器类型设置为VERTEX  
			if (line.find("vertex") != std::string::npos)
				type = ShaderType::VERTEX;
			// 如果当前行同时包含"fragment"字符串，则将着色器类型设置为FRAGMENT  
			else if (line.find("fragment") != std::string::npos)
				type = ShaderType::FRAGMENT;
		}
		// 如果当前行不是定义着色器类型的行，则将其添加到对应的字符串流中  
		else
		{
			// 使用强制类型转换将ShaderType枚举值转换为数组索引  
			// 并将当前行（包括换行符）添加到对应的字符串流中  
			ss[(int)type] << line << "\n";
		}
	}

	// 返回一个ShaderProgramSource结构体，其中包含了从文件中读取的顶点着色器和片段着色器的源代码  
	return { ss[0].str(), ss[1].str() };
}

// 定义一个函数，用于编译一个着色器（顶点着色器或片段着色器）  
// 参数：  
//   type: 着色器的类型（GL_VERTEX_SHADER 或 GL_FRAGMENT_SHADER）  
//   source: 着色器的源代码（以字符串形式提供）  
// 返回值：  
//   如果编译成功，返回着色器的ID；如果失败，返回0  
static uint32_t CompileShader(uint32_t type, const std::string& source)
{
	// 创建一个着色器对象，并获取其ID  
	uint32_t id = glCreateShader(type);

	const char* src = source.c_str(); // 也可以使用 &source[0]  

	// 将源代码设置为着色器的源代码  , 并编译
	glShaderSource(id, 1, &src, nullptr); // 第一个参数是着色器ID，第二个参数是源代码的字符串数量（这里是1），第三个参数是指向源代码字符串的指针的数组，第四个参数是源代码字符串的长度（这里是nullptr，表示自动计算）   
	glCompileShader(id);

	// 检查着色器是否编译成功  
	int result;
	glGetShaderiv(id, GL_COMPILE_STATUS, &result); // 获取着色器的编译状态  

	if (result == GL_FALSE) // 如果编译失败  
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length); // 获取错误日志的长度  

		// char message[length];不允许不确定的值在栈内申请内存，换个思维
		char* message = (char*)alloca(length * sizeof(char));

		// 获取编译错误的详细信息  
		glGetShaderInfoLog(id, length, &length, message);

		std::cout << "Failed to compile shader!"
			<< (type == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< "shader!\n";
		std::cout << message << std::endl;

		// 删除着色器对象（因为编译失败了，所以不再需要它）  
		glDeleteShader(id);

		return 0;
	}

	return id;
}

// 定义一个函数，用于创建一个着色器程序（包括顶点着色器和片段着色器）  
// 参数：  
//   vertexShader: 顶点着色器的源代码  
//   fragmentShader: 片段着色器的源代码  
// 返回值：  
//   如果创建成功，返回着色器程序的ID；否则，行为是未定义的（因为CreateShader函数中没有明确的错误处理）  
static uint32_t CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	// 创建一个着色器程序对象，并获取其ID  
	uint32_t program = glCreateProgram();

	// 编译顶点着色器和片段着色器，并获取它们的ID  
	uint32_t vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
	uint32_t fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

	// 将编译好的着色器附加到着色器程序上  
	glAttachShader(program, vs);
	glAttachShader(program, fs);

	// 链接着色器程序（将顶点着色器和片段着色器连接成一个完整的着色器程序）  
	glLinkProgram(program);

	// 验证着色器程序（检查着色器程序是否按预期工作）  
	glValidateProgram(program); // 注意：验证不是必须的，但它可以帮助你在运行时发现可能的错误  

	// 删除顶点着色器和片段着色器对象（因为它们已经被链接到了着色器程序中，所以不再需要单独的对象）  
	glDeleteShader(vs);
	glDeleteShader(fs);

	// 返回着色器程序的ID  
	return program;
}

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;

	float positions[] = {
		-0.5f, -0.5f,
		0.5f, -0.5f,
		0.5f, 0.5f,
		-0.5f,0.5f,
	};// 矩形缓冲区数组数据

	uint32_t indices[] = {
		0, 1, 2,
		2, 3, 0
	};

	uint32_t buffer;
	// 可以设置多个缓冲区，这里设置1个缓存区
	// 传入这个unsigned int的内存地址，现在，这就是生成的缓冲区的id
	glGenBuffers(1, &buffer);
	// 并且选择(selecting)缓冲区的id在OpenGL中称为绑定(binding) : 所以输入glBindBuffer()
	glBindBuffer(GL_ARRAY_BUFFER, buffer);
	// 指定缓冲区大小
	/*
	void glBufferData( 	GLenum target,
						GLsizeiptr size,
						const GLvoid * data,
						GLenum usage);
	*/
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW); // 或者 6 * sizeof(float)

	/* 布局代码 */
	// 启动索引0
	glEnableVertexAttribArray(0);
	/*
	index	:索引缓冲区 ,			size		:组件数量和字节无关，每个坐标有几个浮点数就是几，三角形二维坐标两个
	type	:类型,		normalize	:标准化，已经是浮点数了设置为flase
	stride	:两点之间的距离——字节数，二维坐标float，相差8
	pointer	:属性偏移，二维坐标这里没有属性设置0，如果有属性，
			二维坐标-0.5f, -0.5f, 0.5f（纹理坐标），那么偏移就是8, 2 * float，那么应该设置为(const void*)8
			这不是最好的办法，实际采用结构体，设置宏偏移量
	*/
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);

	uint32_t ibo;
	glGenBuffers(1, &ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);


	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");

	uint32_t shader = CreateShader(source.VertexSource, source.FragmentSource);
	glUseProgram(shader);

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);
		GLClearError();

		// 没有索引缓冲区的方法
		/*
		first:绘制图像mode-三角形，second:起始顶点（数组下标三个任选一个）,third:顶点数量
		*/
		//glDrawArrays(GL_TRIANGLES, 0, 6);
		// 索引缓冲区函数
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));

#define GL_TRADITION 0
#if GL_TRADITION
		/*画一个三角形*/
		glBegin(GL_TRIANGLES);
		glVertex2f(-0.5f, -0.5f);
		glVertex2f(0.0f, 0.5f);
		glVertex2f(0.5f, -0.5f);
		glEnd();
#endif // 0

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glDeleteProgram(shader);

	glfwTerminate();
	return 0;
}
```



### 最终代码(宏优化后的)

```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

#define ASSERT(x) if(!(x)) __debugbreak()
/* 反斜杠后面不能有空格 */
#define GLCall(x) do { \
    GLClearError();\
    x;\
    ASSERT(GLLogCall(#x, __FILE__, __LINE__));\
 } while (0)

static void GLClearError()
{
	while (glGetError() != GL_NO_ERROR);
}

static bool GLLogCall(const char* function, const char* file, int line)
{
	while (uint32_t error = glGetError())
	{
		std::cout << "[OpenGL Error] (" << error << "): " << function <<
			" " << file << ":" << line << std::endl;
		return false;
	}
	return true;
}

struct ShaderProgramSource
{
	std::string VertexSource;
	std::string FragmentSource;
};

static ShaderProgramSource ParseShader(const std::string& filepath)
{
	std::ifstream stream(filepath);

	enum class ShaderType
	{
		NONE = -1,     // 无类型（初始值）  
		VERTEX = 0,    // 顶点着色器  
		FRAGMENT = 1   // 片段着色器  
	};

	std::string line;
	std::stringstream ss[2];
	ShaderType type = ShaderType::NONE;

	while (getline(stream, line))
	{
		if (line.find("#shader") != std::string::npos)
		{
			if (line.find("vertex") != std::string::npos)
				type = ShaderType::VERTEX;
			else if (line.find("fragment") != std::string::npos)
				type = ShaderType::FRAGMENT;
		}
		else
		{
			ss[(int)type] << line << "\n";
		}
	}
	return { ss[0].str(), ss[1].str() };
}

static uint32_t CompileShader(uint32_t type, const std::string& source)
{

	uint32_t id = glCreateShader(type);
	const char* src = source.c_str(); // 也可以使用 &source[0]  

	GLCall(glShaderSource(id, 1, &src, nullptr));
	GLCall(glCompileShader(id));

	int result;
	GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &result));

	if (result == GL_FALSE)
	{
		int length;
		GLCall(glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length));

		// char message[length];不允许不确定的值在栈内申请内存，换个思维
		char* message = (char*)alloca(length * sizeof(char));

		GLCall(glGetShaderInfoLog(id, length, &length, message));

		std::cout << "Failed to compile shader!"
			<< (type == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< "shader!\n";
		std::cout << message << std::endl;

		GLCall(glDeleteShader(id));

		return 0;
	}

	return id;
}

static uint32_t CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	uint32_t program;
	GLCall(program = glCreateProgram());

	uint32_t vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
	uint32_t fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

	GLCall(glAttachShader(program, vs));
	GLCall(glAttachShader(program, fs));

	GLCall(glLinkProgram(program));
	GLCall(glValidateProgram(program));

	GLCall(glDeleteShader(vs));
	GLCall(glDeleteShader(fs));

	return program;
}

int main(void)
{
	GLFWwindow* window;

	if (!glfwInit())
		return -1;

	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);

	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;

	float positions[] = {
		-0.5f, -0.5f,
		0.5f, -0.5f,
		0.5f, 0.5f,
		-0.5f,0.5f,
	};

	uint32_t indices[] = {
		0, 1, 2,
		2, 3, 0
	};

	uint32_t buffer;
	GLCall(glGenBuffers(1, &buffer));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));
	GLCall(glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW));

	GLCall(glEnableVertexAttribArray(0));
	GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));

	uint32_t ibo;
	GLCall(glGenBuffers(1, &ibo));
	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));
	GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW));

	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
	uint32_t shader = CreateShader(source.VertexSource, source.FragmentSource);
	GLCall(glUseProgram(shader));

	while (!glfwWindowShouldClose(window))
	{
		glClear(GL_COLOR_BUFFER_BIT);
		GLClearError();

		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	GLCall(glDeleteProgram(shader));
	glfwTerminate();
	return 0;
}
```

