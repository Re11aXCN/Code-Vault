行主序相乘，如果你们从左到右读取，相乘的时候，而OpenGL是相反的

==**模型M矩阵把模型投影到世界坐标，视图V矩阵相当手设置世界中的相机位置，正交P矩阵则是为了把相机所能拍摄到的东西投影到屏幕上**==

变换，旋转，缩放，简称TRS

opengl没有相机，所以为了模拟相机向左移动，我们需要做的是将所有东西向右移，逆向运算

```cpp
		// 4*4的正交矩陣
		// 创建了一个从窗口顶部到底部有3个单位距离的东西,从左到右有4个单元距离
		// 这是一个4x3的纵横比，应该能固定所有的顶点位置
		// 左右下上、近平面、远平面
		glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);
		glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));// 1.0f视图矩阵本体左移100，相机右移本体左移
		glm::mat4 mvp = proj * view;
```

![image-20240702214037588](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702214037588.png)

```cpp
		// 4*4的正交矩陣
		// 创建了一个从窗口顶部到底部有3个单位距离的东西,从左到右有4个单元距离
		// 这是一个4x3的纵横比，应该能固定所有的顶点位置
		// 左右下上、近平面、远平面
		glm::mat4 proj = glm::ortho(0.0f, 960.0f, 0.0f, 540.0f, -1.0f, 1.0f);
		glm::mat4 view = glm::translate(glm::mat4(1.0f), glm::vec3(-100, 0, 0));// 1.0f视图矩阵本体左移100，相机右移本体左移
		glm::mat4 model = glm::translate(glm::mat4(1.0f), glm::vec3(200, 200, 0));
		glm::mat4 mvp = proj * view * model;
```

![image-20240702213954495](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702213954495.png)

所以这个得到的矩阵就是我们的mvp就是模型视图投影，乘法的顺序是相反的，事实上，所有数字的内存布局，它们是主列排列的事实，你们可以把OpenGL中的矩阵乘法理解为从右到左



矩阵左乘，因为图形学里的矩阵一般都是按列排列，左行右列，如果要列运算就要把mvp矩阵右乘原矩阵，就也就是把这矩阵依次放原矩阵左边
