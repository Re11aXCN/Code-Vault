绑定页点缓冲区并设置其布局只是变成了绑定顶点数组对象

顶点数组对象必须有，默认情况下，兼容性配置文件实际上为我们创建了一个顶点数组对象，就是默认0的作用



```cpp
int main(void)
{
	GLFWwindow* window;

	if (!glfwInit())
		return -1;
	
    // 新增，版本3.3
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);
    
    
    //...
    // 新增，解绑
	GLCall(glUseProgram(0));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));

	float red = 0.0f;
	float increment = 0.05f;
	while (!glfwWindowShouldClose(window))
	{
		glClear(GL_COLOR_BUFFER_BIT);
		
        // 修改
		GLCall(glUseProgram(shader));
		GLCall(glUniform4f(location, red, 0.3f, 0.8f, 1.0f));

		GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));
		GLCall(glEnableVertexAttribArray(0));
		GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));


		GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

		if (red > 1.0f) increment = -0.05f;
		else if (red < 0.0f) increment = 0.05f;
		red += increment;

		glfwSwapBuffers(window);
		glfwPollEvents();
	}
    
    /...
}
```

### 核心模式兼容模式

当你将 `glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);` 替换为 `glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);` 后，你正在告诉GLFW创建一个支持OpenGL核心模式（Core Profile）的窗口，而不是兼容模式（Compatibility Profile）。

OpenGL核心模式与兼容模式的主要区别在于：

- 核心模式移除了许多旧的、已废弃的功能，并强制使用现代的、更高效的编程方式。
- 兼容模式保留了旧的OpenGL API，允许程序员使用旧的代码和特性，但可能牺牲了一些性能。

当你切换到核心模式时，一些在兼容模式下可用的函数或特性可能不再可用，或者需要不同的方式来使用。具体到你的错误，`glEnableVertexAttribArray(0)` 本身在核心模式下仍然是有效的调用，但错误码1282（在OpenGL中，错误码通常以`GL_INVALID_OPERATION`的形式表示，其值在大多数实现中确实是1282）通常表示你尝试在一个无效的状态下进行了一个操作。

这里有几个可能导致`glEnableVertexAttribArray(0)`在核心模式下失败的原因：

1. **顶点数组对象（VAO）未绑定**：在核心模式下，你必须在调用`glEnableVertexAttribArray`之前绑定一个有效的顶点数组对象（通过`glBindVertexArray`）。否则，该调用将是无效的。

2. **着色器程序未链接或未激活**：在调用`glEnableVertexAttribArray`之前，你需要确保一个着色器程序已经成功链接并且是当前激活的着色器程序（通过`glUseProgram`）。

3. **顶点属性索引无效**：你正在尝试启用索引为0的顶点属性，但是你的顶点着色器可能没有定义该索引的属性。确保你的顶点着色器有一个匹配的属性定义，并且你在调用`glEnableVertexAttribArray`之前正确地设置了属性位置（通过`glBindAttribLocation`或直接在着色器源代码中使用`layout(location = 0)`）。

4. **其他OpenGL错误**：在调用`glEnableVertexAttribArray`之前，确保没有其他OpenGL调用失败并设置了错误状态。你可以使用`glGetError`来检查并清除这些错误。

为了解决这个问题，你应该：

- 确保在调用`glEnableVertexAttribArray`之前绑定了一个有效的顶点数组对象。
- 确保你的着色器程序已经成功链接并且是当前激活的着色器程序。
- 检查你的顶点着色器是否定义了与`glEnableVertexAttribArray`调用匹配的顶点属性。
- 在你的代码中增加OpenGL错误检查，以便更容易地识别和调试问题。

```cpp
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);
修改为核心配置
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
会触发断言输出1282
查看文档https://docs.gl/gl4/glEnableVertexAttribArray
意思是就是当没有绑定顶点数组对象
所以在核心配置文件中我们需要修复创建一个unsigned int vao
    顶点数组对象
```

## 核心模式下存储顶点原理

在OpenGL的核心模式下，使用顶点数组对象（Vertex Array Object, VAO）是处理顶点数据的标准方式。您提到的代码片段正是创建并绑定一个VAO的示例，这里我详细解释一下其原理：

### 顶点数组对象（VAO）

VAO是OpenGL中的一个状态容器，它存储了顶点数据的配置信息，包括顶点缓冲对象（VBOs）的绑定状态、顶点属性指针（vertex attribute pointers）的设置等。使用VAO可以极大地简化顶点数据的设置过程，因为它允许你将所有的顶点数据配置保存在一个对象中，并在需要时通过一次绑定操作来恢复这些配置。

### 创建并绑定VAO

```cpp
uint32_t vao;
GLCall(glGenVertexArrays(1, &vao));
GLCall(glBindVertexArray(vao));
```

1. **glGenVertexArrays**: 这个函数用于生成一个或多个新的VAO标识符（IDs）。在这个例子中，它生成了一个VAO的ID，并将其存储在变量`vao`中。这些ID是OpenGL用来唯一标识VAO的。

2. **glBindVertexArray**: 这个函数用于将当前上下文中的VAO绑定到指定的ID上。一旦绑定，所有后续的顶点数据配置（如绑定VBOs、设置顶点属性指针等）都会与这个VAO关联起来。当这个VAO再次被绑定时，所有这些配置都会自动恢复，无需重新设置。

### 原理

在OpenGL的核心模式下，如果不使用VAO，你需要手动设置每一个顶点属性指针（通过`glVertexAttribPointer`等函数），并在每次绘制调用之前重新设置它们，因为OpenGL的许多状态在状态机中是分离的，并且不会自动保存。这种方式既繁琐又容易出错。

使用VAO后，你可以将所有的顶点数据配置保存在VAO中，并在需要绘制时简单地绑定VAO。这样，OpenGL就会自动恢复所有与VAO关联的顶点数据配置，从而简化了代码并提高了效率。

### 总结

在OpenGL的核心模式下，使用VAO是处理顶点数据的推荐方式。通过创建并绑定VAO，你可以将顶点数据的配置保存在一个状态容器中，并在需要时通过一次绑定操作来恢复这些配置，从而简化了顶点数据的处理过程。

——————————————————————————

绑定顶点数组和缓冲区的时候，实际上没有东西去链接这两个

```cpp
	uint32_t vao;
	GLCall(glGenVertexArrays(1, &vao));
	GLCall(glBindVertexArray(vao));

	uint32_t buffer;
	GLCall(glGenBuffers(1, &buffer));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));
```

当我们指定	`GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));`的时候说明顶点数组的索引为0的位置，将实际绑定到当前绑定的GL_ARRAY_BUFFER插槽

换句话说	`GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));`是实际链接缓冲区buffer的代码，通过`&vao`链接

——————————————————

如果我们只使用兼容性配置文件，这并不意味着没有顶点数组对象，我们有一个默认的顶点数组对像，它被绑定并设置为供我们使用



## 代码

```cpp
int main(void)
{
	GLFWwindow* window;

	if (!glfwInit())
		return -1;

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);

	glfwSwapInterval(1);

	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;

	float positions[] = {
		-0.5f, -0.5f,
		0.5f, -0.5f,
		0.5f, 0.5f,
		-0.5f,0.5f,
	};

	uint32_t indices[] = {
		0, 1, 2,
		2, 3, 0
	};

	// core核心配置需要做的存储顶点对象
	uint32_t vao;
	GLCall(glGenVertexArrays(1, &vao));
	GLCall(glBindVertexArray(vao));

	uint32_t buffer;
	GLCall(glGenBuffers(1, &buffer));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));
	GLCall(glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW));

	GLCall(glEnableVertexAttribArray(0));
	GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));

	uint32_t ibo;
	GLCall(glGenBuffers(1, &ibo));
	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));
	GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW));

	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
	uint32_t shader = CreateShader(source.VertexSource, source.FragmentSource);
	GLCall(glUseProgram(shader));

	// 获取着色器实际颜色变量的位置
	int location;
	GLCall(location = glGetUniformLocation(shader, "u_Color"));
	ASSERT(location != -1);
	// 设置颜色数据
	GLCall(glUniform4f(location, 0.8f, 0.3f, 0.8f, 1.0f));

	// 解绑
	GLCall(glBindVertexArray(0));
	GLCall(glUseProgram(0));
	GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
	GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));

	float red = 0.0f;
	float increment = 0.05f;
	while (!glfwWindowShouldClose(window))
	{
		glClear(GL_COLOR_BUFFER_BIT);

		GLCall(glUseProgram(shader));
		GLCall(glUniform4f(location, red, 0.3f, 0.8f, 1.0f));
		
		// 绑定了顶点数组
		GLCall(glBindVertexArray(vao));
		// 绑定索引缓冲区
		GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));
		GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

		if (red > 1.0f) increment = -0.05f;
		else if (red < 0.0f) increment = 0.05f;
		red += increment;

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	GLCall(glDeleteProgram(shader));
	glfwTerminate();
	return 0;
}
```

## 详细说明



```
float vertices[] = {
	-0.5f, -0.5f, 0.0f,
	 0.5f, -0.5f, 0.0f,
	 0.5f,  0.5f, 0.0f,
	-0.5f,  0.5f, 0.0f,
};
unsigned int indices[] = {
		0, 1, 2,
		2, 3, 0
};
```



```cpp
	glewInit();// Reset OpenGLBuffer

	unsigned int VAO;
	glGenVertexArrays(1, &VAO);
	glBindVertexArray(VAO);	// vertex array object Bind to OpenGL
	unsigned int VBO;
	glGenBuffers(1, &VBO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO); // vertex buffer object Bind to OpenGL
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // Model import to GPU
	unsigned int IBO;
	glGenBuffers(1, &IBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, IBO); // index buffer object Bind to OpenGL
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // Model import to GPU

	while (!glfwWindowShouldClose(window))
	{
		ShortcutKey_ESC_Close(window);
		glClear(GL_COLOR_BUFFER_BIT);/* 指定缓冲区清除 */

		// glDrawArrays(GL_TRIANGLES, 0, 6); //得画6个点，冗余两个
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, NULL); // 画四个点

		glfwSwapBuffers(window);
		glfwPollEvents();
	}
```

