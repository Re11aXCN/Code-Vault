我们载入图像，在OpenGL中创建纹理，然后，当渲染的时候，我们必须绑定纹理，我们修改我们的着色器来绑定到那个纹理插槽，在着色器中对这个纹理采样，当我们绘制矩形时，我们应该看到纹理



![image-20240702181438292](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702181438292.png)

![image-20240702181445940](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702181445940.png)

它基本上允许你们指定这个slot,那就是你们想要绑定纹理的插槽

在Windows.上，典型的现代显卡，你们会有32个纹理插槽，移动显卡8个

![image-20240702181715072](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702181715072.png)

![image-20240702182924354](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702182924354.png)



内部格式也就是第一种格式，那是OpenGL存储纹理数据的格式

，而格式是纹理数据，是你们提供给OpenGL的数据格式，换句话说，也就是m_LocalBuffer的格式



![image-20240702183626321](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702183626321.png)

那么我们需要使用个叫做TextureCoordinateSystem的东西，告诉我们的几何图形，我们渲染的是纹理的哪一部分来采样，所以我们的像素着色器通过渲染并分解我们的矩形，对吧，只是遍历矩形并绘制每个像素，像素着色器或片段着色器负责确定每个像素的颜色，所以在某种程度上，我们真正需要做的是，在渲染某个像素的时候，告诉它对纹理的某个区域进行采样，以检索像素应该是什么颜色



结果图

![image-20240702184956472](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702184956472.png)



```cpp
// 如果不启用混合和设置合适的混合函数，OpenGL 将不会正确地混合新绘制的像素和已存在的像素。
		// 这会导致透明部分不显示或者显示不正确，通常表现为图像背景出现异常或者有方框之类的效果。 
		/**
		 * 混合:
		 * 将输出颜色(判断着色器输出的颜色)和目标缓冲区已有的颜色结合
		 * glEnable/glDisable(启用&关闭) => glBlendFunc(指定颜色因子) => glBlendEquation(指定混合模式)
		 * glBlendEquation(mode) mode: src和dest的混合方式(默认GL_FUNC_ADD, 叠加)
		 *
		 **/
		 /* 启用混合(默认不会启用,按照一个简单的覆盖方式渲染像素) */
		/* 意味着新绘制的像素会完全覆盖已经存在于目标缓冲区的像素，不考虑透明度。 */

		GLCall(glEnable(GL_BLEND));

		/**
		 * glBlendFunc(src, dest) 指定颜色因子
		 * src 指定输出颜色(RGBA)因子的计算方式, 默认为GL_ONE
		 * dest 指定目标颜色因子的计算方式, 默认为GL_ZERO
		 * GL_SRC_ALPHA 因为src的alpha为0, GL_ONE_MINUS_SRC_ALPHA 1-src.alpha
		 * RGBA = Srgba * GL_SRC_ALPHA + Drgba * GL_ONE_MINUS_SRC_ALPHA
		 **/
		GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
```

![image-20240702194230225](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702194230225.png)



### 代码

#### shader

```
#shader vertex
#version 330 core

layout(location = 0) in vec4 position;
layout(location = 1) in vec2 textCoord;

out vec2 v_TextCoord;

void main()
{
	gl_Position = position;
	v_TextCoord = textCoord;
};

#shader fragment
#version 330 core

layout(location = 0) out vec4 color;

in vec2 v_TextCoord;

uniform vec4 u_Color;
uniform sampler2D u_Texture;

void main()
{
	vec4 textColor = texture(u_Texture, v_TextCoord);
	color = textColor;
};
```

#### texture

```cpp
#pragma once

#include "Renderer.h"
/// <summary>
/// 文件加载纹理、设置纹理参数、绑定和解绑操作
/// </summary>
class Texture
{
private:
	unsigned int m_RendererID;
	std::string m_FilePath;
	unsigned char* m_LocalBuffer;
	int m_Width, m_Height, m_BPP;	// 宽高，像素位
public:
	Texture(const std::string& path);
	~Texture();

	void Bind(unsigned int slot = 0) const;
	void Unbind();

	inline int GetWidth() const { return m_Width; }
	inline int GetHeight() const { return m_Height; }
};

#include "Texture.h"
#include "vender/stb_image/stb_image.h"

Texture::Texture(const std::string& path)
	:m_RendererID(0), m_FilePath(path), m_LocalBuffer(nullptr), m_Width(0), m_Height(0), m_BPP(0)
{
	stbi_set_flip_vertically_on_load(1); // 垂直翻转纹理（OpenGL要求纹理从左下角开始）
	m_LocalBuffer = stbi_load(path.c_str(), &m_Width, &m_Height, &m_BPP, 4); /* 加载纹理数据，预期颜色通道RGBA->4 */

	// 生成、绑定纹理对象
	GLCall(glGenTextures(1, &m_RendererID));
	GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));

	// i->int,一定需要指定这四个纹理参数，否则得到黑色纹理
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
	GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));

	// 将图像数据传递给OpenGL，GL_RGBA8指定每个通道8比特
	GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));
	GLCall(glBindTexture(GL_TEXTURE_2D, 0));	// 解绑纹理对象

	if (m_LocalBuffer) {
		stbi_image_free(m_LocalBuffer);	// 释放图像数据内存
	}
}

Texture::~Texture()
{
	GLCall(glDeleteTextures(1, &m_RendererID));
}

void Texture::Bind(unsigned int slot) const
{
	GLCall(glActiveTexture(GL_TEXTURE0 + slot));
	GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));
}

void Texture::Unbind()
{
	GLCall(glBindTexture(GL_TEXTURE_2D, 0));
}

```

#### application

```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

#include "Renderer.h"
#include "IndexBuffer.h"
#include "VertexBuffer.h"
#include "VertexArray.h"
#include "VertexBufferLayout.h"
#include "Shader.h"
#include "Texture.h"

int main(void)
{
	GLFWwindow* window;
	if (!glfwInit()) return -1;
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);
	/**
	 * 交换间隔，交换缓冲区之前等待的帧数，通常称为v-sync
	 * 默认情况下，交换间隔为0
	 * 这里设置为1，即每帧更新一次
	 **/
	glfwSwapInterval(1);

	GLenum err = glewInit();
	if (GLEW_OK != err) {
		std::cout << "Error: " << glewGetErrorString(err) << std::endl;
	}
	std::cout << "Status: Using GLEW " << glewGetString(GLEW_VERSION) << std::endl;

	unsigned char* glVersion;
	GLCall(glVersion = (unsigned char*)glGetString(GL_VERSION));
	std::cout << "Status: Using GL " << glVersion << std::endl;

	{
		/*
		 * 定义顶点数据 positions 和索引数据 indices。
		 * positions 包含四个顶点的位置和纹理坐标。
		 * indices 指定了两个三角形的顶点顺序。
		 */
		float positions[] = {
			-0.5f, -0.5f, 0.0f, 0.0f,
			 0.5f, -0.5f, 1.0f, 0.0f,
			 0.5f,  0.5f, 1.0f, 1.0f,
			-0.5f,  0.5f, 0.0f, 1.0f
		};

		unsigned int indices[] = {
			0, 1, 2,
			2, 3, 0
		};

		// 如果不启用混合和设置合适的混合函数，OpenGL 将不会正确地混合新绘制的像素和已存在的像素。
		// 这会导致透明部分不显示或者显示不正确，通常表现为图像背景出现异常或者有方框之类的效果。 
		/**
		 * 混合:
		 * 将输出颜色(判断着色器输出的颜色)和目标缓冲区已有的颜色结合
		 * glEnable/glDisable(启用&关闭) => glBlendFunc(指定颜色因子) => glBlendEquation(指定混合模式)
		 * glBlendEquation(mode) mode: src和dest的混合方式(默认GL_FUNC_ADD, 叠加)
		 *
		 **/
		 /* 启用混合(默认不会启用,按照一个简单的覆盖方式渲染像素) */
		/* 意味着新绘制的像素会完全覆盖已经存在于目标缓冲区的像素，不考虑透明度。 */

		GLCall(glEnable(GL_BLEND));

		/**
		 * glBlendFunc(src, dest) 指定颜色因子
		 * src 指定输出颜色(RGBA)因子的计算方式, 默认为GL_ONE
		 * dest 指定目标颜色因子的计算方式, 默认为GL_ZERO
		 * GL_SRC_ALPHA 因为src的alpha为0, GL_ONE_MINUS_SRC_ALPHA 1-src.alpha
		 * RGBA = Srgba * GL_SRC_ALPHA + Drgba * GL_ONE_MINUS_SRC_ALPHA
		 **/
		GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));


		VertexArray va;
		VertexBuffer vb(positions, 4 * 4 * sizeof(float)); // sizeof(positions)
		VertexBufferLayout layout;
		layout.Push<float>(2);
		layout.Push<float>(2);
		va.AddBuffer(vb, layout);

		IndexBuffer ib(indices, 6);

		Shader shader("res/shaders/Basic.shader");
		shader.Bind();
		shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);

		Texture texture("res/textures/ChernoLogo.png");
		texture.Bind();
		shader.SetUniform1i("u_Texture", 0);

		// 解绑
		va.Unbind();
		shader.Unbind();
		vb.Unbind();
		ib.Unbind();
		Renderer renderer;

		float red = 0.0f;
		float increment = 0.05f;
		while (!glfwWindowShouldClose(window))
		{
			renderer.Clear();

			shader.Bind();
			shader.SetUniform4f("u_Color", red, 0.3f, 0.8f, 1.0f);

			// 绑定了顶点数组
			va.Bind();
			// 绑定索引缓冲区
			ib.Bind();
			renderer.Draw(va, ib, shader);

			if (red > 1.0f) increment = -0.05f;
			else if (red < 0.0f) increment = 0.05f;
			red += increment;

			glfwSwapBuffers(window);
			glfwPollEvents();
		}
	}
	glfwTerminate();
	return 0;
}
```



### 

### Shader代码解释

#### Vertex Shader (`Basic.shader`)

```glsl
#version 330 core

layout(location = 0) in vec4 position;
layout(location = 1) in vec2 textCoord;

out vec2 v_TextCoord;

void main()
{
    gl_Position = position;
    v_TextCoord = textCoord;
}
```

- `#version 330 core`: 声明使用OpenGL 3.3核心版本。
- `layout(location = 0) in vec4 position;`: 将顶点数据的位置信息输入到顶点着色器，位置信息存储在`position`变量中。
- `layout(location = 1) in vec2 textCoord;`: 将顶点数据的纹理坐标输入到顶点着色器，纹理坐标存储在`textCoord`变量中。
- `out vec2 v_TextCoord;`: 将计算后的纹理坐标传递给片段着色器，存储在`v_TextCoord`变量中。
- `gl_Position = position;`: 设置顶点的位置，将`position`中的位置数据直接赋值给内置变量`gl_Position`，这是顶点着色器中的特殊变量，用于指定顶点的位置。

#### Fragment Shader (`Basic.shader`)

```glsl
#version 330 core

layout(location = 0) out vec4 color;

in vec2 v_TextCoord;

uniform vec4 u_Color;
uniform sampler2D u_Texture;

void main()
{
    vec4 textColor = texture(u_Texture, v_TextCoord);
    color = textColor * u_Color;
}
```

- `#version 330 core`: 声明使用OpenGL 3.3核心版本。
- `layout(location = 0) out vec4 color;`: 片段着色器的输出变量，表示最终的颜色输出。
- `in vec2 v_TextCoord;`: 接收顶点着色器传递过来的纹理坐标。
- `uniform vec4 u_Color;`: 表示一个统一变量，即从CPU端发送到GPU端的常量数据，这里是一个颜色向量。
- `uniform sampler2D u_Texture;`: 表示一个统一变量，用于从纹理中采样颜色值的采样器对象。

- `vec4 textColor = texture(u_Texture, v_TextCoord);`: 使用纹理坐标 `v_TextCoord` 从纹理 `u_Texture` 中采样颜色值，存储在 `textColor` 中。
- `color = textColor * u_Color;`: 最终的片段颜色由采样到的纹理颜色 `textColor` 与统一变量 `u_Color` 相乘得到。这里的乘法可以用于对纹理颜色进行调整，比如乘以一个颜色向量来改变纹理的外观或应用光照效果。

### Shader代码逻辑解释

- **Vertex Shader**：负责处理顶点数据，将顶点位置传递给内置变量 `gl_Position`，将纹理坐标传递给片段着色器。
  
- **Fragment Shader**：负责处理片段（像素）数据，从输入的纹理坐标 `v_TextCoord` 中采样纹理 `u_Texture` 的颜色值。然后将采样到的纹理颜色与统一变量 `u_Color` 相乘，得到最终的片段颜色 `color`。

这两段Shader代码一起工作，实现了从顶点数据到片段颜色的转换过程。顶点着色器将输入的顶点数据映射到屏幕空间，片段着色器根据纹理坐标采样纹理并计算最终颜色输出，从而实现了基本的纹理渲染效果。

