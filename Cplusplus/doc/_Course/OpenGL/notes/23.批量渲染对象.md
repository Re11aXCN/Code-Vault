着色器也被openGL称为程序，字面上有一些着色程序，我们基本上是在告诉GPU该做什么，那非常重要



重新绑定一个不同的顶点缓冲区要比设置统一变量慢，其实不是这样的，把统一变量交给GPU实际上涉及到将数据从CPU传输到GPU



```
{
				glm::mat4 model = glm::translate(glm::mat4(1.0f), translationA);
				glm::mat4 mvp = proj * view * model;
				shader.Bind();
				shader.SetUniformMat4f("u_MVP", mvp);
				renderer.Draw(va, ib, shader);
			}

			{
				glm::mat4 model = glm::translate(glm::mat4(1.0f), translationB);
				glm::mat4 mvp = proj * view * model;
				shader.Bind();
				shader.SetUniformMat4f("u_MVP", mvp);
				renderer.Draw(va, ib, shader);
			}
```

如果你们在已绑定的着色器上调用BindShader，这有点多余，有点慢，有点浪费性能，通常是在更复杂的设置中，如真实游戏引擎或图像引擎，你们会有一个缓存系统，那就像挂起一分钟，你们试图绑定包绑定的着色器，那是多余的，cherno不会运行那个OpenGL调用



![image-20240702230306144](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240702230306144.png)

实际上，我们在这里所做的是，渲染了相同的对像两次,我们没有改变任何东西，除了一个统一变量，我们这样做的原因是因为我们想在实际屏幕上显示两个不同的位置如果你们有一个渲染1000个贴图在屏幕上的满循环，那將会非常慢，因为这是1000个绘制调用，并目就是那样的，但你们实际可以做些叫做批处理的在一个单独的绘制调用中绘制它，也就是把所有的贴图都塞进一个顶点缓冲区，然后不像cherno在这里做的那样，只修改统一变量而已，但不是有两个不同的顶点缓冲区，而是你们把它们都塞进一个顶点缓冲区，然后你们就可以一次渲染所有的东西，所有的点都已经在那里，因为顶点缓冲区非常大，它包含了你们拥有的每个贴图的所有位置，那比你们直接去绑定个着色器要快1000倍
