**显卡实际上做的一切东西都可以归结到三角形**

因为显卡倾向于使用三角形作为它们渲染一些原始的东西



正方形

```cpp
	float positions[] = {
		-0.5f, -0.5f,
		0.5f, 0.5f,
		0.5f, -0.5f,

		0.5f,0.5f,
		-0.5f,0.5f,
		-0.5f,-0.5f
	};
//...
glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);
//...
glDrawArrays(GL_TRIANGLES, 0, 6);
```

存在问题，有重复的顶点，冗余内存



解决如下：

![image-20240701181928562](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240701181928562.png)

```cpp
	float positions[] = {
		-0.5f, -0.5f,
		0.5f, -0.5f,
		0.5f, 0.5f,
		-0.5f,0.5f,
	};// 矩形缓冲区数组数据

	uint32_t indices[] = {
		0, 1, 2,
		2, 3, 0
	};

	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);

	uint32_t ibo;
	glGenBuffers(1, &ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

while{
    
    // 索引缓冲区函数
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);//注意必须是GL_UNSIGNED_INT无符号的不能够是GL_INT有符号的
}
		
```



完整代码

```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

// 定义一个结构体，用于存储顶点着色器和片段着色器的源代码  
struct ShaderProgramSource
{
	std::string VertexSource;  // 顶点着色器的源代码  
	std::string FragmentSource; // 片段着色器的源代码  
};

// 定义一个静态函数，用于从文件路径中解析并读取着色器源代码  
static ShaderProgramSource ParseShader(const std::string& filepath)
{
	// 使用文件流打开指定的文件  
	std::ifstream stream(filepath);

	// 定义一个枚举类，用于表示着色器的类型  
	enum class ShaderType
	{
		NONE = -1,     // 无类型（初始值）  
		VERTEX = 0,    // 顶点着色器  
		FRAGMENT = 1   // 片段着色器  
	};

	// 定义一个字符串变量，用于存储从文件中读取的每一行  
	std::string line;

	// 定义一个字符串流数组，用于分别存储顶点着色器和片段着色器的源代码  
	// 注意：这里使用数组而非两个独立的字符串流，是为了与ShaderType枚举相对应  
	std::stringstream ss[2];

	// 初始化着色器类型为NONE  
	ShaderType type = ShaderType::NONE;

	// 逐行读取文件内容  
	while (getline(stream, line))
	{
		// 检查当前行是否包含"#shader"字符串  
		if (line.find("#shader") != std::string::npos)
		{
			// 如果当前行同时包含"vertex"字符串，则将着色器类型设置为VERTEX  
			if (line.find("vertex") != std::string::npos)
				type = ShaderType::VERTEX;
			// 如果当前行同时包含"fragment"字符串，则将着色器类型设置为FRAGMENT  
			else if (line.find("fragment") != std::string::npos)
				type = ShaderType::FRAGMENT;
		}
		// 如果当前行不是定义着色器类型的行，则将其添加到对应的字符串流中  
		else
		{
			// 使用强制类型转换将ShaderType枚举值转换为数组索引  
			// 并将当前行（包括换行符）添加到对应的字符串流中  
			ss[(int)type] << line << "\n";
		}
	}

	// 返回一个ShaderProgramSource结构体，其中包含了从文件中读取的顶点着色器和片段着色器的源代码  
	return { ss[0].str(), ss[1].str() };
}

// 定义一个函数，用于编译一个着色器（顶点着色器或片段着色器）  
// 参数：  
//   type: 着色器的类型（GL_VERTEX_SHADER 或 GL_FRAGMENT_SHADER）  
//   source: 着色器的源代码（以字符串形式提供）  
// 返回值：  
//   如果编译成功，返回着色器的ID；如果失败，返回0  
static uint32_t CompileShader(uint32_t type, const std::string& source)
{
	// 创建一个着色器对象，并获取其ID  
	uint32_t id = glCreateShader(type);

	const char* src = source.c_str(); // 也可以使用 &source[0]  

	// 将源代码设置为着色器的源代码  , 并编译
	glShaderSource(id, 1, &src, nullptr); // 第一个参数是着色器ID，第二个参数是源代码的字符串数量（这里是1），第三个参数是指向源代码字符串的指针的数组，第四个参数是源代码字符串的长度（这里是nullptr，表示自动计算）   
	glCompileShader(id);

	// 检查着色器是否编译成功  
	int result;
	glGetShaderiv(id, GL_COMPILE_STATUS, &result); // 获取着色器的编译状态  

	if (result == GL_FALSE) // 如果编译失败  
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length); // 获取错误日志的长度  

		// char message[length];不允许不确定的值在栈内申请内存，换个思维
		char* message = (char*)alloca(length * sizeof(char));

		// 获取编译错误的详细信息  
		glGetShaderInfoLog(id, length, &length, message);

		std::cout << "Failed to compile shader!"
			<< (type == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< "shader!\n";
		std::cout << message << std::endl;

		// 删除着色器对象（因为编译失败了，所以不再需要它）  
		glDeleteShader(id);

		return 0;
	}

	return id;
}

// 定义一个函数，用于创建一个着色器程序（包括顶点着色器和片段着色器）  
// 参数：  
//   vertexShader: 顶点着色器的源代码  
//   fragmentShader: 片段着色器的源代码  
// 返回值：  
//   如果创建成功，返回着色器程序的ID；否则，行为是未定义的（因为CreateShader函数中没有明确的错误处理）  
static uint32_t CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	// 创建一个着色器程序对象，并获取其ID  
	uint32_t program = glCreateProgram();

	// 编译顶点着色器和片段着色器，并获取它们的ID  
	uint32_t vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
	uint32_t fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

	// 将编译好的着色器附加到着色器程序上  
	glAttachShader(program, vs);
	glAttachShader(program, fs);

	// 链接着色器程序（将顶点着色器和片段着色器连接成一个完整的着色器程序）  
	glLinkProgram(program);

	// 验证着色器程序（检查着色器程序是否按预期工作）  
	glValidateProgram(program); // 注意：验证不是必须的，但它可以帮助你在运行时发现可能的错误  

	// 删除顶点着色器和片段着色器对象（因为它们已经被链接到了着色器程序中，所以不再需要单独的对象）  
	glDeleteShader(vs);
	glDeleteShader(fs);

	// 返回着色器程序的ID  
	return program;
}

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;

	float positions[] = {
		-0.5f, -0.5f,
		0.5f, -0.5f,
		0.5f, 0.5f,
		-0.5f,0.5f,
	};// 矩形缓冲区数组数据

	uint32_t indices[] = {
		0, 1, 2,
		2, 3, 0
	};

	uint32_t buffer;
	// 可以设置多个缓冲区，这里设置1个缓存区
	// 传入这个unsigned int的内存地址，现在，这就是生成的缓冲区的id
	glGenBuffers(1, &buffer);
	// 并且选择(selecting)缓冲区的id在OpenGL中称为绑定(binding) : 所以输入glBindBuffer()
	glBindBuffer(GL_ARRAY_BUFFER, buffer);
	// 指定缓冲区大小
	/*
	void glBufferData( 	GLenum target,
						GLsizeiptr size,
						const GLvoid * data,
						GLenum usage);
	*/
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW); // 或者 6 * sizeof(float)

	/* 布局代码 */
	// 启动索引0
	glEnableVertexAttribArray(0);
	/*
	index	:索引缓冲区 ,			size		:组件数量和字节无关，每个坐标有几个浮点数就是几，三角形二维坐标两个
	type	:类型,		normalize	:标准化，已经是浮点数了设置为flase
	stride	:两点之间的距离——字节数，二维坐标float，相差8
	pointer	:属性偏移，二维坐标这里没有属性设置0，如果有属性，
			二维坐标-0.5f, -0.5f, 0.5f（纹理坐标），那么偏移就是8, 2 * float，那么应该设置为(const void*)8
			这不是最好的办法，实际采用结构体，设置宏偏移量
	*/
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);

	uint32_t ibo;
	glGenBuffers(1, &ibo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);


	ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");

	uint32_t shader = CreateShader(source.VertexSource, source.FragmentSource);
	glUseProgram(shader);

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		// 没有索引缓冲区的方法
		/*
		first:绘制图像mode-三角形，second:起始顶点（数组下标三个任选一个）,third:顶点数量
		*/
		//glDrawArrays(GL_TRIANGLES, 0, 6);
		// 索引缓冲区函数
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);

#define GL_TRADITION 0
#if GL_TRADITION
		/*画一个三角形*/
		glBegin(GL_TRIANGLES);
		glVertex2f(-0.5f, -0.5f);
		glVertex2f(0.0f, 0.5f);
		glVertex2f(0.5f, -0.5f);
		glEnd();
#endif // 0

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glDeleteProgram(shader);

	glfwTerminate();
	return 0;
}
```

