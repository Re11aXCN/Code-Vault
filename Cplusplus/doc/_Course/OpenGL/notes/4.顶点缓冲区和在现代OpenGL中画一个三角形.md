传统opengl，glfw，五行代码搞定画三角形



现在使用现代opengl，glew画三角形，首先，我们需要能够创建个顶点缓冲区，然后还要创建一个着色器

### 顶点缓冲区

顶点缓冲区，它基本上就是去掉vertex这个单词，它只是一个缓冲区，一个内存缓冲区，云个内存字节数组，那是它的本质，只是个缓冲区，它就是一块用来存字节的内存。存字节的。

但顶点缓冲区跟C+中像字符数组的内存缓冲区不太一样，区别在于。它是OpenGL中的内存缓冲区，这意味着它实际上在显卡上，在我们的RAM(显存)中。也就是Video RAM

所以我要把三角形放入显卡的VRAM中，然后还需要发出DrawCall指令，嘿，显存中有一堆数据读取它，并且把它绘制在屏幕上，实际上，我们还需要告诉显卡，如何读取和解释这些数据，以及如何把它放到我们屏幕上。

当我们在CPU这边做了所有的事情，我们用C++写的东西都隄在CPU上运行的，还要用某种方法告诉显卡，一旦从CPU发出了DrawCall指令，一旦我们发出那个指令，希望显卡在屏幕上给我显示一个三角形，所以需要对显卡编程，并且，那就是着色器

### 着色器

着色器是一个运行在显卡上的程序，是一堆我们可以编写的可以在显卡上运行的代码



opengl是一个状态机，这就是它的运行方式



传统的opengl绘制在while循环中每帧都得绘制，现代opengl设置缓冲区后存储数据后在绘制

记住OpenGL作为一个状态机工作，这意味着，一所有你们生成的…再说一次，这是与上下文相关的，所以，我的意思是，上下文会有自己的流缓冲区会有自己的流，但你们在OpenGL中生成的所有东西都会被分配旷个唯广的标识符，它只是一个整数，比如0、1、2，0通常是无状态

opengl函数文档查看https://docs.gl/gl4/glBufferData

static绘制一次多次使用

dynamic数据内容被反复修改和多次使用

![image-20240630212833706](C:\Users\Re11a\Desktop\c++资料\ChernoOpenGL-master\notes\assets\image-20240630212833706.png)

这意味着是如果我声明它为STATIC,然后绘制它，但我实际上每帧都更新缓冲它还是会运行的，可能会慢很多

```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	if (glewInit() != GLEW_OK);
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;

	float positions[6] = {
		-0.5f, -0.5f,
		0.0f, 0.5f,
		0.5f, -0.5f
	};// 三角形缓冲区数组数据

	uint32_t buffer;
	// 可以设置多个缓冲区，这里设置1个缓存区
	// 传入这个unsigned int的内存地址，现在，这就是生成的缓冲区的id
	glGenBuffers(1, &buffer);
	// 并且选择(selecting)缓冲区的id在OpenGL中称为绑定(binding) : 所以输入glBindBuffer()
	glBindBuffer(GL_ARRAY_BUFFER, buffer);
	// 指定缓冲区大小
	/*
	void glBufferData( 	GLenum target,
						GLsizeiptr size,
						const GLvoid * data,
						GLenum usage);
	*/
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW); // 或者 6 * sizeof(float)


	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		// 没有索引缓冲区的方法
		/*
		first:绘制图像mode-三角形，second:起始顶点（数组下标三个任选一个）,third:顶点数量
		*/
		glDrawArrays(GL_TRIANGLES, 0, 3);
		// 索引缓冲区函数
		//glDrawElements(GL_TRIANGLES, 0, 3);

#define GL_TRADITION 0
#if GL_TRADITION
		/*画一个三角形*/
		glBegin(GL_TRIANGLES);
		glVertex2f(-0.5f, -0.5f);
		glVertex2f(0.0f, 0.5f);
		glVertex2f(0.5f, -0.5f);
		glEnd();
#endif // 0

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glfwTerminate();
	return 0;
}
```

