着色器需要什么，首先,我们基本上希望能够传递二个文件或一个字符串，把它作为着色器来编译，所以那就是第一步，我们希望能够绑定和解绑定着色器，这是第二步，第三步就是我们需要能够设置着色器中各种不同的统一变量



这里只是简单实现，而不是实现游戏引擎，需要设置一些模板化的东西，然后需要实际处理它自己的东西

游戏引擎需要setvalue、setuniforms，实际上你可以直接传入着色器源码去计算出一个统一类型变量是什么，你所需要的只是名称和值，它会自动设置正确的数据等等



```cpp
unsigned int Shader::GetUniformLocation(const std::string& name) const
{
	GLCall(location = glGetUniformLocation(m_RendererID, name.c_str()));
	if (location == -1) {
		std::cout << "Warning: uniform '" << name << "' doesn't exist" << std::endl;
	}
	return location;
}
```

每次我们设置这个统一变量

```cpp
void Shader::SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3)
{

	GLCall(glUniform4f(GetUniformLocation(name), v0, v1, v2, v3)); /* 设置对应的统一变量 */
}
```

我们实际上一次又次地获取这个位置，并不是特别的快，我们真正想做的是缓存它，利用`mutable std::unordered_map<std::string, int> m_UniformlocationCache;`缓存

完整代码

```cpp
unsigned int Shader::GetUniformLocation(const std::string& name) const
{
	if (m_UniformlocationCache.find(name) != m_UniformlocationCache.end()) {
		return m_UniformlocationCache[name];	// 第二次直接获取，第一次缓存不命中缓存
	}
	int location;
	GLCall(location = glGetUniformLocation(m_RendererID, name.c_str()));
	if (location == -1) {
		std::cout << "Warning: uniform '" << name << "' doesn't exist" << std::endl;
	}

	m_UniformlocationCache[name] = location;
	return location;
}
```



## 代码

### shader

```cpp
#pragma once
#include <string>
#include <unordered_map>

//#include "glm/glm.hpp"

struct ShaderProgramSource
{
	std::string VertexSource;
	std::string FragmentSource;
};

class Shader
{
public:
	Shader(const std::string& filepath);
	~Shader();

	void Bind() const;
	void Unbind() const;
	void SetUniform1i(const std::string& name, int value);
	void SetUniform1f(const std::string& name, float value);
	void SetUniform1iv(const std::string& name, int count, int* value);
	void SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3);
	//void SetUniformMat4f(const std::string& name, const glm::mat4& matrix);
private:
	ShaderProgramSource ParseShader(const std::string& filepath);
	unsigned int CompileShader(unsigned int type, const std::string& source);
	unsigned int CreateShader(const std::string& vertexShader, const std::string& fragmentShader);
	unsigned int GetUniformLocation(const std::string& name) const;
private:
	unsigned int m_RendererID;
	std::string m_FilePath;
	mutable std::unordered_map<std::string, int> m_UniformlocationCache;

};

#include "Shader.h"
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include "Renderer.h"

Shader::Shader(const std::string& filepath)
	:m_FilePath(filepath), m_RendererID(0)
{
	/* 从文件中解析着色器源码 */
	ShaderProgramSource source = ParseShader(filepath);
	m_RendererID = CreateShader(source.VertexSource, source.FragmentSource);
}

Shader::~Shader()
{
	GLCall(glDeleteProgram(m_RendererID));
}

void Shader::Bind() const
{
	GLCall(glUseProgram(m_RendererID));
}

void Shader::Unbind() const
{
	GLCall(glUseProgram(0));
}

void Shader::SetUniform1i(const std::string& name, int value)
{
	GLCall(glUniform1i(GetUniformLocation(name), value));
}

void Shader::SetUniform1f(const std::string& name, float value)
{
	GLCall(glUniform1f(GetUniformLocation(name), value));
}

void Shader::SetUniform1iv(const std::string& name, int count, int* value)
{
	GLCall(glUniform1iv(GetUniformLocation(name), count, value));
}

void Shader::SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3)
{

	GLCall(glUniform4f(GetUniformLocation(name), v0, v1, v2, v3)); /* 设置对应的统一变量 */
}

//void Shader::SetUniformMat4f(const std::string& name, const glm::mat4& matrix)
//{
//	GLCall(glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &matrix[0][0]));
//}

ShaderProgramSource Shader::ParseShader(const std::string& filepath)
{
	std::ifstream stream(filepath);/* 这里没判断文件是否能正常打开 is_open */

	enum class ShaderType
	{
		NONE = -1,     // 无类型（初始值）  
		VERTEX = 0,    // 顶点着色器  
		FRAGMENT = 1   // 片段着色器  
	};

	std::string line;
	std::stringstream ss[2];
	ShaderType type = ShaderType::NONE;

	while (getline(stream, line))
	{
		if (line.find("#shader") != std::string::npos)/* 找到#shader标记 */
		{
			if (line.find("vertex") != std::string::npos)/* 顶点着色器标记 */
				type = ShaderType::VERTEX;
			else if (line.find("fragment") != std::string::npos)/* 片段着色器标记 */
				type = ShaderType::FRAGMENT;
		}
		else
		{
			ss[(int)type] << line << "\n";
		}
	}
	return { ss[0].str(), ss[1].str() };
}

unsigned int Shader::CompileShader(unsigned int type, const std::string& source)
{
	unsigned int id;
	GLCall(id = glCreateShader(type));
	const char* src = source.c_str(); // 也可以使用 &source[0]  
	GLCall(glShaderSource(id, 1, &src, nullptr));/* 设置着色器源码 */
	GLCall(glCompileShader(id));

	int result;
	GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &result));
	if (result == GL_FALSE)
	{
		int length;
		GLCall(glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length));

		// char message[length];不允许不确定的值在栈内申请内存，换个思维
		char* message = (char*)_malloca(length * sizeof(char));

		GLCall(glGetShaderInfoLog(id, length, &length, message));

		std::cout << "Failed to compile shader!"
			<< (type == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< "shader!\n";
		std::cout << message << std::endl;

		GLCall(glDeleteShader(id));

		return 0;
	}

	return id;
}

unsigned int Shader::CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	unsigned int program;
	GLCall(program = glCreateProgram());/* 创建程序 */

	unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
	unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

	/* 将着色器附加到程序上 */
	GLCall(glAttachShader(program, vs));
	GLCall(glAttachShader(program, fs));
	GLCall(glLinkProgram(program));
	GLCall(glValidateProgram(program));/* 验证 */

	GLCall(glDeleteShader(vs));
	GLCall(glDeleteShader(fs));

	return program;
}

unsigned int Shader::GetUniformLocation(const std::string& name) const
{
	if (m_UniformlocationCache.find(name) != m_UniformlocationCache.end()) {
		return m_UniformlocationCache[name];
	}
	int location;
	GLCall(location = glGetUniformLocation(m_RendererID, name.c_str()));
	if (location == -1) {
		std::cout << "Warning: uniform '" << name << "' doesn't exist" << std::endl;
	}

	m_UniformlocationCache[name] = location;
	return location;
}

```

### applica

```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

#include "Renderer.h"
#include "IndexBuffer.h"
#include "VertexBuffer.h"
#include "VertexArray.h"
#include "VertexBufferLayout.h"
#include "Shader.h"

int main(void)
{
	GLFWwindow* window;

	if (!glfwInit())
		return -1;

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	glfwMakeContextCurrent(window);

	glfwSwapInterval(1);

	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;
	{
		float positions[] = {
			-0.5f, -0.5f,
			0.5f, -0.5f,
			0.5f, 0.5f,
			-0.5f,0.5f,
		};

		unsigned int indices[] = {
			0, 1, 2,
			2, 3, 0
		};

		// core核心配置需要做的存储顶点对象
		unsigned int vao;
		GLCall(glGenVertexArrays(1, &vao));
		GLCall(glBindVertexArray(vao));

		VertexArray va;
		VertexBuffer vb(positions, 4 * 2 * sizeof(float)); // sizeof(positions)

		VertexBufferLayout layout;
		layout.Push<float>(2);
		va.AddBuffer(vb, layout);

		IndexBuffer ib(indices, 6);

		Shader shader("res/shaders/Basic.shader");
		shader.Bind();
		shader.SetUniform4f("u_Color", 0.8f, 0.3f, 0.8f, 1.0f);

		// 解绑
		va.Unbind();
		shader.Unbind();
		vb.Unbind();
		ib.Unbind();

		float red = 0.0f;
		float increment = 0.05f;
		while (!glfwWindowShouldClose(window))
		{
			glClear(GL_COLOR_BUFFER_BIT);

			shader.Bind();
			shader.SetUniform4f("u_Color", red, 0.3f, 0.8f, 1.0f);

			// 绑定了顶点数组
			va.Bind();
			// 绑定索引缓冲区
			ib.Bind();
			GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

			if (red > 1.0f) increment = -0.05f;
			else if (red < 0.0f) increment = 0.05f;
			red += increment;

			glfwSwapBuffers(window);
			glfwPollEvents();
		}
	}
	glfwTerminate();
	return 0;
}
```

