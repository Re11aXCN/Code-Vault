定义一个static的createShader方法不希望它能够链接到其他单元文件

```cpp
// 定义一个函数，用于编译一个着色器（顶点着色器或片段着色器）  
// 参数：  
//   type: 着色器的类型（GL_VERTEX_SHADER 或 GL_FRAGMENT_SHADER）  
//   source: 着色器的源代码（以字符串形式提供）  
// 返回值：  
//   如果编译成功，返回着色器的ID；如果失败，返回0  
static uint32_t CompileShader(uint32_t type, const std::string& source)
{
	// 创建一个着色器对象，并获取其ID  
	uint32_t id = glCreateShader(type);

	const char* src = source.c_str(); // 也可以使用 &source[0]  

	// 将源代码设置为着色器的源代码  , 并编译
	glShaderSource(id, 1, &src, nullptr); // 第一个参数是着色器ID，第二个参数是源代码的字符串数量（这里是1），第三个参数是指向源代码字符串的指针的数组，第四个参数是源代码字符串的长度（这里是nullptr，表示自动计算）   
	glCompileShader(id);

	// 检查着色器是否编译成功  
	int result;
	glGetShaderiv(id, GL_COMPILE_STATUS, &result); // 获取着色器的编译状态  

	if (result == GL_FALSE) // 如果编译失败  
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length); // 获取错误日志的长度  

		// char message[length];不允许不确定的值在栈内申请内存，换个思维
		char* message = (char*)alloca(length * sizeof(char));

		// 获取编译错误的详细信息  
		glGetShaderInfoLog(id, length, &length, message);

		std::cout << "Failed to compile shader!"
			<< (type == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< "shader!\n";
		std::cout << message << std::endl;

		// 删除着色器对象（因为编译失败了，所以不再需要它）  
		glDeleteShader(id);

		return 0;
	}

	return id;
}

// 定义一个函数，用于创建一个着色器程序（包括顶点着色器和片段着色器）  
// 参数：  
//   vertexShader: 顶点着色器的源代码  
//   fragmentShader: 片段着色器的源代码  
// 返回值：  
//   如果创建成功，返回着色器程序的ID；否则，行为是未定义的（因为CreateShader函数中没有明确的错误处理）  
static uint32_t CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	// 创建一个着色器程序对象，并获取其ID  
	uint32_t program = glCreateProgram();

	// 编译顶点着色器和片段着色器，并获取它们的ID  
	uint32_t vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
	uint32_t fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

	// 将编译好的着色器附加到着色器程序上  
	glAttachShader(program, vs);
	glAttachShader(program, fs);

	// 链接着色器程序（将顶点着色器和片段着色器连接成一个完整的着色器程序）  
	glLinkProgram(program);

	// 验证着色器程序（检查着色器程序是否按预期工作）  
	glValidateProgram(program); // 注意：验证不是必须的，但它可以帮助你在运行时发现可能的错误  

	// 删除顶点着色器和片段着色器对象（因为它们已经被链接到了着色器程序中，所以不再需要单独的对象）  
	glDeleteShader(vs);
	glDeleteShader(fs);

	// 返回着色器程序的ID  
	return program;
}

/**main内部************************************/

	// core 不使用任何弃用函数
	// location = 0和我们之前设置的索引应该保持一致
	// 虽然glVertexAttribPointer上述我们设置ver是2 但gl_Position是ver4，所以in ver4
	std::string vertexShader =
		"#version 330 core\n"
		"\n"
		"layout(location = 0) in vec4 position;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	gl_Position = position;\n"
		"}\n";

	// RGBA
	std::string fragmentShader =
		"#version 330 core\n"
		"\n"
		"layout(location = 0) out vec4 color;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	color = vec4(1.0, 0.0, 0.0, 1.0);\n"
		"}\n";

	uint32_t shader = CreateShader(vertexShader, fragmentShader);
	glUseProgram(shader);
```

我们需要向OpenGL提供我们实际的着色器源代码，我们想让OpenGL编译那个程序，将这两个链接到个独立的着色器程序，然后给我们一些那个着色器返回的唯一标识符，这样我们就能绑定那个着色器并使用它

https://docs.gl/gl4/glShaderSource



它们真的没有必要去清理，因为它占用的内存量很小，是保留源码的着色器是非常重要的，当你在处理像图形深度实体的时候

——————————————————————————

当然可以。着色器源码字符串 `vertexShader` 和 `fragmentShader` 分别定义了顶点着色器（Vertex Shader）和片段着色器（Fragment Shader）的程序。这两个着色器是图形渲染管线中的关键部分，它们负责处理顶点数据和生成像素颜色。

### 顶点着色器（Vertex Shader）

顶点着色器（`vertexShader`）负责处理顶点数据。它读取每个顶点的属性（如位置、颜色、纹理坐标等），然后对这些顶点进行变换，通常包括模型、视图和投影变换，最终输出变换后的顶点位置。

在您的代码中，顶点着色器源码如下：

```glsl
#version 330 core

layout(location = 0) in vec4 position;

void main()
{
    gl_Position = position;
}
```

- `#version 330 core`：这一行指定了GLSL的版本（这里是3.30版的核心模式）。
- `layout(location = 0) in vec4 position;`：这一行定义了一个输入变量 `position`，它是一个四维向量（`vec4`），通常用于表示顶点的位置。`layout(location = 0)` 指定了这个输入变量在顶点数据中的位置索引，这样OpenGL就知道如何从顶点数组中读取这个数据。
- `void main() {...}`：这是顶点着色器的主函数。在这个函数中，它直接将输入的 `position` 赋值给 `gl_Position`，`gl_Position` 是一个内置的输出变量，表示变换后的顶点位置。

### 片段着色器（Fragment Shader）

片段着色器（`fragmentShader`）负责处理像素级别的数据，它决定了屏幕上每个像素的最终颜色。

在您的代码中，片段着色器源码如下：

```glsl
#version 330 core

layout(location = 0) out vec4 color;

void main()
{
    color = vec4(1.0, 0.0, 0.0, 1.0);
}
```

- `#version 330 core`：同样指定了GLSL的版本。
- `layout(location = 0) out vec4 color;`：这一行定义了一个输出变量 `color`，它是一个四维向量，用于表示像素的颜色（包括RGBA四个分量）。然而，对于片段着色器的输出，`layout(location = 0)` 实际上并不是必需的，因为片段着色器通常只有一个颜色输出，并且它默认就是 `location = 0`。但在这里写上也没有问题，可以明确指定输出的位置。
- `void main() {...}`：这是片段着色器的主函数。在这个函数中，它将一个固定的红色值（`vec4(1.0, 0.0, 0.0, 1.0)`）赋给 `color`，这意味着无论屏幕上的哪个像素，它都将被渲染为红色。

### 为什么这样写

- **版本指定**：指定GLSL版本是为了确保代码在特定的OpenGL版本和模式下能够正确运行。
- **输入/输出变量**：通过定义输入和输出变量，着色器能够接收来自顶点数据或上一个着色器的数据，并产生输出数据供下一个着色器或OpenGL渲染管线使用。
- **主函数**：`main` 函数是着色器的入口点，它包含了处理顶点或像素的主要逻辑。
- **内置变量**：如 `gl_Position`（在顶点着色器中）是OpenGL定义的内置变量，用于存储变换后的顶点位置。
- **简洁性**：上述着色器代码非常简洁，它们只展示了着色器的基本结构和功能。在实际应用中，着色器可能会包含更复杂的逻辑和计算。



```cpp
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <iostream>

// 定义一个函数，用于编译一个着色器（顶点着色器或片段着色器）  
// 参数：  
//   type: 着色器的类型（GL_VERTEX_SHADER 或 GL_FRAGMENT_SHADER）  
//   source: 着色器的源代码（以字符串形式提供）  
// 返回值：  
//   如果编译成功，返回着色器的ID；如果失败，返回0  
static uint32_t CompileShader(uint32_t type, const std::string& source)
{
	// 创建一个着色器对象，并获取其ID  
	uint32_t id = glCreateShader(type);

	const char* src = source.c_str(); // 也可以使用 &source[0]  

	// 将源代码设置为着色器的源代码  , 并编译
	glShaderSource(id, 1, &src, nullptr); // 第一个参数是着色器ID，第二个参数是源代码的字符串数量（这里是1），第三个参数是指向源代码字符串的指针的数组，第四个参数是源代码字符串的长度（这里是nullptr，表示自动计算）   
	glCompileShader(id);

	// 检查着色器是否编译成功  
	int result;
	glGetShaderiv(id, GL_COMPILE_STATUS, &result); // 获取着色器的编译状态  

	if (result == GL_FALSE) // 如果编译失败  
	{
		int length;
		glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length); // 获取错误日志的长度  

		// char message[length];不允许不确定的值在栈内申请内存，换个思维
		char* message = (char*)alloca(length * sizeof(char));

		// 获取编译错误的详细信息  
		glGetShaderInfoLog(id, length, &length, message);

		std::cout << "Failed to compile shader!"
			<< (type == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< "shader!\n";
		std::cout << message << std::endl;

		// 删除着色器对象（因为编译失败了，所以不再需要它）  
		glDeleteShader(id);

		return 0;
	}

	return id;
}

// 定义一个函数，用于创建一个着色器程序（包括顶点着色器和片段着色器）  
// 参数：  
//   vertexShader: 顶点着色器的源代码  
//   fragmentShader: 片段着色器的源代码  
// 返回值：  
//   如果创建成功，返回着色器程序的ID；否则，行为是未定义的（因为CreateShader函数中没有明确的错误处理）  
static uint32_t CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
	// 创建一个着色器程序对象，并获取其ID  
	uint32_t program = glCreateProgram();

	// 编译顶点着色器和片段着色器，并获取它们的ID  
	uint32_t vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
	uint32_t fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

	// 将编译好的着色器附加到着色器程序上  
	glAttachShader(program, vs);
	glAttachShader(program, fs);

	// 链接着色器程序（将顶点着色器和片段着色器连接成一个完整的着色器程序）  
	glLinkProgram(program);

	// 验证着色器程序（检查着色器程序是否按预期工作）  
	glValidateProgram(program); // 注意：验证不是必须的，但它可以帮助你在运行时发现可能的错误  

	// 删除顶点着色器和片段着色器对象（因为它们已经被链接到了着色器程序中，所以不再需要单独的对象）  
	glDeleteShader(vs);
	glDeleteShader(fs);

	// 返回着色器程序的ID  
	return program;
}

int main(void)
{
	GLFWwindow* window;

	/* Initialize the library */
	if (!glfwInit())
		return -1;

	/* Create a windowed mode window and its OpenGL context */
	window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		return -1;
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);

	if (glewInit() != GLEW_OK)
	{
		std::cout << "Error!\n";
	}

	std::cout << glGetString(GL_VERSION) << std::endl;

	float positions[6] = {
		-0.5f, -0.5f,
		0.0f, 0.5f,
		0.5f, -0.5f
	};// 三角形缓冲区数组数据

	uint32_t buffer;
	// 可以设置多个缓冲区，这里设置1个缓存区
	// 传入这个unsigned int的内存地址，现在，这就是生成的缓冲区的id
	glGenBuffers(1, &buffer);
	// 并且选择(selecting)缓冲区的id在OpenGL中称为绑定(binding) : 所以输入glBindBuffer()
	glBindBuffer(GL_ARRAY_BUFFER, buffer);
	// 指定缓冲区大小
	/*
	void glBufferData( 	GLenum target,
						GLsizeiptr size,
						const GLvoid * data,
						GLenum usage);
	*/
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW); // 或者 6 * sizeof(float)

	/* 布局代码 */
	// 启动索引0
	glEnableVertexAttribArray(0);
	/*
	index	:索引缓冲区 ,			size		:组件数量和字节无关，每个坐标有几个浮点数就是几，三角形二维坐标两个
	type	:类型,		normalize	:标准化，已经是浮点数了设置为flase
	stride	:两点之间的距离——字节数，二维坐标float，相差8
	pointer	:属性偏移，二维坐标这里没有属性设置0，如果有属性，
			二维坐标-0.5f, -0.5f, 0.5f（纹理坐标），那么偏移就是8, 2 * float，那么应该设置为(const void*)8
			这不是最好的办法，实际采用结构体，设置宏偏移量
	*/
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);

	// core 不使用任何弃用函数
	// location = 0和我们之前设置的索引应该保持一致
	// 虽然glVertexAttribPointer上述我们设置ver是2 但gl_Position是ver4，所以in ver4
	std::string vertexShader =
		"#version 330 core\n"
		"\n"
		"layout(location = 0) in vec4 position;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	gl_Position = position;\n"
		"}\n";

	// RGBA
	std::string fragmentShader =
		"#version 330 core\n"
		"\n"
		"layout(location = 0) out vec4 color;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	color = vec4(1.0, 0.0, 0.0, 1.0);\n"
		"}\n";

	uint32_t shader = CreateShader(vertexShader, fragmentShader);
	glUseProgram(shader);

	/* Loop until the user closes the window */
	while (!glfwWindowShouldClose(window))
	{
		/* Render here */
		glClear(GL_COLOR_BUFFER_BIT);

		// 没有索引缓冲区的方法
		/*
		first:绘制图像mode-三角形，second:起始顶点（数组下标三个任选一个）,third:顶点数量
		*/
		glDrawArrays(GL_TRIANGLES, 0, 3);
		// 索引缓冲区函数
		//glDrawElements(GL_TRIANGLES, 0, 3);

#define GL_TRADITION 0
#if GL_TRADITION
		/*画一个三角形*/
		glBegin(GL_TRIANGLES);
		glVertex2f(-0.5f, -0.5f);
		glVertex2f(0.0f, 0.5f);
		glVertex2f(0.5f, -0.5f);
		glEnd();
#endif // 0

		/* Swap front and back buffers */
		glfwSwapBuffers(window);

		/* Poll for and process events */
		glfwPollEvents();
	}

	glDeleteShader(shader);

	glfwTerminate();
	return 0;
}
```

### 详细说明

#### 着色器cpp代码

```cpp
	unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); // ShaderCode Import
	glCompileShader(vertexShader);
	CheckShaderCompileStatus(&vertexShader);

	unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); // ShaderCode Import
	glCompileShader(fragmentShader);
	CheckShaderCompileStatus(&fragmentShader);

	unsigned int program = glCreateProgram();
	glAttachShader(program, vertexShader);
	glAttachShader(program, fragmentShader);
	glLinkProgram(program);
	CheckProgramLinkStatus(&program);
	glUseProgram(program);
	// 不需要了就删除
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);
```

