# MSVC并发运行时和并行模式库

# <agents.h> 详解

## 概述

`<agents.h>` 是 Microsoft Visual C++ 并发运行时库的重要组成部分，提供了基于消息传递的并发编程模型。它包含了一系列用于构建异步代理、数据流网络和并行处理管道的组件。

## 主要功能

- **消息传递**：提供类型安全的消息传递机制，在不同组件间传递数据
- **数据流处理**：构建数据处理管道
- **异步代理**：创建独立执行的异步任务
- **同步原语**：协调并发操作
- **模式库**：提供常用并发模式的实现
- **消息块**：预定义的消息处理组件
- **选择机制**：在多个消息源之间进行选择

## 核心类详解

### 基础类型和工具类

#### `runtime_object_identity`
```cpp
typedef __int32 runtime_object_identity;
```
消息的唯一标识符类型。

#### `_Runtime_object`
```cpp
class _Runtime_object : public _AllocBase
```
运行时对象基类，提供对象标识功能。

### 消息相关类

#### `message<T>`
```cpp
template<class _Type>
class message : public ::Concurrency::details::_Runtime_object
```
消息容器类，封装要传递的数据，包含唯一的消息ID，提供引用计数和生命周期管理。

**主要方法：**

- `msg_id()`: 获取消息ID
- `add_ref()`/`remove_ref()`: 引用计数管理
- `payload`: 消息负载数据

#### `message_status`
```cpp
enum message_status
{
    accepted,   // 消息被接受
    declined,   // 消息被拒绝
    postponed,  // 消息被推迟
    missed      // 消息丢失
};
```
消息处理状态枚举。

### 消息处理器

#### `message_processor<T>`
```cpp
template<class _Type>
class message_processor
```
消息处理器的抽象基类。

#### `ordered_message_processor<T>`
```cpp
template<class _Type>
class ordered_message_processor : public message_processor<_Type>
```
有序消息处理器，保证消息处理顺序。

### 接口类

#### `ISource<T>`
```cpp
template<class _Type>
class ISource
```
消息源接口，定义消息提供者的行为（接受、消费、释放等操作），支持链接目标。

**主要方法：**
- `link_target()`: 链接目标
- `accept()`: 接受消息
- `reserve()`/`consume()`/`release()`: 消息预留机制

#### `ITarget<T>`
```cpp
template<class _Type>
class ITarget
```
消息目标接口，定义消息消费者的行为（消息传播和发送操作），支持链接源。

**主要方法：**
- `propagate()`: 传播消息
- `send()`: 发送消息
- `supports_anonymous_source()`: 是否支持匿名源

### 链接管理

#### `network_link_registry<Block>`
```cpp
template<class _Block>
class network_link_registry
```
网络链接注册表基类。

#### `single_link_registry<Block>`
```cpp
template<class _Block>
class single_link_registry : public network_link_registry<_Block>
```
单链接注册表，只允许一个连接。

#### `multi_link_registry<Block>`
```cpp
template<class _Block>
class multi_link_registry : public network_link_registry<_Block>
```
多链接注册表，允许多个连接。

### 核心消息块

#### `target_block<SourceLinkRegistry>`
```cpp
template<class _SourceLinkRegistry>
class target_block : public ITarget<typename _SourceLinkRegistry::type::source_type>
```
目标块基类，处理输入消息。

#### `source_block<TargetLinkRegistry>`
```cpp
template<class _TargetLinkRegistry>
class source_block : public ISource<typename _TargetLinkRegistry::type::type>
```
源块基类，产生输出消息。

#### `propagator_block<TargetLinkRegistry, SourceLinkRegistry>`
```cpp
template<class _TargetLinkRegistry, class _SourceLinkRegistry>
class propagator_block : public source_block<_TargetLinkRegistry>, 
                         public ITarget<typename _SourceLinkRegistry::type::source_type>
```
传播块基类，既是源又是目标。

### 具体消息块实现

#### `unbounded_buffer<T>`
```cpp
template<class _Type>
class unbounded_buffer : public propagator_block<multi_link_registry<ITarget<_Type>>, 
                                                 multi_link_registry<ISource<_Type>>>
```
无界缓冲区——先进先出（FIFO）消息队列，存储任意数量的消息，支持多个生产者和消费者。

#### `overwrite_buffer<T>`
```cpp
template<class _Type>
class overwrite_buffer : public propagator_block<multi_link_registry<ITarget<_Type>>, 
                                                 multi_link_registry<ISource<_Type>>>
```
覆盖缓冲区，只保存最新的消息，新消息覆盖旧消息，适合状态更新场景。

#### `single_assignment<T>`
```cpp
template<class _Type>
class single_assignment : public propagator_block<multi_link_registry<ITarget<_Type>>, 
                                                  multi_link_registry<ISource<_Type>>>
```
单次赋值缓冲区，只能设置一次值，多次读取相同值，适合一次性计算结果共享。

#### `call<T>`
```cpp
template<class _Type, class _FunctorType = ::std::function<void(_Type const&)>>
class call : public target_block<multi_link_registry<ISource<_Type>>>
```
调用块，对每个接收的消息调用函数，适合副作用操作，不传递消息给其他块。

#### `transformer<Input, Output>`
```cpp
template<class _Input, class _Output>
class transformer : public propagator_block<single_link_registry<ITarget<_Output>>, 
                                            multi_link_registry<ISource<_Input>>>
```
转换器，将输入消息转换为输出消息，支持数据格式转换，构建数据处理管道。

#### `timer<T>`
```cpp
template<class _Type>
class timer : public ::Concurrency::details::_Timer, 
              public source_block<single_link_registry<ITarget<_Type>>>
```
定时器，定期产生发送消息，支持重复和非重复模式，适合定时任务和心跳。

#### `join<Type, JoinType>`
```cpp
template<class _Type, join_type _Jtype = non_greedy>
class join : public propagator_block<single_link_registry<ITarget<::std::vector<_Type>>>, 
                                     multi_link_registry<ISource<_Type>>>
```
连接块，等待多个源的消息，收集所有输入后发送向量，支持贪婪和非贪婪模式。

#### `choice<Tuple>`
```cpp
template<class _Type>
class choice: public ISource<size_t>
```
选择块，从多个源中选择第一个可用的消息，返回源索引和消息内容，适合多路复用场景。

#### `multitype_join<Tuple, JoinType>`
```cpp
template<typename _Type, join_type _Jtype = non_greedy>
class multitype_join: public ISource<typename _Unwrap<_Type>::type>
```
多类型连接块，组合不同类型的输入为元组。

### 代理框架

#### `agent`
```cpp
class agent
```
代理基类，是异步执行单元，封装异步执行的任务【状态管理（创建、可运行、运行中、完成、取消）】。支持等待和取消操作。

**主要方法：**
- `start()`: 启动代理
- `cancel()`: 取消代理
- `wait()`: 等待代理完成
- `status()`: 获取代理状态
- `run()`: 代理执行逻辑（需重写）

## 使用示例

### 基础消息传递

```cpp
#include <agents.h>
#include <print>
#include <vector>

using namespace Concurrency;

void basic_message_passing() {
    // 创建无界缓冲区
    unbounded_buffer<int> buffer;
    
    // 发送消息
    send(buffer, 1);
    send(buffer, 2);
    send(buffer, 3);
    
    // 接收消息
    std::print("Received: {}\n", receive(buffer));
    std::print("Received: {}\n", receive(buffer));
    std::print("Received: {}\n", receive(buffer));
}
```

### 数据处理管道

```cpp
#include <agents.h>
#include <print>
#include <vector>

using namespace Concurrency;

void data_processing_pipeline() {
    // 创建处理块
    transformer<int, int> doubler([](int n) { return n * 2; });
    transformer<int, std::string> stringifier([](int n) { 
        return std::format("Value: {}", n); 
    });
    call<std::string> printer([](const std::string& str) {
        std::print("{}\n", str);
    });
    
    // 连接管道
    doubler.link_target(&stringifier);
    stringifier.link_target(&printer);
    
    // 发送数据
    for (int i = 1; i <= 5; ++i) {
        send(doubler, i);
    }
    
    // 等待处理完成
    agent::wait_for_all(0, nullptr);
}
```

### 使用代理

```cpp
#include <agents.h>
#include <print>
#include <random>

using namespace Concurrency;

class DataGenerator : public agent {
public:
    explicit DataGenerator(unbounded_buffer<int>* target) 
        : _target(target) {}
    
protected:
    void run() override {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, 100);
        
        for (int i = 0; i < 10; ++i) {
            int value = dis(gen);
            send(*_target, value);
            std::print("Generated: {}\n", value);
        }
        done();
    }
    
private:
    unbounded_buffer<int>* _target;
};

class DataProcessor : public agent {
public:
    explicit DataProcessor(unbounded_buffer<int>* source) 
        : _source(source) {}
    
protected:
    void run() override {
        int sum = 0;
        int count = 0;
        
        while (count < 10) {
            int value = receive(*_source);
            sum += value;
            count++;
            std::print("Processed: {}, running sum: {}\n", value, sum);
        }
        
        std::print("Final sum: {}\n", sum);
        done();
    }
    
private:
    unbounded_buffer<int>* _source;
};

void agent_example() {
    unbounded_buffer<int> buffer;
    
    DataGenerator generator(&buffer);
    DataProcessor processor(&buffer);
    
    generator.start();
    processor.start();
    
    agent::wait(&generator);
    agent::wait(&processor);
}
```

### 复杂数据流网络

```cpp
#include <agents.h>
#include <print>
#include <vector>
#include <algorithm>

using namespace Concurrency;

void complex_dataflow_network() {
    // 创建各种消息块
    unbounded_buffer<int> source;
    transformer<int, int> filter([](int n) {
        return n % 2 == 0 ? n : -1;  // 过滤奇数
    });
    transformer<int, int> multiplier([](int n) {
        return n * 10;
    });
    overwrite_buffer<int> latest;
    call<int> display([](int n) {
        if (n != -1) {
            std::print("Final result: {}\n", n);
        }
    });
    
    // 构建网络
    source.link_target(&filter);
    filter.link_target(&multiplier);
    multiplier.link_target(&latest);
    latest.link_target(&display);
    
    // 发送测试数据
    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    for (int value : data) {
        send(source, value);
    }
    
    // 等待处理
    agent::wait_for_all(0, nullptr);
}
```

### 定时器和选择

```cpp
#include <agents.h>
#include <print>
#include <chrono>

using namespace Concurrency;

void timer_and_choice_example() {
    // 创建数据源
    unbounded_buffer<int> data_source;
    timer<int> data_timer(1000, -1, nullptr, true);  // 每秒产生-1
    
    // 创建选择器
    auto selector = make_choice(&data_source, &data_timer);
    
    call<size_t> handler([&](size_t index) {
        if (index == 0) {
            int data = receive(data_source);
            std::print("Received data: {}\n", data);
        } else {
            receive(data_timer);  // 消耗定时器消息
            std::print("Timer tick - no data received\n");
        }
    });
    
    selector.link_target(&handler);
    
    // 启动定时器
    data_timer.start();
    
    // 发送一些数据
    send(data_source, 100);
    send(data_source, 200);
    
    // 运行一段时间
    std::this_thread::sleep_for(std::chrono::seconds(5));
    
    data_timer.stop();
}
```

## 适用业务场景

1. **数据处理管道** - 构建复杂的数据处理流水线
2. **事件驱动系统** - 处理异步事件和消息
3. **生产者-消费者模式** - 协调生产者和消费者
4. **工作流引擎** - 实现复杂的工作流程
5. **实时数据处理** - 处理流式数据
6. **GUI后台处理** - 在后台执行耗时操作

## 完整示例1：图像处理管道

下面展示一个完整的图像处理管道示例，模拟从摄像头捕获图像到最终显示的完整流程：

```C++
#include <agents.h>
#include <vector>
#include <string>
#include <random>
#include <print>

using namespace Concurrency;
using namespace std;

// 模拟图像数据
struct ImageData {
    int width;
    int height;
    vector<unsigned char> pixels;
    string timestamp;
    
    ImageData(int w, int h) : width(w), height(h), pixels(w * h * 3) {}
};

// 1. 图像捕获代理 - 模拟摄像头
class ImageCaptureAgent : public agent {
private:
    ITarget<ImageData>* m_target;
    bool m_running;
    
public:
    ImageCaptureAgent(ITarget<ImageData>* target) 
        : m_target(target), m_running(false) {}
    
protected:
    void run() override {
        m_running = true;
        std::println("图像捕获代理启动");
        
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> dis(0, 255);
        
        int frame_count = 0;
        while (m_running && frame_count < 10) {
            // 模拟图像捕获延迟
            this_thread::sleep_for(chrono::milliseconds(100));
            
            // 创建模拟图像
            ImageData image(640, 480);
            for (auto& pixel : image.pixels) {
                pixel = static_cast<unsigned char>(dis(gen));
            }
            image.timestamp = "frame_" + to_string(frame_count);
            
            // 发送图像数据
            auto msg = new message<ImageData>(image);
            asend(m_target, msg);
            
            std::println("捕获图像帧: {}", frame_count);
            frame_count++;
            
            if (status() == agent_canceled) {
                break;
            }
        }
        
        std::println("图像捕获代理完成");
        done();
    }
};

// 2. 图像处理转换器 - 应用图像滤镜
class ImageProcessor {
private:
    transformer<ImageData, ImageData> m_processor;
    
public:
    ImageProcessor(ITarget<ImageData>* target) 
        : m_processor(
            [this](const ImageData& input) -> ImageData {
                return processImage(input);
            }, 
            target
        ) {}
    
    ITarget<ImageData>* get_target() { return &m_processor; }
    ISource<ImageData>* get_source() { return &m_processor; }
    
private:
    ImageData processImage(const ImageData& input) {
        std::println("处理图像: {}", input.timestamp);
        
        // 模拟图像处理 - 简单灰度转换
        ImageData output = input;
        for (size_t i = 0; i < input.pixels.size(); i += 3) {
            unsigned char gray = static_cast<unsigned char>(
                0.299 * input.pixels[i] + 
                0.587 * input.pixels[i + 1] + 
                0.114 * input.pixels[i + 2]
            );
            output.pixels[i] = gray;
            output.pixels[i + 1] = gray;
            output.pixels[i + 2] = gray;
        }
        
        this_thread::sleep_for(chrono::milliseconds(50)); // 模拟处理时间
        return output;
    }
};

// 3. 质量控制块 - 检查图像质量
class QualityControl {
private:
    call<ImageData> m_qualityCheck;
    
public:
    QualityControl() : m_qualityCheck(
        [this](const ImageData& image) {
            checkQuality(image);
        }
    ) {}
    
    ITarget<ImageData>* get_target() { return &m_qualityCheck; }
    
private:
    void checkQuality(const ImageData& image) {
        // 简单的质量检查 - 计算平均亮度
        double total_brightness = 0;
        for (size_t i = 0; i < image.pixels.size(); i += 3) {
            total_brightness += image.pixels[i];
        }
        double avg_brightness = total_brightness / (image.pixels.size() / 3);
        
        std::println("质量检查 - 图像: {}, 平均亮度: {:.2f}", 
                    image.timestamp, avg_brightness);
        
        if (avg_brightness < 50) {
            std::println("警告: 图像 {} 亮度不足", image.timestamp);
        } else if (avg_brightness > 200) {
            std::println("警告: 图像 {} 过曝", image.timestamp);
        }
    }
};

// 4. 显示代理 - 模拟图像显示
class DisplayAgent : public agent {
private:
    ISource<ImageData>* m_source;
    
public:
    DisplayAgent(ISource<ImageData>* source) : m_source(source) {}
    
protected:
    void run() override {
        std::println("显示代理启动");
        
        try {
            int displayed_count = 0;
            while (displayed_count < 10) {
                // 接收处理后的图像
                ImageData image = receive<ImageData>(m_source);
                std::println("显示图像: {}", image.timestamp);
                
                // 模拟显示延迟
                this_thread::sleep_for(chrono::milliseconds(30));
                displayed_count++;
                
                if (status() == agent_canceled) {
                    break;
                }
            }
        } catch (const operation_timed_out&) {
            std::println("显示代理超时");
        }
        
        std::println("显示代理完成");
        done();
    }
};

// 5. 系统监控器 - 监控整个管道
class SystemMonitor {
private:
    overwrite_buffer<string> m_statusBuffer;
    timer<string> m_heartbeatTimer;
    
public:
    SystemMonitor() : m_heartbeatTimer(1000, "系统运行正常") {
        // 设置心跳定时器
        m_heartbeatTimer.link_target(&m_statusBuffer);
        m_heartbeatTimer.start();
        
        // 监控状态变化
        auto monitor_call = new call<string>(
            [this](const string& status) {
                std::println("系统状态: {}", status);
            }
        );
        m_statusBuffer.link_target(monitor_call);
    }
    
    void update_status(const string& status) {
        send(m_statusBuffer, status);
    }
};

int main() {
    std::println("=== 图像处理管道演示 ===");
    
    try {
        // 创建消息块
        unbounded_buffer<ImageData> rawImageBuffer;
        SystemMonitor monitor;
        
        // 创建处理组件
        ImageProcessor processor(&rawImageBuffer);
        QualityControl qualityControl;
        
        // 创建代理
        ImageCaptureAgent captureAgent(&rawImageBuffer);
        DisplayAgent displayAgent(processor.get_source());
        
        // 连接管道: 捕获 -> 处理 -> 质量控制 -> 显示
        rawImageBuffer.link_target(processor.get_target());
        processor.get_source()->link_target(qualityControl.get_target());
        
        // 启动系统
        monitor.update_status("系统启动");
        
        // 启动代理
        captureAgent.start();
        displayAgent.start();
        
        // 等待完成
        agent::wait(&captureAgent);
        agent::wait(&displayAgent);
        
        monitor.update_status("系统完成");
        
    } catch (const exception& e) {
        std::println("错误: {}", e.what());
        return 1;
    }
    
    std::println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：并行数据处理

```c++
#include <agents.h>
#include <vector>
#include <numeric>
#include <print>

using namespace Concurrency;
using namespace std;

// 并行数据处理示例
class ParallelDataProcessor {
private:
    transformer<vector<int>, int> m_sumCalculator;
    transformer<vector<int>, double> m_avgCalculator;
    single_assignment<tuple<int, double>> m_finalResult;
    
public:
    ParallelDataProcessor() 
        : m_sumCalculator(
            [](const vector<int>& data) -> int {
                println("计算总和...");
                return accumulate(data.begin(), data.end(), 0);
            }
        )
        , m_avgCalculator(
            [](const vector<int>& data) -> double {
                println("计算平均值...");
                return static_cast<double>(
                    accumulate(data.begin(), data.end(), 0)) / data.size();
            }
        ) {
        
        // 使用choice等待两个计算结果
        auto results_choice = new choice<tuple<ITarget<int>*, ITarget<double>*>>(
            make_tuple(&m_sumCalculator, &m_avgCalculator)
        );
        
        // 连接结果到最终输出
        auto result_processor = new call<size_t>(
            [this](size_t index) {
                processResult(index);
            }
        );
        results_choice->link_target(result_processor);
    }
    
    ITarget<vector<int>>* get_target() { 
        // 使用unbounded_buffer分发数据到两个处理器
        static unbounded_buffer<vector<int>> distributor;
        distributor.link_target(&m_sumCalculator);
        distributor.link_target(&m_avgCalculator);
        return &distributor;
    }
    
    ISource<tuple<int, double>>* get_final_result() { return &m_finalResult; }
    
private:
    void processResult(size_t index) {
        static int sum = 0;
        static double avg = 0.0;
        static int result_count = 0;
        
        result_count++;
        if (result_count == 2) {
            // 两个结果都准备好了
            send(m_finalResult, make_tuple(sum, avg));
            sum = 0;
            avg = 0.0;
            result_count = 0;
        }
    }
};

int main() {
    println("=== 并行数据处理演示 ===");
    
    ParallelDataProcessor processor;
    
    // 测试数据
    vector<vector<int>> test_data = {
        {1, 2, 3, 4, 5},
        {10, 20, 30, 40, 50},
        {100, 200, 300, 400, 500}
    };
    
    for (const auto& data : test_data) {
        println("处理数据: {:n}", data);
        
        // 发送数据到处理器
        send(processor.get_target(), data);
        
        // 等待结果
        auto [sum, avg] = receive<tuple<int, double>>(processor.get_final_result());
        println("结果 - 总和: {}, 平均值: {:.2f}", sum, avg);
        println("---");
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```



## 总结

`<agents.h>` 提供了强大的基于消息传递的并发编程框架，特别适合构建数据流处理管道、异步任务系统和复杂的并发网络。通过组合不同的消息块，可以构建出高效、可维护的并发应用程序。

# <concrt.h> 详解

## 概述

`<concrt.h>` 是 Microsoft Visual C++ 并发运行时库的核心头文件，提供了底层并发基础设施和任务调度功能。它是构建高性能并行应用程序的基础，支持任务并行、数据并行和异步操作。

## 主要功能

- **任务调度**：提供灵活的任务调度机制
- **执行上下文**：管理线程和虚拟处理器
- **资源管理**：动态分配和管理计算资源
- **同步原语**：提供线程安全的同步机制
- **内存管理**：优化的并发内存分配
- **并行模式**：支持多种并行编程模式

## 核心类详解

### 基础工具类

#### `TaskProc`

```cpp
typedef void (__cdecl * TaskProc)(void *);
```
轻量级任务的过程指针类型，用于定义任务执行体。

#### `location`

```cpp
class location
```
硬件位置的抽象表示，支持NUMA节点、调度节点等。

**主要方法：**
- `from_numa_node()`: 从NUMA节点创建位置
- `current()`: 获取当前执行位置
- `_Current_node()`: 获取当前调度节点

### 异常类体系

#### `scheduler_resource_allocation_error`

```cpp
class scheduler_resource_allocation_error : public ::std::exception
```
调度器资源分配失败异常。

#### `scheduler_worker_creation_error`

```cpp
class scheduler_worker_creation_error : public scheduler_resource_allocation_error
```
工作线程创建失败异常。

#### `improper_lock`

```cpp
class improper_lock : public ::std::exception
```
锁使用不当异常。

### 调度策略类

#### `SchedulerPolicy`

```cpp
class SchedulerPolicy
```
调度器策略配置类，控制调度器的行为。

**主要方法：**
- `GetPolicyValue()`: 获取策略值
- `SetPolicyValue()`: 设置策略值
- `SetConcurrencyLimits()`: 设置并发限制

#### `PolicyElementKey`

```cpp
enum PolicyElementKey
```
策略元素键枚举，定义可配置的调度策略：
- `SchedulerKind`: 调度器类型
- `MaxConcurrency`: 最大并发度
- `MinConcurrency`: 最小并发度
- `ContextStackSize`: 上下文栈大小

### 调度器类体系

#### `Scheduler`

```cpp
class Scheduler
```
调度器抽象类，管理任务执行和资源分配。

**主要方法：**
- `Create()`: 创建新调度器
- `Reference()`/`Release()`: 引用计数管理
- `CreateScheduleGroup()`: 创建调度组
- `ScheduleTask()`: 调度任务

#### `CurrentScheduler`

```cpp
class CurrentScheduler
```
当前调度器管理类，提供对当前上下文调度器的访问。

**主要方法：**
- `Create()`: 创建并附加新调度器
- `Detach()`: 分离当前调度器
- `Get()`: 获取当前调度器
- `CreateScheduleGroup()`: 在当前调度器创建调度组

#### `ScheduleGroup`

```cpp
class ScheduleGroup
```
调度组类，组织相关任务以优化调度。

**主要方法：**
- `ScheduleTask()`: 在组内调度任务
- `Reference()`/`Release()`: 引用计数管理
- `Id()`: 获取调度组ID

### 执行上下文类

#### `Context`

```cpp
class Context
```
执行上下文抽象，代表任务执行环境。

**主要方法：**
- `Block()`/`Unblock()`: 阻塞和解除阻塞上下文
- `Yield()`: 让出执行权
- `Oversubscribe()`: 控制过载订阅
- `CurrentContext()`: 获取当前上下文

### 同步原语类

#### `critical_section`

```cpp
class critical_section
```
非重入互斥锁，专门为并发运行时优化。

**主要方法：**
- `lock()`/`unlock()`: 加锁和解锁
- `try_lock()`: 尝试加锁
- `scoped_lock`: RAII包装器

#### `reader_writer_lock`

```cpp
class reader_writer_lock
```
读写锁，支持多读单写。

**主要方法：**
- `lock_read()`/`unlock()`: 读锁
- `lock()`/`unlock()`: 写锁
- `scoped_lock`/`scoped_lock_read`: RAII包装器

#### `event`

```cpp
class event
```
手动重置事件，支持并发等待。

**主要方法：**
- `wait()`: 等待事件
- `set()`: 设置事件
- `reset()`: 重置事件
- `wait_for_multiple()`: 等待多个事件

### 内部工具类

#### `details::_SpinWait`

```cpp
template<unsigned int _YieldCount = 1>
class _CONCRTIMP _SpinWait
```
自旋等待实现，优化短时间等待。

#### `details::_ReentrantLock`

```cpp
class _ReentrantLock
```
可重入锁实现。

#### `details::_TaskCollection`

```cpp
class _TaskCollection : public _TaskCollectionBase
```
任务集合管理，支持结构化并行。

## 使用示例

### 基础任务调度

```cpp
#include <concrt.h>
#include <print>
#include <vector>

using namespace Concurrency;

void basic_task_scheduling() {
    // 创建任务函数
    auto task1 = [](void* data) {
        int* value = static_cast<int*>(data);
        std::println("任务1执行，数据: {}", *value);
    };
    
    auto task2 = [](void* data) {
        std::string* text = static_cast<std::string*>(data);
        std::println("任务2执行，文本: {}", *text);
    };
    
    // 准备数据
    int data1 = 42;
    std::string data2 = "Hello ConcRT";
    
    // 调度任务
    CurrentScheduler::ScheduleTask(task1, &data1);
    CurrentScheduler::ScheduleTask(task2, &data2);
    
    // 等待任务完成
    wait(1000);
}
```

### 自定义调度器

```cpp
#include <concrt.h>
#include <print>
#include <thread>

using namespace Concurrency;

void custom_scheduler_example() {
    // 创建自定义调度策略
    SchedulerPolicy policy;
    policy.SetConcurrencyLimits(2, 4);  // 最小2，最大4个虚拟处理器
    
    // 创建自定义调度器
    Scheduler* pScheduler = Scheduler::Create(policy);
    
    // 附加到当前上下文
    pScheduler->Attach();
    
    std::println("自定义调度器已创建和附加");
    
    // 在自定义调度器上调度任务
    for (int i = 0; i < 10; ++i) {
        CurrentScheduler::ScheduleTask([](void* data) {
            int taskId = *static_cast<int*>(data);
            std::println("任务 {} 在虚拟处理器 {} 上执行", 
                        taskId, Context::VirtualProcessorId());
        }, &i);
    }
    
    // 等待任务执行
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    // 分离并释放调度器
    CurrentScheduler::Detach();
    pScheduler->Release();
}
```

### 调度组优化

```cpp
#include <concrt.h>
#include <print>
#include <vector>

using namespace Concurrency;

void schedule_group_example() {
    // 创建调度组
    ScheduleGroup* pGroup = CurrentScheduler::CreateScheduleGroup();
    
    std::vector<int> results;
    critical_section resultsLock;
    
    // 在调度组内调度相关任务
    for (int i = 0; i < 8; ++i) {
        int* pData = new int(i);  // 注意：实际应用中应使用智能指针
        
        pGroup->ScheduleTask([](void* data) {
            int value = *static_cast<int*>(data);
            
            // 模拟计算密集型任务
            double result = 0;
            for (int j = 0; j < 1000000; ++j) {
                result += std::sqrt(value + j);
            }
            
            // 保护结果写入
            critical_section::scoped_lock lock(resultsLock);
            results.push_back(value);
            
            std::println("任务 {} 完成，结果大小: {}", value, results.size());
            
            delete static_cast<int*>(data);
        }, pData);
    }
    
    // 等待所有任务完成
    std::this_thread::sleep_for(std::chrono::seconds(3));
    
    // 释放调度组
    pGroup->Release();
    
    std::println("所有任务完成，总计结果: {}", results.size());
}
```

### 同步原语使用

```cpp
#include <concrt.h>
#include <print>
#include <vector>
#include <thread>

using namespace Concurrency;

class ThreadSafeCounter {
private:
    int m_count = 0;
    critical_section m_lock;
    
public:
    void increment() {
        critical_section::scoped_lock lock(m_lock);
        m_count++;
        std::println("计数增加至: {}", m_count);
    }
    
    int get() const {
        return m_count;
    }
};

void synchronization_example() {
    ThreadSafeCounter counter;
    std::vector<std::thread> threads;
    
    // 创建多个线程同时增加计数
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back([&counter, i]() {
            std::println("线程 {} 启动", i);
            for (int j = 0; j < 10; ++j) {
                counter.increment();
                Context::Yield();  // 让出执行权
            }
        });
    }
    
    // 等待所有线程完成
    for (auto& thread : threads) {
        thread.join();
    }
    
    std::println("最终计数: {}", counter.get());
}
```

### 读写锁应用

```cpp
#include <concrt.h>
#include <print>
#include <vector>
#include <thread>
#include <random>

using namespace Concurrency;

class SharedData {
private:
    std::vector<int> m_data;
    reader_writer_lock m_rwLock;
    
public:
    void addValue(int value) {
        reader_writer_lock::scoped_lock lock(m_rwLock);  // 写锁
        m_data.push_back(value);
        std::println("写入数据: {}", value);
    }
    
    double calculateAverage() {
        reader_writer_lock::scoped_lock_read lock(m_rwLock);  // 读锁
        
        if (m_data.empty()) return 0.0;
        
        double sum = 0;
        for (int value : m_data) {
            sum += value;
        }
        
        double avg = sum / m_data.size();
        std::println("计算平均值: {:.2f} (基于 {} 个数据)", avg, m_data.size());
        return avg;
    }
    
    size_t getSize() {
        reader_writer_lock::scoped_lock_read lock(m_rwLock);
        return m_data.size();
    }
};

void reader_writer_example() {
    SharedData sharedData;
    std::vector<std::thread> writers;
    std::vector<std::thread> readers;
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 100);
    
    // 创建写入线程
    for (int i = 0; i < 2; ++i) {
        writers.emplace_back([&sharedData, &dis, &gen, i]() {
            for (int j = 0; j < 5; ++j) {
                int value = dis(gen);
                sharedData.addValue(value);
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        });
    }
    
    // 创建读取线程
    for (int i = 0; i < 3; ++i) {
        readers.emplace_back([&sharedData, i]() {
            for (int j = 0; j < 4; ++j) {
                sharedData.calculateAverage();
                std::this_thread::sleep_for(std::chrono::milliseconds(150));
            }
        });
    }
    
    // 等待所有线程完成
    for (auto& thread : writers) {
        thread.join();
    }
    for (auto& thread : readers) {
        thread.join();
    }
    
    std::println("最终数据大小: {}", sharedData.getSize());
}
```

## 适用业务场景

1. **高性能计算** - 科学计算和数值模拟
2. **媒体处理** - 图像、视频、音频处理
3. **数据分析** - 大规模数据并行处理
4. **游戏开发** - 并行游戏逻辑和物理计算
5. **金融服务** - 实时风险计算和交易处理
6. **模拟系统** - 复杂系统仿真

## 完整示例1：并行图像处理系统

下面展示一个完整的并行图像处理系统，利用ConcRT实现高性能的图像批处理：

```cpp
#include <concrt.h>
#include <vector>
#include <string>
#include <random>
#include <algorithm>
#include <numeric>
#include <print>

using namespace Concurrency;
using namespace std;

// 图像数据结构
struct ImageData {
    int id;
    int width;
    int height;
    vector<float> pixels;  // 使用float提高精度
    string filename;
    
    ImageData(int imgId, int w, int h, const string& name) 
        : id(imgId), width(w), height(h), pixels(w * h), filename(name) {}
};

// 图像处理管道类
class ImageProcessingPipeline {
private:
    Scheduler* m_pScheduler;
    ScheduleGroup* m_pScheduleGroup;
    critical_section m_outputLock;
    
public:
    ImageProcessingPipeline() : m_pScheduler(nullptr), m_pScheduleGroup(nullptr) {
        // 创建专用调度器
        SchedulerPolicy policy;
        policy.SetConcurrencyLimits(2, 8);  // 2-8个虚拟处理器
        policy.SetPolicyValue(MaxConcurrency, 4);
        
        m_pScheduler = Scheduler::Create(policy);
        m_pScheduler->Attach();
        
        // 创建调度组优化相关任务
        m_pScheduleGroup = CurrentScheduler::CreateScheduleGroup();
        
        println("图像处理管道初始化完成");
    }
    
    ~ImageProcessingPipeline() {
        if (m_pScheduleGroup) {
            m_pScheduleGroup->Release();
        }
        if (m_pScheduler) {
            CurrentScheduler::Detach();
            m_pScheduler->Release();
        }
        println("图像处理管道清理完成");
    }
    
    // 处理单张图像
    void processSingleImage(const ImageData& image) {
        auto task = [](void* data) {
            auto* context = static_cast<TaskContext*>(data);
            context->pipeline->processImageTask(*context);
            delete context;
        };
        
        auto* context = new TaskContext{this, image};
        m_pScheduleGroup->ScheduleTask(task, context);
    }
    
    // 批量处理图像
    void processBatch(const vector<ImageData>& images) {
        println("开始批量处理 {} 张图像", images.size());
        
        vector<ImageData> results;
        reader_writer_lock resultsLock;
        event completionEvent;
        
        atomic<int> completedCount = 0;
        const int totalImages = static_cast<int>(images.size());
        
        for (const auto& image : images) {
            auto task = [&, image](void*) {
                try {
                    // 执行图像处理
                    ImageData result = processImage(image);
                    
                    // 保护结果写入
                    reader_writer_lock::scoped_lock_write lock(resultsLock);
                    results.push_back(result);
                    
                    int completed = ++completedCount;
                    println("图像 {} 处理完成 ({}/{})", 
                           image.filename, completed, totalImages);
                    
                    // 如果所有任务完成，设置完成事件
                    if (completed == totalImages) {
                        completionEvent.set();
                    }
                }
                catch (const exception& e) {
                    critical_section::scoped_lock lock(m_outputLock);
                    println("处理图像 {} 时出错: {}", image.filename, e.what());
                }
            };
            
            m_pScheduleGroup->ScheduleTask(task, nullptr);
        }
        
        // 等待所有任务完成
        completionEvent.wait();
        println("批量处理完成，成功处理 {} 张图像", results.size());
    }
    
private:
    struct TaskContext {
        ImageProcessingPipeline* pipeline;
        ImageData image;
    };
    
    void processImageTask(const TaskContext& context) {
        try {
            ImageData result = processImage(context.image);
            
            critical_section::scoped_lock lock(m_outputLock);
            println("任务完成: 图像 {} -> {}", 
                   context.image.filename, result.filename);
        }
        catch (const exception& e) {
            critical_section::scoped_lock lock(m_outputLock);
            println("任务失败: {} - {}", context.image.filename, e.what());
        }
    }
    
    ImageData processImage(const ImageData& input) {
        // 模拟复杂的图像处理流程
        ImageData result = input;
        result.filename = "processed_" + input.filename;
        
        // 1. 噪声减少
        applyNoiseReduction(result);
        Context::Yield();  // 让出执行权
        
        // 2. 对比度增强
        enhanceContrast(result);
        Context::Yield();
        
        // 3. 锐化
        applySharpening(result);
        Context::Yield();
        
        // 4. 颜色校正
        applyColorCorrection(result);
        
        // 模拟处理时间
        this_thread::sleep_for(chrono::milliseconds(50 + (input.id % 100)));
        
        return result;
    }
    
    void applyNoiseReduction(ImageData& image) {
        // 简单的高斯模糊模拟
        vector<float> temp = image.pixels;
        for (int i = 1; i < image.pixels.size() - 1; ++i) {
            image.pixels[i] = (temp[i-1] + temp[i] + temp[i+1]) / 3.0f;
        }
    }
    
    void enhanceContrast(ImageData& image) {
        // 对比度拉伸
        auto [minIt, maxIt] = minmax_element(image.pixels.begin(), image.pixels.end());
        float minVal = *minIt;
        float maxVal = *maxIt;
        
        if (maxVal > minVal) {
            float range = maxVal - minVal;
            for (auto& pixel : image.pixels) {
                pixel = (pixel - minVal) / range;
            }
        }
    }
    
    void applySharpening(ImageData& image) {
        // 简单的锐化核
        vector<float> temp = image.pixels;
        int width = image.width;
        
        for (int y = 1; y < image.height - 1; ++y) {
            for (int x = 1; x < width - 1; ++x) {
                int idx = y * width + x;
                float sharpened = 5.0f * temp[idx]
                                - temp[idx-1] - temp[idx+1]
                                - temp[idx-width] - temp[idx+width];
                image.pixels[idx] = max(0.0f, min(1.0f, sharpened));
            }
        }
    }
    
    void applyColorCorrection(ImageData& image) {
        // Gamma校正
        float gamma = 1.2f;
        for (auto& pixel : image.pixels) {
            pixel = powf(pixel, gamma);
        }
    }
};

// 性能监控器
class PerformanceMonitor {
private:
    reader_writer_lock m_dataLock;
    vector<long long> m_processingTimes;
    event m_updateEvent;
    
public:
    void recordProcessingTime(long long microseconds) {
        reader_writer_lock::scoped_lock_write lock(m_dataLock);
        m_processingTimes.push_back(microseconds);
        m_updateEvent.set();
    }
    
    void printStatistics() {
        reader_writer_lock::scoped_lock_read lock(m_dataLock);
        
        if (m_processingTimes.empty()) {
            println("无性能数据");
            return;
        }
        
        long long total = accumulate(m_processingTimes.begin(), 
                                   m_processingTimes.end(), 0LL);
        double average = static_cast<double>(total) / m_processingTimes.size();
        
        auto [minIt, maxIt] = minmax_element(m_processingTimes.begin(), 
                                           m_processingTimes.end());
        
        println("性能统计:");
        println("  总任务数: {}", m_processingTimes.size());
        println("  平均处理时间: {:.2f} 微秒", average);
        println("  最短处理时间: {} 微秒", *minIt);
        println("  最长处理时间: {} 微秒", *maxIt);
    }
};

// 模拟图像数据生成器
vector<ImageData> generateTestImages(int count) {
    vector<ImageData> images;
    images.reserve(count);
    
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> pixelDist(0.0f, 1.0f);
    
    for (int i = 0; i < count; ++i) {
        ImageData image(i, 100, 100, "image_" + to_string(i) + ".raw");
        
        // 生成随机像素数据
        for (auto& pixel : image.pixels) {
            pixel = pixelDist(gen);
        }
        
        images.push_back(move(image));
    }
    
    return images;
}

int main() {
    println("=== ConcRT 并行图像处理系统演示 ===");
    
    try {
        // 创建性能监控器
        PerformanceMonitor monitor;
        
        // 创建图像处理管道
        ImageProcessingPipeline pipeline;
        
        // 生成测试图像
        auto testImages = generateTestImages(20);
        println("生成 {} 张测试图像", testImages.size());
        
        // 执行批量处理
        auto startTime = chrono::high_resolution_clock::now();
        pipeline.processBatch(testImages);
        auto endTime = chrono::high_resolution_clock::now();
        
        // 计算总执行时间
        auto duration = chrono::duration_cast<chrono::milliseconds>(
            endTime - startTime);
        println("总执行时间: {} 毫秒", duration.count());
        
        // 显示性能统计
        monitor.printStatistics();
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：科学计算并行化

```cpp
#include <concrt.h>
#include <vector>
#include <cmath>
#include <numeric>
#include <print>
#include <algorithm>

using namespace Concurrency;
using namespace std;

class ParallelScientificComputing {
private:
    Scheduler* m_pScheduler;
    
public:
    ParallelScientificComputing() {
        // 为科学计算优化调度策略
        SchedulerPolicy policy;
        policy.SetConcurrencyLimits(4, 16);
        policy.SetPolicyValue(TargetOversubscriptionFactor, 1);
        
        m_pScheduler = Scheduler::Create(policy);
        m_pScheduler->Attach();
    }
    
    ~ParallelScientificComputing() {
        CurrentScheduler::Detach();
        m_pScheduler->Release();
    }
    
    // 并行矩阵乘法
    vector<vector<double>> parallelMatrixMultiply(
        const vector<vector<double>>& A,
        const vector<vector<double>>& B) {
        
        int n = A.size();
        int m = B[0].size();
        int p = B.size();
        
        vector<vector<double>> C(n, vector<double>(m, 0.0));
        reader_writer_lock resultLock;
        
        // 按块并行计算
        const int blockSize = 32;
        int blockCount = (n + blockSize - 1) / blockSize;
        
        event completionEvent;
        atomic<int> completedBlocks = 0;
        
        for (int blockI = 0; blockI < blockCount; ++blockI) {
            for (int blockJ = 0; blockJ < blockCount; ++blockJ) {
                auto task = [&, blockI, blockJ](void*) {
                    computeMatrixBlock(A, B, C, blockI, blockJ, blockSize);
                    
                    if (++completedBlocks == blockCount * blockCount) {
                        completionEvent.set();
                    }
                };
                
                CurrentScheduler::ScheduleTask(task, nullptr);
            }
        }
        
        completionEvent.wait();
        return C;
    }
    
    // 并行数值积分
    double parallelIntegrate(function<double(double)> f, 
                           double a, double b, int segments) {
        double segmentWidth = (b - a) / segments;
        vector<double> results(segments, 0.0);
        critical_section sumLock;
        
        event completionEvent;
        atomic<int> completedSegments = 0;
        
        // 每个段使用梯形法则并行计算
        for (int i = 0; i < segments; ++i) {
            auto task = [&, i](void*) {
                double x1 = a + i * segmentWidth;
                double x2 = x1 + segmentWidth;
                double area = (f(x1) + f(x2)) * segmentWidth / 2.0;
                
                {
                    critical_section::scoped_lock lock(sumLock);
                    results[i] = area;
                }
                
                if (++completedSegments == segments) {
                    completionEvent.set();
                }
            };
            
            CurrentScheduler::ScheduleTask(task, nullptr);
        }
        
        completionEvent.wait();
        return accumulate(results.begin(), results.end(), 0.0);
    }
    
    // 并行Monte Carlo模拟
    double parallelMonteCarlo(int totalSamples) {
        const int samplesPerTask = 10000;
        int taskCount = (totalSamples + samplesPerTask - 1) / samplesPerTask;
        
        vector<int> hitsPerTask(taskCount, 0);
        reader_writer_lock hitsLock;
        
        event completionEvent;
        atomic<int> completedTasks = 0;
        
        random_device rd;
        
        for (int i = 0; i < taskCount; ++i) {
            auto task = [&, i, seed = rd()](void*) {
                mt19937 gen(seed);
                uniform_real_distribution<> dis(0.0, 1.0);
                
                int hits = 0;
                int samples = (i == taskCount - 1) ? 
                    totalSamples - i * samplesPerTask : samplesPerTask;
                
                for (int j = 0; j < samples; ++j) {
                    double x = dis(gen);
                    double y = dis(gen);
                    
                    if (x * x + y * y <= 1.0) {
                        hits++;
                    }
                }
                
                {
                    reader_writer_lock::scoped_lock_write lock(hitsLock);
                    hitsPerTask[i] = hits;
                }
                
                if (++completedTasks == taskCount) {
                    completionEvent.set();
                }
            };
            
            CurrentScheduler::ScheduleTask(task, nullptr);
        }
        
        completionEvent.wait();
        
        int totalHits = accumulate(hitsPerTask.begin(), hitsPerTask.end(), 0);
        return 4.0 * totalHits / totalSamples;
    }
    
private:
    void computeMatrixBlock(const vector<vector<double>>& A,
                          const vector<vector<double>>& B,
                          vector<vector<double>>& C,
                          int blockI, int blockJ, int blockSize) {
        int n = A.size();
        int m = B[0].size();
        int p = B.size();
        
        int startI = blockI * blockSize;
        int endI = min(startI + blockSize, n);
        int startJ = blockJ * blockSize;
        int endJ = min(startJ + blockSize, m);
        
        for (int i = startI; i < endI; ++i) {
            for (int j = startJ; j < endJ; ++j) {
                double sum = 0.0;
                for (int k = 0; k < p; ++k) {
                    sum += A[i][k] * B[k][j];
                }
                C[i][j] = sum;
            }
        }
    }
};

int main() {
    println("=== ConcRT 科学计算并行化演示 ===");
    
    ParallelScientificComputing computer;
    
    // 测试数值积分
    auto f = [](double x) { return sin(x) * exp(-x); };
    double integral = computer.parallelIntegrate(f, 0.0, 3.14159, 10000);
    println("数值积分结果: {:.6f}", integral);
    
    // 测试Monte Carlo模拟
    double piEstimate = computer.parallelMonteCarlo(1000000);
    println("Monte Carlo π 估计: {:.6f}", piEstimate);
    println("实际 π 值: {:.6f}", 3.1415926535);
    println("误差: {:.6f}", abs(piEstimate - 3.1415926535));
    
    // 测试矩阵乘法
    vector<vector<double>> A = {{1, 2, 3}, {4, 5, 6}};
    vector<vector<double>> B = {{7, 8}, {9, 10}, {11, 12}};
    
    auto C = computer.parallelMatrixMultiply(A, B);
    println("矩阵乘法结果:");
    for (const auto& row : C) {
        println("  [{:.1f}, {:.1f}]", row[0], row[1]);
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 性能优化建议

1. **合理设置并发度**：根据硬件特性调整MinConcurrency和MaxConcurrency
2. **使用调度组**：相关任务使用同一调度组提高局部性
3. **避免过度订阅**：合理使用Oversubscribe控制资源使用
4. **选择合适的同步原语**：根据读写比例选择锁类型
5. **任务粒度控制**：避免任务过小导致调度开销过大

## 总结

`<concrt.h>` 提供了强大的底层并发基础设施，支持构建高性能的并行应用程序。通过灵活的调度策略、高效的同步机制和优化的内存管理，开发者可以充分利用现代多核处理器的计算能力。

# <concrtrm.h> 详解

## 概述

`<concrtrm.h>` 是 Microsoft Visual C++ 并发运行时库的资源管理器头文件，提供了底层资源管理和调度器通信的核心接口。它定义了资源管理器与自定义调度器之间的通信协议，允许开发者创建与ConcRT协同工作的自定义调度器。

## 主要功能

- **资源管理**：在多个调度器之间动态分配计算资源
- **虚拟处理器管理**：管理虚拟处理器根的分配和回收
- **线程代理管理**：提供线程抽象和上下文切换机制
- **执行上下文管理**：定义任务执行环境
- **拓扑感知**：提供系统硬件拓扑信息
- **动态反馈**：基于工作负载动态调整资源分配

## 核心接口详解

### 基础枚举类型

#### `SwitchingProxyState`

```cpp
enum SwitchingProxyState
{
    Idle,      // 线程代理空闲，返回给资源管理器
    Blocking,  // 线程代理阻塞，等待唤醒
    Nesting    // 线程代理嵌套，临时脱离虚拟处理器
};
```

线程代理切换状态，控制线程代理在上下文切换时的行为。

#### `CriticalRegionType`

```cpp
enum CriticalRegionType
{
    OutsideCriticalRegion,      // 在关键区域外
    InsideCriticalRegion,       // 在关键区域内，隐藏异步挂起
    InsideHyperCriticalRegion   // 在超关键区域内，隐藏同步和异步挂起
};
```

关键区域类型，影响调度器对线程挂起的处理方式。

### 执行上下文接口

#### `IExecutionContext`

```cpp
struct IExecutionContext
```

执行上下文接口，代表可在线程代理上执行的工作单元。

**主要方法：**

- `GetId()`: 获取唯一标识符
- `GetScheduler()`: 获取所属调度器
- `GetProxy()`/`SetProxy()`: 线程代理管理
- `Dispatch()`: 工作执行入口点

### 线程代理接口

#### `IThreadProxy`

```cpp
struct IThreadProxy
```

线程代理接口，抽象执行线程。

**主要方法：**

- `GetId()`: 获取唯一标识符
- `SwitchTo()`: 协作式上下文切换到另一个执行上下文
- `SwitchOut()`: 从当前虚拟处理器根分离
- `YieldToSystem()`: 让出执行权给系统

### 执行资源接口

#### `IExecutionResource`

```cpp
struct IExecutionResource
```

执行资源接口，代表硬件线程。

**主要方法：**

- `GetNodeId()`: 获取所属处理器节点ID
- `GetExecutionResourceId()`: 获取硬件线程ID
- `Remove()`: 返回资源给资源管理器
- `CurrentSubscriptionLevel()`: 获取当前订阅级别

### 虚拟处理器根接口

#### `IVirtualProcessorRoot`

```cpp
struct IVirtualProcessorRoot : public IExecutionResource
```

虚拟处理器根接口，代表在硬件线程上执行线程代理的权利。

**主要方法：**

- `GetId()`: 获取唯一标识符
- `Activate()`: 激活虚拟处理器根执行执行上下文
- `Deactivate()`: 停用虚拟处理器根
- `EnsureAllTasksVisible()`: 确保内存一致性

### 调度器接口

#### `IScheduler`

```cpp
struct IScheduler
```

调度器接口，资源管理器与自定义调度器通信的桥梁。

**主要方法：**

- `GetId()`: 获取调度器唯一标识符
- `Statistics()`: 提供任务统计信息用于动态反馈
- `GetPolicy()`: 返回调度器策略
- `AddVirtualProcessors()`: 接收新分配的虚拟处理器根
- `RemoveVirtualProcessors()`: 移除指定的虚拟处理器根
- `NotifyResourcesExternallyIdle()`: 通知资源变为外部空闲
- `NotifyResourcesExternallyBusy()`: 通知资源变为外部繁忙

### 调度器代理接口

#### `ISchedulerProxy`

```cpp
struct ISchedulerProxy
```

调度器代理接口，调度器与资源管理器通信的代理。

**主要方法：**

- `RequestInitialVirtualProcessors()`: 请求初始虚拟处理器根
- `Shutdown()`: 关闭调度器代理
- `BindContext()`/`UnbindContext()`: 执行上下文绑定管理
- `SubscribeCurrentThread()`: 注册当前线程参与工作
- `CreateOversubscriber()`: 创建过载订阅的虚拟处理器根

### 资源管理器接口

#### `IResourceManager`

```cpp
struct IResourceManager
```

资源管理器接口，系统资源分配的核心组件。

**主要方法：**

- `Reference()`/`Release()`: 引用计数管理
- `RegisterScheduler()`: 注册新调度器
- `GetAvailableNodeCount()`: 获取可用节点数
- `GetFirstNode()`: 获取第一个拓扑节点
- `CreateNodeTopology()`: 创建测试用节点拓扑

### 拓扑接口

#### `ITopologyNode`

```cpp
struct ITopologyNode
```

拓扑节点接口，代表系统中的一个处理器节点。

**主要方法：**

- `GetNext()`: 获取下一个拓扑节点
- `GetId()`: 获取节点ID
- `GetNumaNode()`: 获取NUMA节点号
- `GetExecutionResourceCount()`: 获取执行资源数
- `GetFirstExecutionResource()`: 获取第一个执行资源

#### `ITopologyExecutionResource`

```cpp
struct ITopologyExecutionResource
```

拓扑执行资源接口，代表节点中的硬件线程。

**主要方法：**

- `GetNext()`: 获取下一个执行资源
- `GetId()`: 获取执行资源ID

## 使用示例

### 基础自定义调度器

```cpp
#include <concrtrm.h>
#include <print>
#include <vector>
#include <queue>
#include <atomic>

using namespace Concurrency;

// 简单的自定义调度器实现
class SimpleScheduler : public IScheduler {
private:
    unsigned int m_id;
    SchedulerPolicy m_policy;
    std::queue<IExecutionContext*> m_taskQueue;
    critical_section m_queueLock;
    std::vector<IVirtualProcessorRoot*> m_virtualProcessors;
    ISchedulerProxy* m_proxy;
    std::atomic<bool> m_shuttingDown;
    
public:
    SimpleScheduler(const SchedulerPolicy& policy) 
        : m_id(GetSchedulerId()), m_policy(policy), m_shuttingDown(false) {
        
        // 注册到资源管理器
        IResourceManager* rm = CreateResourceManager();
        m_proxy = rm->RegisterScheduler(this, CONCRT_RM_VERSION_1);
        rm->Release();
        
        std::println("自定义调度器创建，ID: {}", m_id);
    }
    
    ~SimpleScheduler() {
        m_shuttingDown = true;
        m_proxy->Shutdown();
    }
    
    // IScheduler 接口实现
    unsigned int GetId() const override {
        return m_id;
    }
    
    void Statistics(unsigned int* pTaskCompletionRate, 
                   unsigned int* pTaskArrivalRate, 
                   unsigned int* pNumberOfTasksEnqueued) override {
        // 简单的统计实现
        *pTaskCompletionRate = 10;
        *pTaskArrivalRate = 8;
        
        critical_section::scoped_lock lock(m_queueLock);
        *pNumberOfTasksEnqueued = static_cast<unsigned int>(m_taskQueue.size());
    }
    
    SchedulerPolicy GetPolicy() const override {
        return m_policy;
    }
    
    void AddVirtualProcessors(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                             unsigned int count) override {
        std::println("接收到 {} 个虚拟处理器根", count);
        
        for (unsigned int i = 0; i < count; ++i) {
            m_virtualProcessors.push_back(ppVirtualProcessorRoots[i]);
            
            // 立即激活虚拟处理器根
            auto context = new SimpleExecutionContext(this);
            ppVirtualProcessorRoots[i]->Activate(context);
        }
    }
    
    void RemoveVirtualProcessors(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                unsigned int count) override {
        std::println("移除 {} 个虚拟处理器根", count);
        
        // 简化实现：直接从列表中移除
        for (unsigned int i = 0; i < count; ++i) {
            auto it = std::find(m_virtualProcessors.begin(), 
                              m_virtualProcessors.end(), 
                              ppVirtualProcessorRoots[i]);
            if (it != m_virtualProcessors.end()) {
                m_virtualProcessors.erase(it);
                ppVirtualProcessorRoots[i]->Remove(this);
            }
        }
    }
    
    void NotifyResourcesExternallyIdle(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                      unsigned int count) override {
        std::println("{} 个资源变为外部空闲", count);
    }
    
    void NotifyResourcesExternallyBusy(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                      unsigned int count) override {
        std::println("{} 个资源变为外部繁忙", count);
    }
    
    // 调度任务方法
    void ScheduleTask(IExecutionContext* pContext) {
        {
            critical_section::scoped_lock lock(m_queueLock);
            m_taskQueue.push(pContext);
        }
        
        // 尝试激活空闲的虚拟处理器根
        for (auto vp : m_virtualProcessors) {
            // 简化实现：在实际应用中需要更复杂的逻辑
            auto context = new SimpleExecutionContext(this);
            vp->Activate(context);
        }
    }
    
    // 获取任务方法
    IExecutionContext* GetNextTask() {
        critical_section::scoped_lock lock(m_queueLock);
        if (m_taskQueue.empty()) {
            return nullptr;
        }
        
        IExecutionContext* task = m_taskQueue.front();
        m_taskQueue.pop();
        return task;
    }
};

// 简单的执行上下文实现
class SimpleExecutionContext : public IExecutionContext {
private:
    SimpleScheduler* m_scheduler;
    IThreadProxy* m_threadProxy;
    unsigned int m_id;
    
public:
    SimpleExecutionContext(SimpleScheduler* scheduler) 
        : m_scheduler(scheduler), m_threadProxy(nullptr), m_id(GetExecutionContextId()) {}
    
    // IExecutionContext 接口实现
    unsigned int GetId() const override {
        return m_id;
    }
    
    IScheduler* GetScheduler() override {
        return m_scheduler;
    }
    
    IThreadProxy* GetProxy() override {
        return m_threadProxy;
    }
    
    void SetProxy(IThreadProxy* pThreadProxy) override {
        m_threadProxy = pThreadProxy;
    }
    
    void Dispatch(DispatchState* pDispatchState) override {
        std::println("执行上下文 {} 开始分发", m_id);
        
        while (true) {
            IExecutionContext* nextTask = m_scheduler->GetNextTask();
            if (nextTask) {
                std::println("切换到下一个任务");
                m_threadProxy->SwitchTo(nextTask, Idle);
                break;
            } else {
                std::println("没有任务，停用虚拟处理器根");
                if (m_threadProxy->Deactivate(this)) {
                    break;
                }
            }
        }
        
        std::println("执行上下文 {} 结束分发", m_id);
    }
};

void basic_custom_scheduler_example() {
    std::println("=== 基础自定义调度器示例 ===");
    
    // 创建调度策略
    SchedulerPolicy policy;
    policy.SetConcurrencyLimits(1, 4);
    
    // 创建自定义调度器
    SimpleScheduler scheduler(policy);
    
    // 创建一些任务
    for (int i = 0; i < 5; ++i) {
        auto context = new SimpleExecutionContext(&scheduler);
        scheduler.ScheduleTask(context);
    }
    
    // 等待一段时间让任务执行
    std::this_thread::sleep_for(std::chrono::seconds(2));
    
    std::println("=== 示例完成 ===");
}
```

### 高级资源管理

```cpp
#include <concrtrm.h>
#include <print>
#include <vector>
#include <map>
#include <atomic>

using namespace Concurrency;

class AdvancedResourceManager {
private:
    IResourceManager* m_resourceManager;
    std::map<unsigned int, ISchedulerProxy*> m_schedulerProxies;
    critical_section m_lock;
    
public:
    AdvancedResourceManager() {
        m_resourceManager = CreateResourceManager();
        std::println("资源管理器创建，版本: {}", CONCRT_RM_VERSION_1);
        
        // 打印系统信息
        printSystemInfo();
    }
    
    ~AdvancedResourceManager() {
        // 清理所有调度器代理
        for (auto& pair : m_schedulerProxies) {
            pair.second->Shutdown();
        }
        m_resourceManager->Release();
    }
    
    // 注册调度器
    unsigned int RegisterScheduler(IScheduler* pScheduler) {
        ISchedulerProxy* proxy = m_resourceManager->RegisterScheduler(
            pScheduler, CONCRT_RM_VERSION_1);
        
        unsigned int schedulerId = pScheduler->GetId();
        
        {
            critical_section::scoped_lock lock(m_lock);
            m_schedulerProxies[schedulerId] = proxy;
        }
        
        std::println("调度器 {} 已注册", schedulerId);
        return schedulerId;
    }
    
    // 获取系统拓扑信息
    void printSystemInfo() {
        std::println("=== 系统信息 ===");
        std::println("处理器数量: {}", GetProcessorCount());
        std::println("处理器节点数量: {}", GetProcessorNodeCount());
        std::println("可用节点数量: {}", m_resourceManager->GetAvailableNodeCount());
        
        // 遍历拓扑
        ITopologyNode* node = m_resourceManager->GetFirstNode();
        while (node != nullptr) {
            std::println("节点 {}: NUMA节点={}, 执行资源数={}", 
                        node->GetId(), node->GetNumaNode(), 
                        node->GetExecutionResourceCount());
            
            // 遍历节点中的执行资源
            ITopologyExecutionResource* resource = node->GetFirstExecutionResource();
            while (resource != nullptr) {
                std::println("  执行资源 ID: {}", resource->GetId());
                resource = resource->GetNext();
            }
            
            node = node->GetNext();
        }
    }
    
    // 创建测试拓扑（仅调试版本可用）
    void createTestTopology() {
#ifdef _DEBUG
        unsigned int nodeCount = 2;
        unsigned int coreCounts[] = {4, 4};  // 每个节点4个核心
        unsigned int processorGroups[] = {0, 0};  // 都在处理器组0
        
        m_resourceManager->CreateNodeTopology(nodeCount, coreCounts, 
                                            nullptr, processorGroups);
        std::println("测试拓扑已创建");
#endif
    }
};

void advanced_resource_management_example() {
    std::println("=== 高级资源管理示例 ===");
    
    AdvancedResourceManager resourceManager;
    
    // 创建多个调度器演示资源分配
    SchedulerPolicy policy1;
    policy1.SetConcurrencyLimits(2, 4);
    
    SchedulerPolicy policy2;
    policy2.SetConcurrencyLimits(1, 2);
    
    // 在实际应用中，这里会创建实际的调度器实例
    // 为了示例简化，我们只演示资源管理器功能
    
    std::println("=== 示例完成 ===");
}
```

## 适用业务场景

1. **自定义调度器开发** - 实现特定领域专用的调度策略
2. **实时系统** - 需要精确控制线程执行和资源分配的系统
3. **高性能计算** - 科学计算和数值模拟中的资源优化
4. **游戏引擎** - 游戏循环和任务系统的底层调度
5. **嵌入式系统** - 资源受限环境下的并发控制
6. **研究原型** - 并发算法和调度策略的研究

## 完整示例1：自定义工作窃取调度器

下面展示一个完整的自定义工作窃取调度器实现，利用资源管理器接口实现高效的负载均衡：

```cpp
#include <concrtrm.h>
#include <vector>
#include <deque>
#include <random>
#include <atomic>
#include <print>

using namespace Concurrency;
using namespace std;

// 工作窃取调度器实现
class WorkStealingScheduler : public IScheduler {
private:
    unsigned int m_id;
    SchedulerPolicy m_policy;
    ISchedulerProxy* m_proxy;
    
    // 每个虚拟处理器根一个任务队列
    struct ProcessorData {
        deque<IExecutionContext*> localQueue;
        critical_section queueLock;
        IVirtualProcessorRoot* virtualProcessor;
        atomic<bool> isActive;
    };
    
    vector<ProcessorData> m_processors;
    atomic<unsigned int> m_nextProcessorIndex;
    critical_section m_processorsLock;
    
public:
    WorkStealingScheduler(const SchedulerPolicy& policy) 
        : m_id(GetSchedulerId()), m_policy(policy), m_nextProcessorIndex(0) {
        
        // 注册到资源管理器
        IResourceManager* rm = CreateResourceManager();
        m_proxy = rm->RegisterScheduler(this, CONCRT_RM_VERSION_1);
        rm->Release();
        
        println("工作窃取调度器创建，ID: {}", m_id);
    }
    
    ~WorkStealingScheduler() {
        m_proxy->Shutdown();
    }
    
    // IScheduler 接口实现
    unsigned int GetId() const override {
        return m_id;
    }
    
    void Statistics(unsigned int* pTaskCompletionRate, 
                   unsigned int* pTaskArrivalRate, 
                   unsigned int* pNumberOfTasksEnqueued) override {
        // 计算总体统计信息
        unsigned int totalTasks = 0;
        for (const auto& proc : m_processors) {
            critical_section::scoped_lock lock(proc.queueLock);
            totalTasks += static_cast<unsigned int>(proc.localQueue.size());
        }
        
        *pTaskCompletionRate = 50;  // 简化统计
        *pTaskArrivalRate = 45;
        *pNumberOfTasksEnqueued = totalTasks;
    }
    
    SchedulerPolicy GetPolicy() const override {
        return m_policy;
    }
    
    void AddVirtualProcessors(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                             unsigned int count) override {
        critical_section::scoped_lock lock(m_processorsLock);
        
        println("添加 {} 个虚拟处理器根", count);
        
        for (unsigned int i = 0; i < count; ++i) {
            ProcessorData procData;
            procData.virtualProcessor = ppVirtualProcessorRoots[i];
            procData.isActive = true;
            
            m_processors.push_back(procData);
            
            // 激活虚拟处理器根
            auto context = new WorkStealingContext(this, 
                                                 static_cast<unsigned int>(m_processors.size() - 1));
            ppVirtualProcessorRoots[i]->Activate(context);
        }
    }
    
    void RemoveVirtualProcessors(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                unsigned int count) override {
        critical_section::scoped_lock lock(m_processorsLock);
        
        println("移除 {} 个虚拟处理器根", count);
        
        for (unsigned int i = 0; i < count; ++i) {
            auto it = find_if(m_processors.begin(), m_processors.end(),
                            [&](const ProcessorData& pd) {
                                return pd.virtualProcessor == ppVirtualProcessorRoots[i];
                            });
            
            if (it != m_processors.end()) {
                it->isActive = false;  // 标记为不活跃
                it->virtualProcessor->Remove(this);
                m_processors.erase(it);
            }
        }
    }
    
    void NotifyResourcesExternallyIdle(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                      unsigned int count) override {
        println("{} 个外部资源变为空闲", count);
    }
    
    void NotifyResourcesExternallyBusy(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                      unsigned int count) override {
        println("{} 个外部资源变为繁忙", count);
    }
    
    // 调度任务 - 使用工作窃取策略
    void ScheduleTask(IExecutionContext* pContext) {
        // 选择下一个处理器的索引（轮询）
        unsigned int index = m_nextProcessorIndex++ % max(1u, static_cast<unsigned int>(m_processors.size()));
        
        if (index < m_processors.size()) {
            auto& proc = m_processors[index];
            critical_section::scoped_lock lock(proc.queueLock);
            proc.localQueue.push_back(pContext);
            
            // 如果处理器处于停用状态，重新激活它
            if (!proc.isActive) {
                auto context = new WorkStealingContext(this, index);
                proc.virtualProcessor->Activate(context);
                proc.isActive = true;
            }
        }
    }
    
    // 从指定处理器获取任务（支持工作窃取）
    IExecutionContext* GetTask(unsigned int processorIndex, bool allowSteal = false) {
        // 首先尝试从本地队列获取
        if (processorIndex < m_processors.size()) {
            auto& localProc = m_processors[processorIndex];
            
            {
                critical_section::scoped_lock lock(localProc.queueLock);
                if (!localProc.localQueue.empty()) {
                    IExecutionContext* task = localProc.localQueue.front();
                    localProc.localQueue.pop_front();
                    return task;
                }
            }
        }
        
        // 如果允许窃取，尝试从其他处理器窃取工作
        if (allowSteal) {
            random_device rd;
            mt19937 gen(rd());
            
            for (int attempt = 0; attempt < 3; ++attempt) {
                // 随机选择受害者处理器
                uniform_int_distribution<unsigned int> dis(0, 
                    static_cast<unsigned int>(m_processors.size() - 1));
                unsigned int victimIndex = dis(gen);
                
                if (victimIndex != processorIndex && victimIndex < m_processors.size()) {
                    auto& victimProc = m_processors[victimIndex];
                    
                    critical_section::scoped_lock lock(victimProc.queueLock);
                    if (!victimProc.localQueue.empty()) {
                        // 从受害者队列的尾部窃取（工作窃取模式）
                        IExecutionContext* task = victimProc.localQueue.back();
                        victimProc.localQueue.pop_back();
                        println("处理器 {} 从处理器 {} 窃取任务", processorIndex, victimIndex);
                        return task;
                    }
                }
            }
        }
        
        return nullptr;  // 没有找到任务
    }
};

// 工作窃取执行上下文
class WorkStealingContext : public IExecutionContext {
private:
    WorkStealingScheduler* m_scheduler;
    IThreadProxy* m_threadProxy;
    unsigned int m_id;
    unsigned int m_processorIndex;
    
public:
    WorkStealingContext(WorkStealingScheduler* scheduler, unsigned int processorIndex) 
        : m_scheduler(scheduler), m_threadProxy(nullptr), 
          m_id(GetExecutionContextId()), m_processorIndex(processorIndex) {}
    
    unsigned int GetId() const override {
        return m_id;
    }
    
    IScheduler* GetScheduler() override {
        return m_scheduler;
    }
    
    IThreadProxy* GetProxy() override {
        return m_threadProxy;
    }
    
    void SetProxy(IThreadProxy* pThreadProxy) override {
        m_threadProxy = pThreadProxy;
    }
    
    void Dispatch(DispatchState* pDispatchState) override {
        println("工作窃取上下文 {} 在处理器 {} 上启动", m_id, m_processorIndex);
        
        bool shouldContinue = true;
        int consecutiveIdleCycles = 0;
        const int maxIdleCycles = 3;  // 最大空闲周期数
        
        while (shouldContinue) {
            IExecutionContext* task = m_scheduler->GetTask(m_processorIndex, true);
            
            if (task) {
                consecutiveIdleCycles = 0;  // 重置空闲计数
                println("处理器 {} 执行任务", m_processorIndex);
                
                // 切换到任务执行
                m_threadProxy->SwitchTo(task, Idle);
                
                // 任务执行完成后继续
            } else {
                consecutiveIdleCycles++;
                println("处理器 {} 没有任务 (空闲周期 {})", m_processorIndex, consecutiveIdleCycles);
                
                if (consecutiveIdleCycles >= maxIdleCycles) {
                    // 停用虚拟处理器根以节省资源
                    println("处理器 {} 停用以节省资源", m_processorIndex);
                    if (m_threadProxy->Deactivate(this)) {
                        shouldContinue = false;
                    } else {
                        consecutiveIdleCycles = 0;  // 重新激活，重置计数
                    }
                } else {
                    // 短暂让步后重试
                    m_threadProxy->YieldToSystem();
                }
            }
        }
        
        println("工作窃取上下文 {} 在处理器 {} 上结束", m_id, m_processorIndex);
    }
};

// 测试任务上下文
class TestTaskContext : public IExecutionContext {
private:
    unsigned int m_id;
    IScheduler* m_scheduler;
    IThreadProxy* m_threadProxy;
    int m_taskId;
    
public:
    TestTaskContext(IScheduler* scheduler, int taskId) 
        : m_id(GetExecutionContextId()), m_scheduler(scheduler), 
          m_threadProxy(nullptr), m_taskId(taskId) {}
    
    unsigned int GetId() const override {
        return m_id;
    }
    
    IScheduler* GetScheduler() override {
        return m_scheduler;
    }
    
    IThreadProxy* GetProxy() override {
        return m_threadProxy;
    }
    
    void SetProxy(IThreadProxy* pThreadProxy) override {
        m_threadProxy = pThreadProxy;
    }
    
    void Dispatch(DispatchState* pDispatchState) override {
        println("任务 {} 开始执行", m_taskId);
        
        // 模拟工作负载
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> workDist(100, 500);
        
        // 模拟计算工作
        double result = 0.0;
        int iterations = workDist(gen);
        for (int i = 0; i < iterations; ++i) {
            result += sqrt(static_cast<double>(i));
        }
        
        println("任务 {} 完成，迭代次数: {}, 结果: {:.2f}", 
               m_taskId, iterations, result);
        
        // 任务完成，不需要切换回调度器
    }
};

int main() {
    println("=== 工作窃取调度器演示 ===");
    
    try {
        // 创建调度策略
        SchedulerPolicy policy;
        policy.SetConcurrencyLimits(2, 8);  // 最小2个，最大8个虚拟处理器
        
        // 创建工作窃取调度器
        WorkStealingScheduler scheduler(policy);
        
        // 创建并调度测试任务
        println("创建和调度测试任务...");
        for (int i = 0; i < 20; ++i) {
            auto task = new TestTaskContext(&scheduler, i);
            scheduler.ScheduleTask(task);
        }
        
        // 等待任务执行
        println("等待任务执行...");
        this_thread::sleep_for(chrono::seconds(5));
        
        // 调度更多任务
        println("调度更多任务...");
        for (int i = 20; i < 30; ++i) {
            auto task = new TestTaskContext(&scheduler, i);
            scheduler.ScheduleTask(task);
        }
        
        // 继续等待
        this_thread::sleep_for(chrono::seconds(3));
        
    } catch (const exception& e) {
        println("错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：实时任务调度器

```cpp
#include <concrtrm.h>
#include <vector>
#include <queue>
#include <chrono>
#include <atomic>
#include <print>

using namespace Concurrency;
using namespace std;

// 实时任务优先级
enum class RealTimePriority {
    Critical,    // 关键任务，必须立即执行
    High,        // 高优先级任务
    Normal,      // 普通优先级任务
    Low          // 低优先级任务
};

// 实时任务调度器
class RealTimeScheduler : public IScheduler {
private:
    unsigned int m_id;
    SchedulerPolicy m_policy;
    ISchedulerProxy* m_proxy;
    
    // 按优先级组织的任务队列
    struct PriorityQueue {
        deque<IExecutionContext*> critical;
        deque<IExecutionContext*> high;
        deque<IExecutionContext*> normal;
        deque<IExecutionContext*> low;
        critical_section lock;
        
        // 获取最高优先级任务
        IExecutionContext* pop() {
            critical_section::scoped_lock scopedLock(lock);
            
            if (!critical.empty()) {
                auto task = critical.front();
                critical.pop_front();
                return task;
            }
            if (!high.empty()) {
                auto task = high.front();
                high.pop_front();
                return task;
            }
            if (!normal.empty()) {
                auto task = normal.front();
                normal.pop_front();
                return task;
            }
            if (!low.empty()) {
                auto task = low.front();
                low.pop_front();
                return task;
            }
            return nullptr;
        }
        
        // 按优先级添加任务
        void push(IExecutionContext* task, RealTimePriority priority) {
            critical_section::scoped_lock scopedLock(lock);
            
            switch (priority) {
            case RealTimePriority::Critical:
                critical.push_back(task);
                break;
            case RealTimePriority::High:
                high.push_back(task);
                break;
            case RealTimePriority::Normal:
                normal.push_back(task);
                break;
            case RealTimePriority::Low:
                low.push_back(task);
                break;
            }
        }
        
        // 获取队列大小
        size_t size() const {
            return critical.size() + high.size() + normal.size() + low.size();
        }
    };
    
    PriorityQueue m_taskQueue;
    vector<IVirtualProcessorRoot*> m_virtualProcessors;
    atomic<long long> m_totalTasksProcessed;
    
public:
    RealTimeScheduler(const SchedulerPolicy& policy) 
        : m_id(GetSchedulerId()), m_policy(policy), m_totalTasksProcessed(0) {
        
        IResourceManager* rm = CreateResourceManager();
        m_proxy = rm->RegisterScheduler(this, CONCRT_RM_VERSION_1);
        rm->Release();
        
        println("实时调度器创建，ID: {}", m_id);
    }
    
    ~RealTimeScheduler() {
        m_proxy->Shutdown();
    }
    
    // IScheduler 接口实现
    unsigned int GetId() const override {
        return m_id;
    }
    
    void Statistics(unsigned int* pTaskCompletionRate, 
                   unsigned int* pTaskArrivalRate, 
                   unsigned int* pNumberOfTasksEnqueued) override {
        *pTaskCompletionRate = static_cast<unsigned int>(m_totalTasksProcessed / 10);
        *pTaskArrivalRate = static_cast<unsigned int>(m_totalTasksProcessed / 10);
        *pNumberOfTasksEnqueued = static_cast<unsigned int>(m_taskQueue.size());
    }
    
    SchedulerPolicy GetPolicy() const override {
        return m_policy;
    }
    
    void AddVirtualProcessors(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                             unsigned int count) override {
        println("实时调度器接收到 {} 个虚拟处理器根", count);
        
        for (unsigned int i = 0; i < count; ++i) {
            m_virtualProcessors.push_back(ppVirtualProcessorRoots[i]);
            
            // 立即激活处理实时任务
            auto context = new RealTimeContext(this);
            ppVirtualProcessorRoots[i]->Activate(context);
        }
    }
    
    void RemoveVirtualProcessors(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                unsigned int count) override {
        println("实时调度器移除 {} 个虚拟处理器根", count);
        
        for (unsigned int i = 0; i < count; ++i) {
            auto it = find(m_virtualProcessors.begin(), 
                         m_virtualProcessors.end(), 
                         ppVirtualProcessorRoots[i]);
            if (it != m_virtualProcessors.end()) {
                m_virtualProcessors.erase(it);
                ppVirtualProcessorRoots[i]->Remove(this);
            }
        }
    }
    
    void NotifyResourcesExternallyIdle(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                      unsigned int count) override {
        println("实时调度器: {} 个外部资源空闲", count);
    }
    
    void NotifyResourcesExternallyBusy(IVirtualProcessorRoot** ppVirtualProcessorRoots, 
                                      unsigned int count) override {
        println("实时调度器: {} 个外部资源繁忙", count);
    }
    
    // 按优先级调度任务
    void ScheduleTask(IExecutionContext* pContext, RealTimePriority priority) {
        m_taskQueue.push(pContext, priority);
        
        // 确保有活跃的虚拟处理器处理任务
        for (auto vp : m_virtualProcessors) {
            auto context = new RealTimeContext(this);
            vp->Activate(context);
        }
    }
    
    // 获取下一个要执行的任务
    IExecutionContext* GetNextTask() {
        return m_taskQueue.pop();
    }
    
    // 记录任务完成
    void RecordTaskCompletion() {
        m_totalTasksProcessed++;
    }
};

// 实时执行上下文
class RealTimeContext : public IExecutionContext {
private:
    RealTimeScheduler* m_scheduler;
    IThreadProxy* m_threadProxy;
    unsigned int m_id;
    
public:
    RealTimeContext(RealTimeScheduler* scheduler) 
        : m_scheduler(scheduler), m_threadProxy(nullptr), 
          m_id(GetExecutionContextId()) {}
    
    unsigned int GetId() const override {
        return m_id;
    }
    
    IScheduler* GetScheduler() override {
        return m_scheduler;
    }
    
    IThreadProxy* GetProxy() override {
        return m_threadProxy;
    }
    
    void SetProxy(IThreadProxy* pThreadProxy) override {
        m_threadProxy = pThreadProxy;
    }
    
    void Dispatch(DispatchState* pDispatchState) override {
        println("实时上下文 {} 启动", m_id);
        
        auto startTime = chrono::steady_clock::now();
        const auto maxRuntime = chrono::seconds(10);  // 最大运行时间
        
        while (chrono::steady_clock::now() - startTime < maxRuntime) {
            IExecutionContext* task = m_scheduler->GetNextTask();
            
            if (task) {
                println("实时上下文 {} 执行任务", m_id);
                
                // 切换到任务执行
                m_threadProxy->SwitchTo(task, Idle);
                
                // 记录任务完成
                m_scheduler->RecordTaskCompletion();
            } else {
                // 没有任务，短暂停用
                println("实时上下文 {} 没有任务，停用", m_id);
                if (m_threadProxy->Deactivate(this)) {
                    break;
                }
            }
        }
        
        println("实时上下文 {} 结束", m_id);
    }
};

// 演示实时任务
void real_time_scheduler_demo() {
    println("=== 实时调度器演示 ===");
    
    SchedulerPolicy policy;
    policy.SetConcurrencyLimits(2, 4);
    
    RealTimeScheduler scheduler(policy);
    
    // 创建不同优先级的任务
    for (int i = 0; i < 5; ++i) {
        auto task = new RealTimeContext(&scheduler);
        scheduler.ScheduleTask(task, RealTimePriority::Critical);
    }
    
    for (int i = 0; i < 10; ++i) {
        auto task = new RealTimeContext(&scheduler);
        scheduler.ScheduleTask(task, RealTimePriority::Normal);
    }
    
    // 运行一段时间
    this_thread::sleep_for(chrono::seconds(5));
    
    println("=== 演示完成 ===");
}
```

## 性能优化建议

1. **合理使用虚拟处理器**：根据工作负载动态调整虚拟处理器数量
2. **优化任务粒度**：避免任务过小导致调度开销过大
3. **使用适当的同步原语**：根据访问模式选择合适的锁
4. **利用拓扑信息**：根据NUMA节点特性优化数据局部性
5. **实现有效的统计反馈**：为资源管理器提供准确的工作负载信息
6. **合理处理资源通知**：及时响应外部资源状态变化

## 总结

`<concrtrm.h>` 提供了ConcRT资源管理器的核心接口，允许开发者创建与系统资源管理器协同工作的自定义调度器。通过实现 `IScheduler` 和相关接口，可以构建高度优化的并发调度策略，满足特定应用场景的性能需求。这种底层控制能力使得ConcRT成为构建高性能并发应用程序的强大框架。

# <concurrent_priority_queue.h> 详解

## 概述

`<concurrent_priority_queue.h>` 是 Microsoft Visual C++ 并发运行时库的重要组成部分，提供了线程安全的并发优先级队列实现。它基于 Intel Threading Building Blocks 的实现，允许多个线程同时进行推送和弹出操作，同时保持元素的优先级顺序。

## 主要功能

- **并发安全**：支持多线程同时进行推送和弹出操作
- **优先级排序**：元素按优先级顺序弹出，优先级由比较器决定
- **高效操作**：使用聚合器模式批量处理操作，减少锁竞争
- **异常安全**：提供异常处理机制，确保操作完整性
- **内存管理**：支持自定义分配器进行内存管理
- **移动语义**：支持移动构造和移动赋值，提高性能

## 核心类详解

### 聚合器模式基础类

#### `_Aggregated_operation`

```cpp
template <typename _Derived>
class _Aggregated_operation
```

聚合操作基类，提供操作状态和链表管理功能。

**主要成员：**
- `_M_status`：操作状态
- `_M_pNext`：指向下一个操作的指针

#### `_Aggregator`

```cpp
template < typename _Operation_type, typename _Handler_type >
class _Aggregator
```

聚合器模板类，收集来自多个源的操作并在单线程上串行执行。

**主要方法：**
- `_Initialize_handler()`：初始化操作处理器
- `_Execute()`：执行操作，可能等待操作完成

### 并发优先级队列类

#### `concurrent_priority_queue`

```cpp
template <typename _Ty, typename _Compare=::std::less<_Ty>, typename _Ax = ::std::allocator<_Ty>>
class concurrent_priority_queue
```

并发优先级队列主类，提供线程安全的优先级队列操作。

**模板参数：**
- `_Ty`：队列中存储的元素类型
- `_Compare`：比较器类型，默认为 `std::less<_Ty>`
- `_Ax`：分配器类型，默认为 `std::allocator<_Ty>`

**类型定义：**
- `value_type`：存储的数据类型
- `reference`：元素引用类型
- `const_reference`：常量引用类型
- `size_type`：大小类型
- `allocator_type`：分配器类型

## 构造函数详解

### 默认构造函数

```cpp
explicit concurrent_priority_queue(const allocator_type& _Al = allocator_type())
```

创建空的并发优先级队列，可选指定分配器。

### 容量构造函数

```cpp
explicit concurrent_priority_queue(size_type _Init_capacity, const allocator_type& _Al = allocator_type())
```

创建具有初始容量的并发优先级队列。

### 迭代器范围构造函数

```cpp
template<typename _InputIterator>
concurrent_priority_queue(_InputIterator _Begin, _InputIterator _End, const allocator_type& _Al = allocator_type())
```

使用迭代器范围初始化队列。

### 拷贝构造函数

```cpp
concurrent_priority_queue(const concurrent_priority_queue& _Src)
concurrent_priority_queue(const concurrent_priority_queue& _Src, const allocator_type& _Al)
```

拷贝构造队列。

### 移动构造函数

```cpp
concurrent_priority_queue(concurrent_priority_queue&& _Src)
concurrent_priority_queue(concurrent_priority_queue&& _Src, const allocator_type& _Al)
```

移动构造队列，提高性能。

## 主要成员函数

### 容量操作

#### `empty()`

```cpp
bool empty() const
```

检查队列是否为空（线程安全）。

#### `size()`

```cpp
size_type size() const
```

返回队列中的元素数量（线程安全）。

### 元素访问操作

#### `push()`

```cpp
void push(const value_type& _Elem)
void push(value_type&& _Elem)
```

向队列添加元素（线程安全）。

#### `try_pop()`

```cpp
bool try_pop(reference _Elem)
```

从队列弹出最高优先级元素（线程安全）。

### 容器管理操作

#### `clear()`

```cpp
void clear()
```

清空队列（非线程安全）。

#### `swap()`

```cpp
void swap(concurrent_priority_queue& _Queue)
```

交换两个队列内容（非线程安全）。

#### `get_allocator()`

```cpp
allocator_type get_allocator() const
```

获取分配器副本（线程安全）。

## 内部实现机制

### 操作类型枚举

```cpp
enum _Operation_type {_INVALID_OP, _PUSH_OP_COPY, _PUSH_OP_MOVE, _POP_OP};
enum _Operation_status { _WAIT=0, _SUCCEEDED, _FAILED };
```

定义操作类型和状态。

### 操作数据结构

```cpp
class _Cpq_operation : public ::Concurrency::details::_Aggregated_operation<_Cpq_operation>
```

封装队列操作的数据结构。

### 堆管理机制

队列使用二叉堆数据结构维护优先级顺序：

- `_Heapify()`：将未排序元素合并到堆中
- `_Reheap()`：从根开始将最后一个元素推下堆重新堆化
- `_M_handle_operations()`：批量处理挂起的操作

## 使用示例

### 基础并发优先级队列

```cpp
#include <concurrent_priority_queue.h>
#include <print>
#include <thread>
#include <vector>
#include <random>

using namespace Concurrency;
using namespace std;

void basic_concurrent_priority_queue() {
    concurrent_priority_queue<int> queue;
    
    // 多线程推送数据
    vector<thread> producers;
    for (int i = 0; i < 3; ++i) {
        producers.emplace_back([&queue, i]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dis(1, 100);
            
            for (int j = 0; j < 5; ++j) {
                int value = dis(gen);
                queue.push(value);
                println("生产者 {} 推送: {}", i, value);
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        });
    }
    
    // 多线程弹出数据
    vector<thread> consumers;
    for (int i = 0; i < 2; ++i) {
        consumers.emplace_back([&queue, i]() {
            for (int j = 0; j < 7; ++j) {
                int value;
                if (queue.try_pop(value)) {
                    println("消费者 {} 弹出: {}", i, value);
                } else {
                    println("消费者 {} 未能弹出元素", i);
                }
                this_thread::sleep_for(chrono::milliseconds(20));
            }
        });
    }
    
    // 等待所有线程完成
    for (auto& t : producers) t.join();
    for (auto& t : consumers) t.join();
    
    // 弹出剩余元素
    println("剩余元素:");
    int value;
    while (queue.try_pop(value)) {
        println("  弹出: {}", value);
    }
}
```

### 自定义比较器

```cpp
#include <concurrent_priority_queue.h>
#include <print>
#include <string>

using namespace Concurrency;
using namespace std;

// 自定义任务结构
struct Task {
    int priority;
    string description;
    int estimated_time;
    
    Task(int p, const string& desc, int time) 
        : priority(p), description(desc), estimated_time(time) {}
};

// 自定义比较器 - 优先级高的先执行
struct TaskComparator {
    bool operator()(const Task& a, const Task& b) const {
        return a.priority < b.priority;  // 数字越大优先级越高
    }
};

void custom_comparator_example() {
    concurrent_priority_queue<Task, TaskComparator> task_queue;
    
    // 添加任务
    task_queue.push(Task(1, "低优先级任务", 10));
    task_queue.push(Task(5, "高优先级任务", 5));
    task_queue.push(Task(3, "中优先级任务", 8));
    task_queue.push(Task(8, "紧急任务", 2));
    task_queue.push(Task(2, "普通任务", 15));
    
    // 按优先级执行任务
    println("按优先级执行任务:");
    Task task(0, "", 0);
    while (task_queue.try_pop(task)) {
        println("执行任务: {} (优先级: {}, 预计时间: {}分钟)", 
               task.description, task.priority, task.estimated_time);
    }
}
```

## 适用业务场景

1. **任务调度系统** - 按优先级处理任务
2. **消息处理系统** - 处理不同优先级的消息
3. **实时系统** - 处理紧急事件
4. **网络包处理** - 按优先级处理网络数据包
5. **作业调度** - 调度计算作业
6. **事件驱动系统** - 处理不同重要性的事件

## 完整示例1：实时任务调度系统

下面展示一个完整的实时任务调度系统，使用并发优先级队列管理不同优先级的任务：

```cpp
#include <concurrent_priority_queue.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>

using namespace Concurrency;
using namespace std;

// 任务类型枚举
enum class TaskType {
    SystemCritical,  // 系统关键任务
    UserInteractive, // 用户交互任务
    Background,      // 后台任务
    Maintenance      // 维护任务
};

// 任务结构
struct ScheduledTask {
    int id;
    TaskType type;
    string description;
    chrono::system_clock::time_point scheduled_time;
    int priority;  // 0-100，数值越大优先级越高
    
    ScheduledTask(int task_id, TaskType task_type, const string& desc, 
                  chrono::system_clock::time_point time, int pri)
        : id(task_id), type(task_type), description(desc), 
          scheduled_time(time), priority(pri) {}
};

// 任务比较器 - 考虑优先级和调度时间
struct TaskComparator {
    bool operator()(const ScheduledTask& a, const ScheduledTask& b) const {
        // 首先比较优先级
        if (a.priority != b.priority) {
            return a.priority < b.priority;
        }
        // 优先级相同则比较调度时间（早的优先）
        return a.scheduled_time > b.scheduled_time;
    }
};

// 任务调度器类
class TaskScheduler {
private:
    concurrent_priority_queue<ScheduledTask, TaskComparator> m_taskQueue;
    atomic<bool> m_running;
    vector<thread> m_workerThreads;
    atomic<int> m_nextTaskId;
    
public:
    TaskScheduler(int num_workers = 4) : m_running(false), m_nextTaskId(1) {
        start_workers(num_workers);
    }
    
    ~TaskScheduler() {
        stop();
    }
    
    // 调度任务
    void schedule_task(TaskType type, const string& description, 
                      chrono::system_clock::time_point time, int priority) {
        ScheduledTask task(m_nextTaskId++, type, description, time, priority);
        m_taskQueue.push(task);
        
        println("已调度任务: {} (ID: {}, 优先级: {}, 类型: {})", 
               description, task.id, priority, task_type_to_string(type));
    }
    
    // 调度立即执行的任务
    void schedule_immediate(TaskType type, const string& description, int priority) {
        auto now = chrono::system_clock::now();
        schedule_task(type, description, now, priority);
    }
    
    // 启动工作线程
    void start_workers(int num_workers) {
        m_running = true;
        for (int i = 0; i < num_workers; ++i) {
            m_workerThreads.emplace_back([this, i]() { worker_loop(i); });
        }
        println("启动 {} 个工作线程", num_workers);
    }
    
    // 停止调度器
    void stop() {
        m_running = false;
        for (auto& thread : m_workerThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_workerThreads.clear();
        println("任务调度器已停止");
    }
    
    // 获取队列大小
    size_t pending_tasks() const {
        return m_taskQueue.size();
    }
    
private:
    // 工作线程循环
    void worker_loop(int worker_id) {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> work_time(50, 500);
        
        println("工作线程 {} 启动", worker_id);
        
        while (m_running) {
            ScheduledTask task(0, TaskType::Background, "", 
                              chrono::system_clock::now(), 0);
            
            if (m_taskQueue.try_pop(task)) {
                auto now = chrono::system_clock::now();
                
                // 检查任务是否应该执行
                if (now >= task.scheduled_time) {
                    execute_task(task, worker_id);
                } else {
                    // 任务还未到执行时间，重新放回队列
                    m_taskQueue.push(task);
                    this_thread::sleep_for(chrono::milliseconds(10));
                }
            } else {
                // 队列为空，短暂休眠
                this_thread::sleep_for(chrono::milliseconds(50));
            }
        }
        
        println("工作线程 {} 退出", worker_id);
    }
    
    // 执行任务
    void execute_task(const ScheduledTask& task, int worker_id) {
        auto start_time = chrono::system_clock::now();
        
        println("线程 {} 开始执行任务 {}: {} (优先级: {})", 
               worker_id, task.id, task.description, task.priority);
        
        // 模拟任务执行时间
        this_thread::sleep_for(chrono::milliseconds(
            task.type == TaskType::SystemCritical ? 50 : 
            task.type == TaskType::UserInteractive ? 100 : 200));
        
        auto end_time = chrono::system_clock::now();
        auto duration = chrono::duration_cast<chrono::milliseconds>(
            end_time - start_time);
        
        println("线程 {} 完成任务 {}: {} (执行时间: {}ms)", 
               worker_id, task.id, task.description, duration.count());
    }
    
    // 任务类型转字符串
    string task_type_to_string(TaskType type) {
        switch (type) {
        case TaskType::SystemCritical: return "系统关键";
        case TaskType::UserInteractive: return "用户交互";
        case TaskType::Background: return "后台";
        case TaskType::Maintenance: return "维护";
        default: return "未知";
        }
    }
};

// 模拟任务生成器
class TaskGenerator {
private:
    TaskScheduler& m_scheduler;
    atomic<bool> m_running;
    thread m_generatorThread;
    random_device m_rd;
    mt19937 m_gen;
    
public:
    TaskGenerator(TaskScheduler& scheduler) 
        : m_scheduler(scheduler), m_running(false), m_gen(m_rd()) {}
    
    ~TaskGenerator() {
        stop();
    }
    
    void start() {
        m_running = true;
        m_generatorThread = thread([this]() { generate_tasks(); });
        println("任务生成器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_generatorThread.joinable()) {
            m_generatorThread.join();
        }
        println("任务生成器停止");
    }
    
private:
    void generate_tasks() {
        uniform_int_distribution<> task_type_dist(0, 3);
        uniform_int_distribution<> priority_dist(1, 100);
        uniform_int_distribution<> delay_dist(0, 5000);
        
        vector<string> task_descriptions = {
            "处理用户请求", "系统状态检查", "数据备份", "日志清理",
            "内存优化", "磁盘整理", "网络连接检查", "安全扫描",
            "性能监控", "错误报告处理", "缓存更新", "数据库优化"
        };
        
        uniform_int_distribution<> desc_dist(0, 
            static_cast<int>(task_descriptions.size() - 1));
        
        int task_count = 0;
        while (m_running && task_count < 50) {
            // 随机生成任务
            TaskType type = static_cast<TaskType>(task_type_dist(m_gen));
            string description = task_descriptions[desc_dist(m_gen)];
            int priority = priority_dist(m_gen);
            
            // 随机延迟
            auto scheduled_time = chrono::system_clock::now() + 
                                chrono::milliseconds(delay_dist(m_gen));
            
            m_scheduler.schedule_task(type, description, scheduled_time, priority);
            
            task_count++;
            this_thread::sleep_for(chrono::milliseconds(100));
        }
    }
};

int main() {
    println("=== 实时任务调度系统演示 ===");
    
    try {
        // 创建任务调度器
        TaskScheduler scheduler(4);
        
        // 创建任务生成器
        TaskGenerator generator(scheduler);
        
        // 手动添加一些高优先级任务
        scheduler.schedule_immediate(TaskType::SystemCritical, 
                                   "紧急系统更新", 95);
        scheduler.schedule_immediate(TaskType::UserInteractive, 
                                   "用户界面刷新", 80);
        scheduler.schedule_immediate(TaskType::SystemCritical, 
                                   "安全漏洞修复", 99);
        
        // 启动任务生成
        generator.start();
        
        // 运行一段时间
        println("系统运行中...");
        this_thread::sleep_for(chrono::seconds(10));
        
        // 停止系统
        generator.stop();
        scheduler.stop();
        
        println("最终待处理任务数: {}", scheduler.pending_tasks());
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：网络包优先级处理系统

```cpp
#include <concurrent_priority_queue.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>

using namespace Concurrency;
using namespace std;

// 网络包类型
enum class PacketType {
    Control,        // 控制包 - 最高优先级
    Voice,          // 语音包 - 高优先级
    Video,          // 视频包 - 中优先级
    Data,           // 数据包 - 普通优先级
    Bulk            // 批量数据 - 低优先级
};

// 网络包结构
struct NetworkPacket {
    int id;
    PacketType type;
    string source_ip;
    string destination_ip;
    vector<unsigned char> payload;
    chrono::system_clock::time_point arrival_time;
    int size;
    
    NetworkPacket(int pkt_id, PacketType pkt_type, 
                  const string& src, const string& dest, 
                  const vector<unsigned char>& data)
        : id(pkt_id), type(pkt_type), source_ip(src), 
          destination_ip(dest), payload(data), 
          arrival_time(chrono::system_clock::now()),
          size(static_cast<int>(data.size())) {}
};

// 网络包比较器
struct PacketComparator {
    bool operator()(const NetworkPacket& a, const NetworkPacket& b) const {
        // 按包类型确定优先级
        auto get_priority = [](PacketType type) {
            switch (type) {
            case PacketType::Control: return 100;
            case PacketType::Voice: return 80;
            case PacketType::Video: return 60;
            case PacketType::Data: return 40;
            case PacketType::Bulk: return 20;
            default: return 0;
            }
        };
        
        int pri_a = get_priority(a.type);
        int pri_b = get_priority(b.type);
        
        if (pri_a != pri_b) {
            return pri_a < pri_b;
        }
        
        // 优先级相同则按到达时间（早的优先）
        return a.arrival_time > b.arrival_time;
    }
};

// 网络包处理器
class PacketProcessor {
private:
    concurrent_priority_queue<NetworkPacket, PacketComparator> m_packetQueue;
    vector<thread> m_processingThreads;
    atomic<bool> m_running;
    atomic<int> m_nextPacketId;
    atomic<long long> m_totalProcessed;
    atomic<long long> m_totalBytes;
    
public:
    PacketProcessor(int num_processors = 6) 
        : m_running(false), m_nextPacketId(1), 
          m_totalProcessed(0), m_totalBytes(0) {
        start_processors(num_processors);
    }
    
    ~PacketProcessor() {
        stop();
    }
    
    // 接收网络包
    void receive_packet(PacketType type, const string& src, 
                       const string& dest, const vector<unsigned char>& data) {
        NetworkPacket packet(m_nextPacketId++, type, src, dest, data);
        m_packetQueue.push(packet);
        
        println("收到包: ID={}, 类型={}, 大小={}字节, 源={}, 目标={}", 
               packet.id, packet_type_to_string(type), 
               data.size(), src, dest);
    }
    
    // 启动处理线程
    void start_processors(int num_processors) {
        m_running = true;
        for (int i = 0; i < num_processors; ++i) {
            m_processingThreads.emplace_back([this, i]() { process_packets(i); });
        }
        println("启动 {} 个包处理线程", num_processors);
    }
    
    // 停止处理器
    void stop() {
        m_running = false;
        for (auto& thread : m_processingThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_processingThreads.clear();
        
        println("包处理器停止。总计处理: {} 个包, {} 字节", 
               m_totalProcessed.load(), m_totalBytes.load());
    }
    
    // 获取统计信息
    void print_statistics() const {
        println("当前状态: 待处理包={}, 总计处理={}个包, {}字节", 
               m_packetQueue.size(), m_totalProcessed.load(), 
               m_totalBytes.load());
    }
    
private:
    // 包处理循环
    void process_packets(int processor_id) {
        random_device rd;
        mt19937 gen(rd());
        
        println("包处理线程 {} 启动", processor_id);
        
        while (m_running) {
            NetworkPacket packet(0, PacketType::Data, "", "", {});
            
            if (m_packetQueue.try_pop(packet)) {
                process_single_packet(packet, processor_id);
                m_totalProcessed++;
                m_totalBytes += packet.size;
            } else {
                // 队列为空，短暂休眠
                this_thread::sleep_for(chrono::milliseconds(1));
            }
        }
        
        println("包处理线程 {} 退出", processor_id);
    }
    
    // 处理单个包
    void process_single_packet(const NetworkPacket& packet, int processor_id) {
        auto start_time = chrono::system_clock::now();
        
        // 模拟处理时间（基于包类型和大小）
        int processing_time = calculate_processing_time(packet);
        
        println("线程 {} 处理包 {}: 类型={}, 大小={}字节, 预计时间={}ms", 
               processor_id, packet.id, packet_type_to_string(packet.type), 
               packet.size, processing_time);
        
        // 模拟处理
        this_thread::sleep_for(chrono::milliseconds(processing_time));
        
        auto end_time = chrono::system_clock::now();
        auto actual_time = chrono::duration_cast<chrono::milliseconds>(
            end_time - start_time);
        
        println("线程 {} 完成包 {}: 实际处理时间={}ms", 
               processor_id, packet.id, actual_time.count());
    }
    
    // 计算处理时间
    int calculate_processing_time(const NetworkPacket& packet) {
        int base_time = 0;
        switch (packet.type) {
        case PacketType::Control: base_time = 1; break;
        case PacketType::Voice: base_time = 2; break;
        case PacketType::Video: base_time = 5; break;
        case PacketType::Data: base_time = 10; break;
        case PacketType::Bulk: base_time = 20; break;
        }
        
        // 基于包大小调整时间
        return base_time + packet.size / 100;
    }
    
    // 包类型转字符串
    string packet_type_to_string(PacketType type) {
        switch (type) {
        case PacketType::Control: return "控制包";
        case PacketType::Voice: return "语音包";
        case PacketType::Video: return "视频包";
        case PacketType::Data: return "数据包";
        case PacketType::Bulk: return "批量包";
        default: return "未知";
        }
    }
};

// 网络流量模拟器
class TrafficSimulator {
private:
    PacketProcessor& m_processor;
    atomic<bool> m_running;
    thread m_simulatorThread;
    random_device m_rd;
    mt19937 m_gen;
    
public:
    TrafficSimulator(PacketProcessor& processor) 
        : m_processor(processor), m_running(false), m_gen(m_rd()) {}
    
    ~TrafficSimulator() {
        stop();
    }
    
    void start() {
        m_running = true;
        m_simulatorThread = thread([this]() { simulate_traffic(); });
        println("流量模拟器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_simulatorThread.joinable()) {
            m_simulatorThread.join();
        }
        println("流量模拟器停止");
    }
    
private:
    void simulate_traffic() {
        uniform_int_distribution<> type_dist(0, 4);
        uniform_int_distribution<> size_dist(64, 1500);
        uniform_int_distribution<> ip_part_dist(1, 254);
        
        vector<string> source_ips = {
            "192.168.1.1", "10.0.0.2", "172.16.0.3", "192.168.0.4"
        };
        
        vector<string> dest_ips = {
            "192.168.1.100", "10.0.0.101", "172.16.0.102", "192.168.0.103"
        };
        
        uniform_int_distribution<> ip_dist(0, 
            static_cast<int>(source_ips.size() - 1));
        
        int packet_count = 0;
        while (m_running && packet_count < 200) {
            // 随机生成包
            PacketType type = static_cast<PacketType>(type_dist(m_gen));
            string src_ip = source_ips[ip_dist(m_gen)];
            string dest_ip = dest_ips[ip_dist(m_gen)];
            
            // 生成随机负载
            int payload_size = size_dist(m_gen);
            vector<unsigned char> payload(payload_size);
            for (int i = 0; i < payload_size; ++i) {
                payload[i] = static_cast<unsigned char>(m_gen() % 256);
            }
            
            m_processor.receive_packet(type, src_ip, dest_ip, payload);
            
            packet_count++;
            
            // 随机间隔
            this_thread::sleep_for(chrono::milliseconds(m_gen() % 10));
        }
    }
};

int main() {
    println("=== 网络包优先级处理系统演示 ===");
    
    try {
        // 创建包处理器
        PacketProcessor processor(4);
        
        // 创建流量模拟器
        TrafficSimulator simulator(processor);
        
        // 启动模拟
        simulator.start();
        
        // 定期打印统计信息
        for (int i = 0; i < 10; ++i) {
            this_thread::sleep_for(chrono::seconds(1));
            processor.print_statistics();
        }
        
        // 停止系统
        simulator.stop();
        processor.stop();
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 性能优化建议

1. **合理设置比较器**：确保比较操作高效，避免复杂计算
2. **批量操作**：利用聚合器模式的批量处理优势
3. **内存预分配**：使用容量构造函数预分配内存
4. **避免虚假共享**：注意缓存行对齐
5. **合理选择优先级范围**：避免过于细粒度的优先级划分
6. **监控队列大小**：防止内存无限增长

## 总结

`<concurrent_priority_queue.h>` 提供了高效的并发优先级队列实现，特别适合需要按优先级处理任务的并发场景。通过聚合器模式减少锁竞争，结合高效的堆操作算法，为构建高性能并发应用程序提供了强大的基础设施。无论是实时系统、网络处理还是任务调度，都能从中获得显著的性能提升。

# <concurrent_queue.h> 详解

## 概述

`<concurrent_queue.h>` 是 Microsoft Visual C++ 并发运行时库的重要组成部分，提供了线程安全的并发队列实现。它基于 Intel Threading Building Blocks 的实现，允许多个线程同时进行入队和出队操作，支持先进先出（FIFO）的访问模式。

## 主要功能

- **并发安全**：支持多线程同时进行推送和弹出操作
- **无锁设计**：使用无锁算法减少线程竞争
- **高效性能**：优化的内存管理和页面分配策略
- **异常安全**：提供异常处理机制，确保操作完整性
- **内存管理**：支持自定义分配器进行内存管理
- **移动语义**：支持移动构造和移动赋值，提高性能
- **迭代器支持**：提供非线程安全的迭代器用于调试

## 核心类详解

### 基础内部类

#### `_Concurrent_queue_base_v4`

```cpp
class _Concurrent_queue_base_v4
```

并发队列的基类，提供类型无关的基础操作。

**主要方法：**
- `_Internal_push()`：内部入队操作
- `_Internal_move_push()`：移动入队操作
- `_Internal_pop_if_present()`：内部出队操作
- `_Internal_size()`：获取队列大小
- `_Internal_empty()`：检查队列是否为空

#### `_Micro_queue`

```cpp
struct _Micro_queue
```

微队列结构，使用简单锁定实现的队列。

**主要成员：**
- `_Head_page`：头页面指针
- `_Head_counter`：头计数器
- `_Tail_page`：尾页面指针
- `_Tail_counter`：尾计数器

#### `_Concurrent_queue_rep`

```cpp
class _Concurrent_queue_rep
```

并发队列的内部表示，管理多个微队列。

**主要特性：**
- 使用8个微队列分散竞争
- 采用黄金比例分布策略
- 缓存行对齐优化

### 迭代器类

#### `_Concurrent_queue_iterator_base_v4`

```cpp
class _Concurrent_queue_iterator_base_v4
```

并发队列迭代器基类，提供迭代器基础功能。

#### `_Concurrent_queue_iterator`

```cpp
template<typename _Container, typename _Value>
class _Concurrent_queue_iterator: public _Concurrent_queue_iterator_base_v4
```

并发队列迭代器模板类，支持前向迭代操作。

**迭代器类别：**
- `iterator_category`：前向迭代器
- `value_type`：值类型
- `difference_type`：差值类型
- `pointer`：指针类型
- `reference`：引用类型

### 主队列类

#### `concurrent_queue`

```cpp
template<typename _Ty, class _Ax = ::std::allocator<_Ty>>
class concurrent_queue: public ::Concurrency::details::_Concurrent_queue_base_v4
```

并发队列主类，提供线程安全的队列操作。

**模板参数：**
- `_Ty`：队列中存储的元素类型
- `_Ax`：分配器类型，默认为 `std::allocator<_Ty>`

**类型定义：**
- `value_type`：存储的数据类型
- `allocator_type`：分配器类型
- `reference`：元素引用类型
- `const_reference`：常量引用类型
- `size_type`：大小类型
- `difference_type`：差值类型
- `iterator`：迭代器类型
- `const_iterator`：常量迭代器类型

## 构造函数详解

### 默认构造函数

```cpp
explicit concurrent_queue(const allocator_type& _Al = allocator_type())
```

创建空的并发队列，可选指定分配器。

### 拷贝构造函数

```cpp
concurrent_queue(const concurrent_queue& _OtherQ, const allocator_type& _Al = allocator_type())
```

拷贝构造队列。

### 移动构造函数

```cpp
concurrent_queue(concurrent_queue&& _OtherQ, const allocator_type& _Al = allocator_type())
```

移动构造队列，提高性能。

### 迭代器范围构造函数

```cpp
template<typename _InputIterator>
concurrent_queue(_InputIterator _Begin, _InputIterator _End)
```

使用迭代器范围初始化队列。

## 主要成员函数

### 元素操作

#### `push()`

```cpp
void push( const _Ty& _Src )
void push( _Ty&& _Src )
```

向队列尾部添加元素（线程安全）。

#### `try_pop()`

```cpp
bool try_pop( _Ty& _Dest )
```

从队列头部弹出元素（线程安全）。

### 容量操作

#### `empty()`

```cpp
bool empty() const
```

检查队列是否为空（线程安全）。

#### `unsafe_size()`

```cpp
size_type unsafe_size() const
```

返回队列中的元素数量（非线程安全）。

### 容器管理操作

#### `clear()`

```cpp
void clear()
```

清空队列（非线程安全）。

#### `get_allocator()`

```cpp
allocator_type get_allocator() const
```

获取分配器副本（线程安全）。

### 迭代器操作

#### `unsafe_begin()`

```cpp
iterator unsafe_begin()
const_iterator unsafe_begin() const
```

获取队列起始迭代器（非线程安全）。

#### `unsafe_end()`

```cpp
iterator unsafe_end()
const_iterator unsafe_end() const
```

获取队列结束迭代器（非线程安全）。

## 内部实现机制

### 页面管理

队列使用页面（Page）结构管理元素存储：

```cpp
struct _Page {
    _Page* _Next;    // 下一个页面指针
    size_t _Mask;    // 页面掩码
};
```

### 无锁算法

采用多微队列设计减少竞争：
- 8个独立的微队列
- 使用票据（Ticket）系统跟踪位置
- 黄金比例分布策略分散访问

### 内存管理

支持自定义分配器：
- 页面级别的内存分配
- 异常安全的资源管理
- 移动语义优化

## 使用示例

### 基础并发队列

```cpp
#include <concurrent_queue.h>
#include <print>
#include <thread>
#include <vector>
#include <random>

using namespace Concurrency;
using namespace std;

void basic_concurrent_queue() {
    concurrent_queue<int> queue;
    
    // 多线程生产者
    vector<thread> producers;
    for (int i = 0; i < 3; ++i) {
        producers.emplace_back([&queue, i]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dis(1, 100);
            
            for (int j = 0; j < 5; ++j) {
                int value = dis(gen);
                queue.push(value);
                println("生产者 {} 入队: {}", i, value);
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        });
    }
    
    // 多线程消费者
    vector<thread> consumers;
    for (int i = 0; i < 2; ++i) {
        consumers.emplace_back([&queue, i]() {
            for (int j = 0; j < 7; ++j) {
                int value;
                if (queue.try_pop(value)) {
                    println("消费者 {} 出队: {}", i, value);
                } else {
                    println("消费者 {} 未能出队元素", i);
                }
                this_thread::sleep_for(chrono::milliseconds(20));
            }
        });
    }
    
    // 等待所有线程完成
    for (auto& t : producers) t.join();
    for (auto& t : consumers) t.join();
    
    // 检查剩余元素
    println("队列大小: {}", queue.unsafe_size());
    println("队列是否为空: {}", queue.empty());
}
```

### 自定义类型队列

```cpp
#include <concurrent_queue.h>
#include <print>
#include <string>

using namespace Concurrency;
using namespace std;

struct Message {
    int id;
    string content;
    chrono::system_clock::time_point timestamp;
    
    Message(int msg_id, const string& msg) 
        : id(msg_id), content(msg), timestamp(chrono::system_clock::now()) {}
};

void custom_type_queue() {
    concurrent_queue<Message> message_queue;
    
    // 添加消息
    message_queue.push(Message(1, "Hello World"));
    message_queue.push(Message(2, "Concurrent Queue"));
    message_queue.push(Message(3, "Multi-threading"));
    
    // 处理消息
    Message msg(0, "");
    while (message_queue.try_pop(msg)) {
        auto time = chrono::system_clock::to_time_t(msg.timestamp);
        println("处理消息 {}: {} (时间: {})", 
               msg.id, msg.content, ctime(&time));
    }
}
```

## 适用业务场景

1. **生产者-消费者模式** - 协调生产者和消费者线程
2. **任务队列系统** - 管理工作任务分发
3. **消息传递系统** - 处理异步消息
4. **数据流水线** - 构建数据处理管道
5. **网络包缓冲** - 缓冲网络数据包
6. **事件处理系统** - 处理并发事件

## 完整示例1：高性能日志系统

下面展示一个完整的高性能日志系统，使用并发队列实现异步日志记录：

```cpp
#include <concurrent_queue.h>
#include <fstream>
#include <thread>
#include <chrono>
#include <atomic>
#include <format>
#include <print>
#include <vector>
#include <string>

using namespace Concurrency;
using namespace std;

// 日志级别
enum class LogLevel {
    Debug,
    Info,
    Warning,
    Error,
    Critical
};

// 日志条目
struct LogEntry {
    LogLevel level;
    string message;
    string source;
    chrono::system_clock::time_point timestamp;
    thread::id thread_id;
    
    LogEntry(LogLevel lvl, const string& msg, const string& src = "")
        : level(lvl), message(msg), source(src), 
          timestamp(chrono::system_clock::now()),
          thread_id(this_thread::get_id()) {}
};

// 日志系统类
class AsyncLogger {
private:
    concurrent_queue<LogEntry> m_logQueue;
    ofstream m_logFile;
    thread m_logWorker;
    atomic<bool> m_running;
    string m_filename;
    
public:
    AsyncLogger(const string& filename) 
        : m_filename(filename), m_running(false) {
        start();
    }
    
    ~AsyncLogger() {
        stop();
    }
    
    // 启动日志系统
    void start() {
        m_logFile.open(m_filename, ios::app);
        if (!m_logFile.is_open()) {
            throw runtime_error("无法打开日志文件: " + m_filename);
        }
        
        m_running = true;
        m_logWorker = thread([this]() { process_logs(); });
        println("日志系统启动，文件: {}", m_filename);
    }
    
    // 停止日志系统
    void stop() {
        if (m_running) {
            m_running = false;
            if (m_logWorker.joinable()) {
                m_logWorker.join();
            }
            m_logFile.close();
            println("日志系统停止");
        }
    }
    
    // 记录日志
    void log(LogLevel level, const string& message, const string& source = "") {
        LogEntry entry(level, message, source);
        m_logQueue.push(entry);
    }
    
    // 便捷方法
    void debug(const string& message, const string& source = "") {
        log(LogLevel::Debug, message, source);
    }
    
    void info(const string& message, const string& source = "") {
        log(LogLevel::Info, message, source);
    }
    
    void warning(const string& message, const string& source = "") {
        log(LogLevel::Warning, message, source);
    }
    
    void error(const string& message, const string& source = "") {
        log(LogLevel::Error, message, source);
    }
    
    void critical(const string& message, const string& source = "") {
        log(LogLevel::Critical, message, source);
    }
    
    // 获取待处理日志数量
    size_t pending_logs() const {
        return m_logQueue.unsafe_size();
    }
    
private:
    // 处理日志的工作线程
    void process_logs() {
        println("日志处理线程启动");
        
        while (m_running || !m_logQueue.empty()) {
            LogEntry entry(LogLevel::Info, "");
            
            if (m_logQueue.try_pop(entry)) {
                write_log_entry(entry);
            } else {
                // 队列为空，短暂休眠
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        }
        
        println("日志处理线程退出");
    }
    
    // 写入日志条目
    void write_log_entry(const LogEntry& entry) {
        auto time_t = chrono::system_clock::to_time_t(entry.timestamp);
        tm local_time;
        localtime_s(&local_time, &time_t);
        
        string level_str = log_level_to_string(entry.level);
        string timestamp = format("{:04d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}",
                                 local_time.tm_year + 1900, local_time.tm_mon + 1,
                                 local_time.tm_mday, local_time.tm_hour,
                                 local_time.tm_min, local_time.tm_sec);
        
        string log_line = format("[{}] [{}] [Thread:{}] [{}] {}\n",
                               timestamp, level_str, entry.thread_id,
                               entry.source, entry.message);
        
        // 写入文件
        m_logFile << log_line;
        m_logFile.flush();
        
        // 同时输出到控制台（可选）
        print("{}", log_line);
    }
    
    // 日志级别转字符串
    string log_level_to_string(LogLevel level) {
        switch (level) {
        case LogLevel::Debug: return "DEBUG";
        case LogLevel::Info: return "INFO";
        case LogLevel::Warning: return "WARNING";
        case LogLevel::Error: return "ERROR";
        case LogLevel::Critical: return "CRITICAL";
        default: return "UNKNOWN";
        }
    }
};

// 模拟多线程应用
class Application {
private:
    AsyncLogger& m_logger;
    vector<thread> m_workerThreads;
    atomic<bool> m_running;
    
public:
    Application(AsyncLogger& logger) : m_logger(logger), m_running(false) {}
    
    void start() {
        m_running = true;
        
        // 启动多个工作线程
        for (int i = 0; i < 4; ++i) {
            m_workerThreads.emplace_back([this, i]() { worker_loop(i); });
        }
        
        m_logger.info("应用程序启动", "Application");
    }
    
    void stop() {
        m_running = false;
        for (auto& thread : m_workerThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_workerThreads.clear();
        
        m_logger.info("应用程序停止", "Application");
    }
    
private:
    void worker_loop(int worker_id) {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> work_dist(100, 1000);
        uniform_int_distribution<> level_dist(0, 4);
        
        string worker_name = "Worker_" + to_string(worker_id);
        
        m_logger.info(format("工作线程 {} 启动", worker_id), worker_name);
        
        int task_count = 0;
        while (m_running && task_count < 20) {
            // 模拟工作
            this_thread::sleep_for(chrono::milliseconds(work_dist(gen)));
            
            // 随机选择日志级别
            LogLevel level = static_cast<LogLevel>(level_dist(gen));
            string message = format("完成任务 #{}, 耗时 {}ms", 
                                  task_count, work_dist(gen));
            
            m_logger.log(level, message, worker_name);
            task_count++;
        }
        
        m_logger.info(format("工作线程 {} 完成 {} 个任务", worker_id, task_count), 
                     worker_name);
    }
};

int main() {
    println("=== 高性能异步日志系统演示 ===");
    
    try {
        // 创建日志系统
        AsyncLogger logger("application.log");
        
        // 创建应用程序
        Application app(logger);
        
        // 启动系统
        app.start();
        
        // 让系统运行一段时间
        this_thread::sleep_for(chrono::seconds(5));
        
        // 停止系统
        app.stop();
        
        // 等待所有日志处理完成
        println("等待日志处理完成...");
        while (logger.pending_logs() > 0) {
            println("剩余待处理日志: {}", logger.pending_logs());
            this_thread::sleep_for(chrono::milliseconds(100));
        }
        
        logger.stop();
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：图像处理流水线

```cpp
#include <concurrent_queue.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>
#include <algorithm>

using namespace Concurrency;
using namespace std;

// 图像数据
struct ImageData {
    int id;
    int width;
    int height;
    vector<unsigned char> pixels;
    string filename;
    
    ImageData(int img_id, int w, int h, const string& name) 
        : id(img_id), width(w), height(h), pixels(w * h * 3), filename(name) {}
};

// 处理阶段枚举
enum class ProcessingStage {
    Raw,           // 原始图像
    Denoised,      // 去噪后
    Enhanced,      // 增强后
    Final          // 最终结果
};

// 处理任务
struct ProcessingTask {
    ImageData image;
    ProcessingStage stage;
    chrono::system_clock::time_point enqueue_time;
    
    ProcessingTask(ImageData img, ProcessingStage s)
        : image(move(img)), stage(s), 
          enqueue_time(chrono::system_clock::now()) {}
};

// 图像处理流水线
class ImageProcessingPipeline {
private:
    // 各阶段队列
    concurrent_queue<ProcessingTask> m_rawQueue;
    concurrent_queue<ProcessingTask> m_denoiseQueue;
    concurrent_queue<ProcessingTask> m_enhanceQueue;
    concurrent_queue<ProcessingTask> m_finalQueue;
    
    // 工作线程
    vector<thread> m_denoiseWorkers;
    vector<thread> m_enhanceWorkers;
    vector<thread> m_finalWorkers;
    
    atomic<bool> m_running;
    atomic<int> m_processedCount;
    
public:
    ImageProcessingPipeline() : m_running(false), m_processedCount(0) {}
    
    ~ImageProcessingPipeline() {
        stop();
    }
    
    // 启动流水线
    void start(int denoise_workers = 2, int enhance_workers = 2, int final_workers = 1) {
        m_running = true;
        
        // 启动去噪工作线程
        for (int i = 0; i < denoise_workers; ++i) {
            m_denoiseWorkers.emplace_back([this, i]() { denoise_worker(i); });
        }
        
        // 启动增强工作线程
        for (int i = 0; i < enhance_workers; ++i) {
            m_enhanceWorkers.emplace_back([this, i]() { enhance_worker(i); });
        }
        
        // 启动最终处理工作线程
        for (int i = 0; i < final_workers; ++i) {
            m_finalWorkers.emplace_back([this, i]() { final_worker(i); });
        }
        
        println("图像处理流水线启动: {}去噪 + {}增强 + {}最终处理",
               denoise_workers, enhance_workers, final_workers);
    }
    
    // 停止流水线
    void stop() {
        m_running = false;
        
        // 等待所有工作线程完成
        for (auto& thread : m_denoiseWorkers) {
            if (thread.joinable()) thread.join();
        }
        for (auto& thread : m_enhanceWorkers) {
            if (thread.joinable()) thread.join();
        }
        for (auto& thread : m_finalWorkers) {
            if (thread.joinable()) thread.join();
        }
        
        m_denoiseWorkers.clear();
        m_enhanceWorkers.clear();
        m_finalWorkers.clear();
        
        println("图像处理流水线停止，总计处理: {} 张图像", m_processedCount.load());
    }
    
    // 提交原始图像
    void submit_image(ImageData image) {
        ProcessingTask task(move(image), ProcessingStage::Raw);
        m_rawQueue.push(task);
        
        println("提交图像: {}", task.image.filename);
    }
    
    // 获取统计信息
    void print_statistics() const {
        println("流水线状态:");
        println("  原始队列: {} 张", m_rawQueue.unsafe_size());
        println("  去噪队列: {} 张", m_denoiseQueue.unsafe_size());
        println("  增强队列: {} 张", m_enhanceQueue.unsafe_size());
        println("  最终队列: {} 张", m_finalQueue.unsafe_size());
        println("  已处理: {} 张", m_processedCount.load());
    }
    
private:
    // 去噪工作线程
    void denoise_worker(int worker_id) {
        println("去噪工作线程 {} 启动", worker_id);
        
        while (m_running) {
            ProcessingTask task(ImageData(0, 0, 0, ""), ProcessingStage::Raw);
            
            if (m_rawQueue.try_pop(task)) {
                // 模拟去噪处理
                println("线程 {} 去噪处理: {}", worker_id, task.image.filename);
                this_thread::sleep_for(chrono::milliseconds(50));
                
                // 推进到下一阶段
                task.stage = ProcessingStage::Denoised;
                m_denoiseQueue.push(task);
            } else {
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        }
        
        println("去噪工作线程 {} 退出", worker_id);
    }
    
    // 增强工作线程
    void enhance_worker(int worker_id) {
        println("增强工作线程 {} 启动", worker_id);
        
        while (m_running) {
            ProcessingTask task(ImageData(0, 0, 0, ""), ProcessingStage::Raw);
            
            if (m_denoiseQueue.try_pop(task)) {
                // 模拟增强处理
                println("线程 {} 增强处理: {}", worker_id, task.image.filename);
                this_thread::sleep_for(chrono::milliseconds(30));
                
                // 推进到下一阶段
                task.stage = ProcessingStage::Enhanced;
                m_enhanceQueue.push(task);
            } else {
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        }
        
        println("增强工作线程 {} 退出", worker_id);
    }
    
    // 最终处理工作线程
    void final_worker(int worker_id) {
        println("最终处理工作线程 {} 启动", worker_id);
        
        while (m_running) {
            ProcessingTask task(ImageData(0, 0, 0, ""), ProcessingStage::Raw);
            
            if (m_enhanceQueue.try_pop(task)) {
                // 模拟最终处理
                println("线程 {} 最终处理: {}", worker_id, task.image.filename);
                this_thread::sleep_for(chrono::milliseconds(20));
                
                // 完成处理
                task.stage = ProcessingStage::Final;
                auto process_time = chrono::duration_cast<chrono::milliseconds>(
                    chrono::system_clock::now() - task.enqueue_time);
                
                println("完成图像 {}: 总处理时间 {}ms", 
                       task.image.filename, process_time.count());
                
                m_processedCount++;
            } else {
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        }
        
        println("最终处理工作线程 {} 退出", worker_id);
    }
};

// 图像生成器
class ImageGenerator {
private:
    ImageProcessingPipeline& m_pipeline;
    atomic<bool> m_running;
    thread m_generatorThread;
    random_device m_rd;
    mt19937 m_gen;
    atomic<int> m_nextImageId;
    
public:
    ImageGenerator(ImageProcessingPipeline& pipeline) 
        : m_pipeline(pipeline), m_running(false), m_gen(m_rd()), m_nextImageId(1) {}
    
    ~ImageGenerator() {
        stop();
    }
    
    void start() {
        m_running = true;
        m_generatorThread = thread([this]() { generate_images(); });
        println("图像生成器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_generatorThread.joinable()) {
            m_generatorThread.join();
        }
        println("图像生成器停止");
    }
    
private:
    void generate_images() {
        uniform_int_distribution<> size_dist(100, 800);
        uniform_int_distribution<> delay_dist(10, 200);
        
        vector<string> image_names = {
            "landscape", "portrait", "building", "nature", "city",
            "animal", "flower", "sunset", "mountain", "river"
        };
        
        uniform_int_distribution<> name_dist(0, 
            static_cast<int>(image_names.size() - 1));
        
        int image_count = 0;
        while (m_running && image_count < 50) {
            // 生成随机图像
            int width = size_dist(m_gen);
            int height = size_dist(m_gen);
            string name = image_names[name_dist(m_gen)] + "_" + 
                         to_string(m_nextImageId++) + ".jpg";
            
            ImageData image(m_nextImageId.load(), width, height, name);
            
            // 提交到流水线
            m_pipeline.submit_image(move(image));
            
            image_count++;
            
            // 随机延迟
            this_thread::sleep_for(chrono::milliseconds(delay_dist(m_gen)));
        }
    }
};

int main() {
    println("=== 图像处理流水线演示 ===");
    
    try {
        // 创建处理流水线
        ImageProcessingPipeline pipeline;
        
        // 创建图像生成器
        ImageGenerator generator(pipeline);
        
        // 启动系统
        pipeline.start(3, 2, 2);
        generator.start();
        
        // 运行期间定期打印统计信息
        for (int i = 0; i < 8; ++i) {
            this_thread::sleep_for(chrono::seconds(1));
            pipeline.print_statistics();
        }
        
        // 停止系统
        generator.stop();
        pipeline.stop();
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 性能优化建议

1. **合理设置工作线程数**：根据处理阶段的工作负载调整线程数量
2. **批量处理**：在适当的时候使用批量操作减少队列竞争
3. **内存预分配**：对于固定大小的数据，考虑预分配内存
4. **避免虚假共享**：注意数据结构的缓存行对齐
5. **监控队列深度**：防止队列无限增长导致内存问题
6. **合理使用移动语义**：对于大型对象使用移动构造减少拷贝

## 总结

`<concurrent_queue.h>` 提供了高效的并发队列实现，特别适合构建生产者-消费者模式和多阶段处理流水线。通过无锁算法和优化的内存管理，它为构建高性能并发应用程序提供了可靠的基础设施。无论是日志系统、任务处理还是数据流水线，都能从中获得显著的性能优势。

# <concurrent_unordered_map.h> 详解

## 概述

`<concurrent_unordered_map.h>` 是 Microsoft Visual C++ 并发运行时库的重要组成部分，提供了线程安全的并发无序映射容器。它基于内部并发哈希表实现，允许多个线程同时进行插入、查找和删除操作，同时保持键值对的关联关系。

## 主要功能

- **并发安全**：支持多线程同时进行插入、查找和删除操作
- **哈希表实现**：使用哈希表提供平均O(1)时间复杂度的查找性能
- **键值对存储**：存储 `std::pair<const Key, Value>` 类型的元素
- **自定义哈希和比较**：支持自定义哈希函数和键比较函数
- **迭代器支持**：提供前向迭代器用于遍历元素
- **桶管理**：支持桶级别的操作和统计
- **内存管理**：支持自定义分配器进行内存管理

## 核心类详解

### 特性类

#### `_Concurrent_unordered_map_traits`

```cpp
template<typename _Key_type, typename _Element_type, typename _Key_comparator, typename _Allocator_type, bool _Allow_multimapping>
class _Concurrent_unordered_map_traits
```

并发无序映射特性类，定义映射容器的行为和特性。

**主要成员：**
- `value_type`：值类型，为 `std::pair<const Key, Value>`
- `key_type`：键类型
- `_Key_compare`：键比较器类型
- `_Value_compare`：值比较器类

### 主映射类

#### `concurrent_unordered_map`

```cpp
template <typename _Key_type, typename _Element_type, typename _Hasher = ::std::hash<_Key_type>, typename _Key_equality = ::std::equal_to<_Key_type>, typename _Allocator_type = ::std::allocator<::std::pair<const _Key_type, _Element_type>>>
class concurrent_unordered_map : public details::_Concurrent_hash<...>
```

并发无序映射主类，提供线程安全的键值对存储。

**模板参数：**
- `_Key_type`：键类型
- `_Element_type`：值类型
- `_Hasher`：哈希函数类型，默认为 `std::hash<_Key_type>`
- `_Key_equality`：键相等比较类型，默认为 `std::equal_to<_Key_type>`
- `_Allocator_type`：分配器类型

**类型定义：**
- `key_type`：键类型
- `mapped_type`：映射值类型
- `value_type`：值类型（键值对）
- `hasher`：哈希函数类型
- `key_equal`：键相等比较类型
- `allocator_type`：分配器类型
- `iterator`：迭代器类型
- `const_iterator`：常量迭代器类型

#### `concurrent_unordered_multimap`

```cpp
template <typename _Key_type, typename _Element_type, typename _Hasher = ::std::hash<_Key_type>, typename _Key_equality = ::std::equal_to<_Key_type>, typename _Allocator_type = ::std::allocator<::std::pair<const _Key_type, _Element_type>>>
class concurrent_unordered_multimap : public details::_Concurrent_hash<...>
```

并发无序多重映射类，允许重复键的线程安全映射容器。

## 构造函数详解

### 默认构造函数

```cpp
explicit concurrent_unordered_map(size_type _Number_of_buckets = 8, const hasher& _Hasharg = hasher(), const key_equal& _Keyeqarg = key_equal(), const allocator_type& _Allocator = allocator_type())
```

创建空的并发无序映射，可指定桶数量、哈希函数、比较函数和分配器。

### 迭代器范围构造函数

```cpp
template <typename _Iterator>
concurrent_unordered_map(_Iterator _Begin, _Iterator _End, size_type _Number_of_buckets = 8, const hasher& _Hasharg = hasher(), const key_equal& _Keyeqarg = key_equal(), const allocator_type& _Allocator = allocator_type())
```

使用迭代器范围初始化映射。

### 拷贝构造函数

```cpp
concurrent_unordered_map(const concurrent_unordered_map& _Umap)
concurrent_unordered_map(const concurrent_unordered_map& _Umap, const allocator_type& _Allocator)
```

拷贝构造映射。

### 移动构造函数

```cpp
concurrent_unordered_map(concurrent_unordered_map&& _Umap)
```

移动构造映射，提高性能。

## 主要成员函数

### 元素操作

#### `insert()`

```cpp
::std::pair<iterator, bool> insert(const value_type& _Value)
iterator insert(const_iterator _Where, const value_type& _Value)
template<class _Iterator> void insert(_Iterator _First, _Iterator _Last)
```

向映射中插入元素（线程安全）。

#### `unsafe_erase()`

```cpp
iterator unsafe_erase(const_iterator _Where)
size_type unsafe_erase(const key_type& _Keyval)
iterator unsafe_erase(const_iterator _First, const_iterator _Last)
```

从映射中删除元素（非线程安全）。

### 元素访问

#### `operator[]`

```cpp
mapped_type& operator[](const key_type& _Keyval)
mapped_type& operator[](key_type&& _Keyval)
```

通过键访问或插入元素（线程安全）。

#### `at()`

```cpp
mapped_type& at(const key_type& _Keyval)
const mapped_type& at(const key_type& _Keyval) const
```

通过键访问元素，键不存在时抛出异常（线程安全）。

### 查找操作

#### `find()`

```cpp
iterator find(const key_type& _Keyval)
const_iterator find(const key_type& _Keyval) const
```

查找指定键的元素（线程安全）。

#### `count()`

```cpp
size_type count(const key_type& _Keyval) const
```

统计指定键的元素数量（线程安全）。

#### `equal_range()`

```cpp
::std::pair<iterator, iterator> equal_range(const key_type& _Keyval)
::std::pair<const_iterator, const_iterator> equal_range(const key_type& _Keyval) const
```

查找指定键的元素范围（线程安全）。

### 容器信息

#### `size()`

```cpp
size_type size() const
```

返回映射中的元素数量（线程安全）。

#### `empty()`

```cpp
bool empty() const
```

检查映射是否为空（线程安全）。

#### `bucket_count()`

```cpp
size_type bucket_count() const
```

返回桶的数量（线程安全）。

### 哈希和比较

#### `hash_function()`

```cpp
hasher hash_function() const
```

获取存储的哈希函数对象。

#### `key_eq()`

```cpp
key_equal key_eq() const
```

获取存储的相等比较函数对象。

### 容器管理

#### `swap()`

```cpp
void swap(concurrent_unordered_map& _Umap)
```

交换两个映射的内容（非线程安全）。

#### `clear()`

```cpp
void clear()
```

清空映射（非线程安全）。

#### `rehash()`

```cpp
void rehash(size_type _Buckets)
```

重新哈希映射，调整桶数量。

## 使用示例

### 基础并发无序映射

```cpp
#include <concurrent_unordered_map.h>
#include <print>
#include <thread>
#include <vector>
#include <random>

using namespace Concurrency;
using namespace std;

void basic_concurrent_unordered_map() {
    concurrent_unordered_map<string, int> word_count;
    
    // 多线程插入数据
    vector<thread> writers;
    vector<string> words = {"apple", "banana", "cherry", "date", "elderberry"};
    
    for (int i = 0; i < 3; ++i) {
        writers.emplace_back([&word_count, &words, i]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dis(0, words.size() - 1);
            uniform_int_distribution<> count_dis(1, 10);
            
            for (int j = 0; j < 10; ++j) {
                string word = words[dis(gen)];
                int count = count_dis(gen);
                
                // 使用operator[]插入或更新
                word_count[word] += count;
                println("线程 {} 增加 {}: +{}", i, word, count);
                
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        });
    }
    
    // 多线程读取数据
    vector<thread> readers;
    for (int i = 0; i < 2; ++i) {
        readers.emplace_back([&word_count, i]() {
            for (int j = 0; j < 5; ++j) {
                println("线程 {} 读取统计:", i);
                for (const auto& [word, count] : word_count) {
                    println("  {}: {}", word, count);
                }
                this_thread::sleep_for(chrono::milliseconds(50));
            }
        });
    }
    
    // 等待所有线程完成
    for (auto& t : writers) t.join();
    for (auto& t : readers) t.join();
    
    // 最终统计
    println("最终统计:");
    for (const auto& [word, count] : word_count) {
        println("{}: {}", word, count);
    }
}
```

### 自定义哈希函数

```cpp
#include <concurrent_unordered_map.h>
#include <print>
#include <string>

using namespace Concurrency;
using namespace std;

// 自定义键类型
struct EmployeeId {
    int department;
    int employee_number;
    
    bool operator==(const EmployeeId& other) const {
        return department == other.department && employee_number == other.employee_number;
    }
};

// 自定义哈希函数
struct EmployeeIdHash {
    size_t operator()(const EmployeeId& id) const {
        return hash<int>{}(id.department) ^ (hash<int>{}(id.employee_number) << 1);
    }
};

// 自定义键比较
struct EmployeeIdEqual {
    bool operator()(const EmployeeId& a, const EmployeeId& b) const {
        return a.department == b.department && a.employee_number == b.employee_number;
    }
};

void custom_hash_example() {
    concurrent_unordered_map<EmployeeId, string, EmployeeIdHash, EmployeeIdEqual> employees;
    
    // 插入员工数据
    employees.insert({EmployeeId{1, 1001}, "Alice Johnson"});
    employees.insert({EmployeeId{1, 1002}, "Bob Smith"});
    employees.insert({EmployeeId{2, 2001}, "Charlie Brown"});
    employees.insert({EmployeeId{2, 2002}, "Diana Prince"});
    
    // 查找员工
    EmployeeId id{1, 1001};
    auto it = employees.find(id);
    if (it != employees.end()) {
        println("找到员工: {} -> {}", id.employee_number, it->second);
    }
    
    // 遍历所有员工
    println("所有员工:");
    for (const auto& [emp_id, name] : employees) {
        println("  部门{} 工号{}: {}", emp_id.department, emp_id.employee_number, name);
    }
}
```

## 适用业务场景

1. **缓存系统** - 实现线程安全的缓存存储
2. **会话管理** - 管理用户会话数据
3. **配置存储** - 存储应用程序配置
4. **数据索引** - 构建数据索引结构
5. **统计计数** - 实时统计和计数
6. **资源管理** - 管理共享资源

## 完整示例1：高性能缓存系统

下面展示一个完整的高性能缓存系统，使用并发无序映射实现线程安全的缓存：

```cpp
#include <concurrent_unordered_map.h>
#include <chrono>
#include <thread>
#include <atomic>
#include <format>
#include <print>
#include <vector>
#include <string>
#include <random>

using namespace Concurrency;
using namespace std;

// 缓存条目
template<typename T>
struct CacheEntry {
    T value;
    chrono::system_clock::time_point timestamp;
    chrono::seconds time_to_live;
    size_t access_count;
    
    CacheEntry(const T& val, chrono::seconds ttl)
        : value(val), timestamp(chrono::system_clock::now()), 
          time_to_live(ttl), access_count(0) {}
    
    bool is_expired() const {
        auto now = chrono::system_clock::now();
        return (now - timestamp) > time_to_live;
    }
    
    void update_access() {
        access_count++;
    }
};

// 高性能缓存类
template<typename Key, typename Value>
class ConcurrentCache {
private:
    concurrent_unordered_map<Key, CacheEntry<Value>> m_cache;
    atomic<size_t> m_hit_count;
    atomic<size_t> m_miss_count;
    atomic<size_t> m_eviction_count;
    size_t m_max_size;
    
public:
    ConcurrentCache(size_t max_size = 1000) 
        : m_max_size(max_size), m_hit_count(0), m_miss_count(0), m_eviction_count(0) {}
    
    // 获取值
    optional<Value> get(const Key& key) {
        auto it = m_cache.find(key);
        if (it != m_cache.end()) {
            auto& entry = it->second;
            
            if (entry.is_expired()) {
                // 条目已过期，删除
                m_cache.unsafe_erase(it);
                m_miss_count++;
                return nullopt;
            }
            
            // 更新访问统计
            entry.update_access();
            m_hit_count++;
            return entry.value;
        }
        
        m_miss_count++;
        return nullopt;
    }
    
    // 设置值
    void set(const Key& key, const Value& value, chrono::seconds ttl = chrono::seconds(300)) {
        // 检查是否需要清理
        if (m_cache.size() >= m_max_size) {
            cleanup_expired();
        }
        
        CacheEntry<Value> entry(value, ttl);
        m_cache.insert({key, entry});
    }
    
    // 删除值
    bool remove(const Key& key) {
        return m_cache.unsafe_erase(key) > 0;
    }
    
    // 检查是否存在
    bool contains(const Key& key) {
        auto it = m_cache.find(key);
        if (it != m_cache.end()) {
            return !it->second.is_expired();
        }
        return false;
    }
    
    // 清理过期条目
    void cleanup_expired() {
        vector<Key> expired_keys;
        
        // 收集过期键
        for (const auto& [key, entry] : m_cache) {
            if (entry.is_expired()) {
                expired_keys.push_back(key);
            }
        }
        
        // 删除过期条目
        for (const auto& key : expired_keys) {
            if (m_cache.unsafe_erase(key) > 0) {
                m_eviction_count++;
            }
        }
        
        if (!expired_keys.empty()) {
            println("清理了 {} 个过期条目", expired_keys.size());
        }
    }
    
    // 获取缓存统计
    void print_stats() const {
        size_t current_size = m_cache.size();
        size_t total_requests = m_hit_count + m_miss_count;
        double hit_ratio = total_requests > 0 ? 
            (static_cast<double>(m_hit_count) / total_requests) * 100.0 : 0.0;
        
        println("缓存统计:");
        println("  当前大小: {}", current_size);
        println("  命中次数: {}", m_hit_count.load());
        println("  未命中次数: {}", m_miss_count.load());
        println("  驱逐次数: {}", m_eviction_count.load());
        println("  命中率: {:.2f}%", hit_ratio);
        println("  最大容量: {}", m_max_size);
    }
    
    // 获取缓存大小
    size_t size() const {
        return m_cache.size();
    }
    
    // 清空缓存
    void clear() {
        m_cache.clear();
        m_hit_count = 0;
        m_miss_count = 0;
        m_eviction_count = 0;
    }
};

// 模拟数据获取函数
string fetch_data_from_database(const string& key) {
    this_thread::sleep_for(chrono::milliseconds(10)); // 模拟数据库延迟
    return "Data for " + key + " at " + to_string(chrono::system_clock::to_time_t(chrono::system_clock::now()));
}

// 缓存测试
void cache_performance_test() {
    println("=== 高性能缓存系统测试 ===");
    
    ConcurrentCache<string, string> cache(500);
    vector<thread> clients;
    
    vector<string> test_keys = {
        "user_profile_", "product_info_", "order_details_", 
        "inventory_status_", "price_list_", "config_"
    };
    
    // 创建客户端线程
    for (int client_id = 0; client_id < 5; ++client_id) {
        clients.emplace_back([&cache, &test_keys, client_id]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> key_dist(0, test_keys.size() - 1);
            uniform_int_distribution<> index_dist(1, 100);
            uniform_real_distribution<> action_dist(0.0, 1.0);
            
            for (int request = 0; request < 100; ++request) {
                string key = test_keys[key_dist(gen)] + to_string(index_dist(gen));
                
                if (action_dist(gen) < 0.8) {
                    // 80% 的请求是读取
                    auto data = cache.get(key);
                    if (!data) {
                        // 缓存未命中，从数据库获取并缓存
                        string new_data = fetch_data_from_database(key);
                        cache.set(key, new_data, chrono::seconds(30));
                        println("客户端 {} 缓存未命中，加载: {}", client_id, key);
                    } else {
                        println("客户端 {} 缓存命中: {}", client_id, key);
                    }
                } else {
                    // 20% 的请求是写入/更新
                    string new_data = "Updated data for " + key;
                    cache.set(key, new_data, chrono::seconds(60));
                    println("客户端 {} 更新缓存: {}", client_id, key);
                }
                
                this_thread::sleep_for(chrono::milliseconds(5));
            }
        });
    }
    
    // 定期打印统计信息
    thread stats_thread([&cache]() {
        for (int i = 0; i < 10; ++i) {
            this_thread::sleep_for(chrono::seconds(1));
            cache.print_stats();
            println("---");
        }
    });
    
    // 等待所有客户端完成
    for (auto& client : clients) {
        client.join();
    }
    
    stats_thread.join();
    
    // 最终统计
    println("最终统计结果:");
    cache.print_stats();
    cache.cleanup_expired();
    println("清理后大小: {}", cache.size());
}

int main() {
    cache_performance_test();
    return 0;
}
```

## 完整示例2：实时数据统计系统

```cpp
#include <concurrent_unordered_map.h>
#include <atomic>
#include <thread>
#include <vector>
#include <random>
#include <chrono>
#include <format>
#include <print>

using namespace Concurrency;
using namespace std;

// 事件类型
enum class EventType {
    PageView,
    Click,
    Purchase,
    Login,
    Search,
    Download
};

// 事件数据
struct EventData {
    string user_id;
    string session_id;
    chrono::system_clock::time_point timestamp;
    map<string, string> properties;
    
    EventData(string user, string session) 
        : user_id(move(user)), session_id(move(session)), 
          timestamp(chrono::system_clock::now()) {}
};

// 实时统计器
class RealTimeStatistics {
private:
    // 用户行为统计
    concurrent_unordered_map<string, atomic<size_t>> m_user_activity;
    
    // 事件类型统计
    concurrent_unordered_map<EventType, atomic<size_t>> m_event_counts;
    
    // 会话统计
    concurrent_unordered_map<string, vector<EventType>> m_session_events;
    
    // 时间窗口统计 (分钟级)
    concurrent_unordered_map<string, atomic<size_t>> m_minute_stats;
    
public:
    // 记录事件
    void record_event(const EventData& event, EventType type) {
        // 更新用户活动统计
        m_user_activity[event.user_id]++;
        
        // 更新事件类型统计
        m_event_counts[type]++;
        
        // 更新会话事件
        m_session_events[event.session_id].push_back(type);
        
        // 更新时间窗口统计
        auto time_key = get_current_minute_key();
        m_minute_stats[time_key]++;
        
        println("记录事件: 用户={}, 会话={}, 类型={}", 
               event.user_id, event.session_id, event_type_to_string(type));
    }
    
    // 获取用户活动统计
    size_t get_user_activity(const string& user_id) const {
        auto it = m_user_activity.find(user_id);
        return it != m_user_activity.end() ? it->second.load() : 0;
    }
    
    // 获取事件类型统计
    size_t get_event_count(EventType type) const {
        auto it = m_event_counts.find(type);
        return it != m_event_counts.end() ? it->second.load() : 0;
    }
    
    // 获取会话事件
    vector<EventType> get_session_events(const string& session_id) const {
        auto it = m_session_events.find(session_id);
        return it != m_session_events.end() ? it->second : vector<EventType>{};
    }
    
    // 获取当前分钟统计
    size_t get_current_minute_count() const {
        auto time_key = get_current_minute_key();
        auto it = m_minute_stats.find(time_key);
        return it != m_minute_stats.end() ? it->second.load() : 0;
    }
    
    // 获取活跃用户数
    size_t get_active_user_count() const {
        return m_user_activity.size();
    }
    
    // 获取活跃会话数
    size_t get_active_session_count() const {
        return m_session_events.size();
    }
    
    // 打印统计摘要
    void print_summary() const {
        println("=== 实时统计摘要 ===");
        println("活跃用户数: {}", get_active_user_count());
        println("活跃会话数: {}", get_active_session_count());
        println("当前分钟事件数: {}", get_current_minute_count());
        
        println("事件类型统计:");
        for (int i = 0; i <= static_cast<int>(EventType::Download); ++i) {
            EventType type = static_cast<EventType>(i);
            println("  {}: {}", event_type_to_string(type), get_event_count(type));
        }
        
        // 显示前5个最活跃用户
        println("最活跃用户:");
        vector<pair<string, size_t>> top_users;
        for (const auto& [user, count] : m_user_activity) {
            top_users.emplace_back(user, count.load());
        }
        
        sort(top_users.begin(), top_users.end(), 
             [](const auto& a, const auto& b) { return a.second > b.second; });
        
        for (size_t i = 0; i < min(size_t(5), top_users.size()); ++i) {
            println("  {}: {} 次活动", top_users[i].first, top_users[i].second);
        }
    }
    
    // 清理过期数据（模拟实现）
    void cleanup_old_data() {
        auto current_time = chrono::system_clock::now();
        auto threshold = current_time - chrono::hours(1); // 保留1小时数据
        
        // 这里简化实现，实际中需要更复杂的时间管理
        println("执行数据清理...");
    }
    
private:
    // 获取当前分钟键
    string get_current_minute_key() const {
        auto now = chrono::system_clock::now();
        auto time_t = chrono::system_clock::to_time_t(now);
        tm local_time;
        localtime_s(&local_time, &time_t);
        return format("{:04d}{:02d}{:02d}{:02d}{:02d}", 
                     local_time.tm_year + 1900, local_time.tm_mon + 1,
                     local_time.tm_mday, local_time.tm_hour, local_time.tm_min);
    }
    
    // 事件类型转字符串
    string event_type_to_string(EventType type) const {
        switch (type) {
        case EventType::PageView: return "页面浏览";
        case EventType::Click: return "点击";
        case EventType::Purchase: return "购买";
        case EventType::Login: return "登录";
        case EventType::Search: return "搜索";
        case EventType::Download: return "下载";
        default: return "未知";
        }
    }
};

// 事件生成器
class EventGenerator {
private:
    RealTimeStatistics& m_stats;
    atomic<bool> m_running;
    vector<thread> m_generator_threads;
    
public:
    EventGenerator(RealTimeStatistics& stats) : m_stats(stats), m_running(false) {}
    
    ~EventGenerator() {
        stop();
    }
    
    void start(int num_generators = 3) {
        m_running = true;
        for (int i = 0; i < num_generators; ++i) {
            m_generator_threads.emplace_back([this, i]() { generate_events(i); });
        }
        println("启动 {} 个事件生成器", num_generators);
    }
    
    void stop() {
        m_running = false;
        for (auto& thread : m_generator_threads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_generator_threads.clear();
        println("事件生成器停止");
    }
    
private:
    void generate_events(int generator_id) {
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> user_dist(1, 50);
        uniform_int_distribution<> session_dist(1, 20);
        uniform_int_distribution<> event_dist(0, static_cast<int>(EventType::Download));
        uniform_int_distribution<> delay_dist(10, 200);
        
        vector<string> user_prefixes = {"user", "customer", "visitor", "client"};
        uniform_int_distribution<> prefix_dist(0, user_prefixes.size() - 1);
        
        while (m_running) {
            // 生成随机用户和会话
            string user_id = user_prefixes[prefix_dist(gen)] + "_" + to_string(user_dist(gen));
            string session_id = "session_" + to_string(session_dist(gen));
            
            // 生成随机事件
            EventType type = static_cast<EventType>(event_dist(gen));
            EventData event(user_id, session_id);
            
            // 添加一些随机属性
            event.properties["source"] = "generator_" + to_string(generator_id);
            event.properties["ip"] = "192.168.1." + to_string(generator_id + 1);
            
            // 记录事件
            m_stats.record_event(event, type);
            
            // 随机延迟
            this_thread::sleep_for(chrono::milliseconds(delay_dist(gen)));
        }
    }
};

int main() {
    println("=== 实时数据统计系统演示 ===");
    
    RealTimeStatistics stats;
    EventGenerator generator(stats);
    
    // 启动事件生成
    generator.start(4);
    
    // 定期打印统计信息
    println("系统运行中，定期输出统计信息...");
    for (int i = 0; i < 8; ++i) {
        this_thread::sleep_for(chrono::seconds(3));
        stats.print_summary();
        println("---");
    }
    
    // 停止系统
    generator.stop();
    
    // 最终统计
    println("最终统计结果:");
    stats.print_summary();
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 性能优化建议

1. **合理设置桶数量**：根据预期数据量设置合适的初始桶数量
2. **选择合适的哈希函数**：确保哈希函数分布均匀且计算高效
3. **避免频繁重新哈希**：预分配足够的桶空间减少重新哈希
4. **使用适当的键类型**：选择简单高效的键类型
5. **批量操作**：在可能的情况下使用批量插入和删除
6. **定期清理**：对于缓存类应用，定期清理过期数据

## 总结

`<concurrent_unordered_map.h>` 提供了高效的并发无序映射实现，特别适合构建需要高性能键值存储的并发应用程序。通过优化的哈希表实现和线程安全操作，它为缓存系统、实时统计、会话管理等场景提供了强大的基础设施。无论是单键映射还是允许多重键的映射，都能满足不同业务场景的需求。

# <concurrent_unordered_set.h> 详解

## 概述

`<concurrent_unordered_set.h>` 是 Microsoft Visual C++ 并发运行时库的重要组成部分，提供了线程安全的并发无序集合实现。它基于哈希表数据结构，允许多个线程同时进行插入、查找和遍历操作，支持高效的并发访问。

## 主要功能

- **并发安全**：支持多线程同时进行插入、查找和删除操作
- **哈希表实现**：基于哈希桶的存储结构，提供平均O(1)的访问复杂度
- **无锁读取**：读取操作通常无需锁定，提供高性能并发访问
- **迭代器支持**：提供线程安全的迭代器遍历功能
- **内存管理**：支持自定义分配器进行内存管理
- **移动语义**：支持移动构造和移动赋值，提高性能
- **桶接口**：提供对哈希桶的直接访问和操作

## 核心类详解

### 基础内部类

#### `_Concurrent_unordered_set_traits`

```cpp
template<typename _Key_type, typename _Key_comparator, typename _Allocator_type, bool _Allow_multimapping>
class _Concurrent_unordered_set_traits
```

并发无序集合特性类，定义集合的基本特性和行为。

**模板参数：**
- `_Key_type`：键类型
- `_Key_comparator`：键比较器类型
- `_Allocator_type`：分配器类型
- `_Allow_multimapping`：是否允许多重映射

#### `_Hash_compare`

```cpp
template<typename _Key_type, typename _Hasher, typename _Key_equality>
class _Hash_compare
```

哈希比较器类，封装哈希函数和键相等比较。

### 主集合类

#### `concurrent_unordered_set`

```cpp
template <typename _Key_type, typename _Hasher = ::std::hash<_Key_type>, 
          typename _Key_equality = ::std::equal_to<_Key_type>, 
          typename _Allocator_type = ::std::allocator<_Key_type>>
class concurrent_unordered_set
```

并发无序集合主类，提供线程安全的集合操作，不允许重复元素。

**模板参数：**
- `_Key_type`：集合中存储的键类型
- `_Hasher`：哈希函数类型，默认为 `std::hash<_Key_type>`
- `_Key_equality`：键相等比较器类型，默认为 `std::equal_to<_Key_type>`
- `_Allocator_type`：分配器类型，默认为 `std::allocator<_Key_type>`

**类型定义：**
- `key_type`：键类型
- `value_type`：值类型（与键类型相同）
- `hasher`：哈希函数类型
- `key_equal`：键相等比较器类型
- `allocator_type`：分配器类型
- `size_type`：大小类型
- `difference_type`：差值类型
- `iterator`：迭代器类型
- `const_iterator`：常量迭代器类型
- `local_iterator`：桶迭代器类型
- `const_local_iterator`：常量桶迭代器类型

#### `concurrent_unordered_multiset`

```cpp
template <typename _Key_type, typename _Hasher = ::std::hash<_Key_type>,
          typename _Key_equality = ::std::equal_to<_Key_type>, 
          typename _Allocator_type = ::std::allocator<_Key_type>>
class concurrent_unordered_multiset
```

并发无序多重集合类，提供线程安全的集合操作，允许重复元素。

## 构造函数详解

### 默认构造函数

```cpp
explicit concurrent_unordered_set(size_type _Number_of_buckets = 8, 
                                 const hasher& _Hasharg = hasher(), 
                                 const key_equal& _Keyeqarg = key_equal(),
                                 const allocator_type& _Allocator = allocator_type())
```

创建空的并发无序集合，可指定初始桶数、哈希函数、相等比较器和分配器。

### 迭代器范围构造函数

```cpp
template <typename _Iterator>
concurrent_unordered_set(_Iterator _First, _Iterator _Last, 
                        size_type _Number_of_buckets = 8,
                        const hasher& _Hasharg = hasher(),
                        const key_equal& _Keyeqarg = key_equal(), 
                        const allocator_type& _Allocator = allocator_type())
```

使用迭代器范围初始化集合。

### 拷贝构造函数

```cpp
concurrent_unordered_set(const concurrent_unordered_set& _Uset)
concurrent_unordered_set(const concurrent_unordered_set& _Uset, 
                        const allocator_type& _Allocator)
```

拷贝构造集合。

### 移动构造函数

```cpp
concurrent_unordered_set(concurrent_unordered_set&& _Uset)
concurrent_unordered_set(concurrent_unordered_set&& _Uset, 
                        const allocator_type& _Allocator)
```

移动构造集合，提高性能。

## 主要成员函数

### 容量操作

#### `empty()`

```cpp
bool empty() const
```

检查集合是否为空（线程安全）。

#### `size()`

```cpp
size_type size() const
```

返回集合中的元素数量（线程安全）。

#### `max_size()`

```cpp
size_type max_size() const
```

返回集合可容纳的最大元素数量。

### 元素操作

#### `insert()`

```cpp
::std::pair<iterator, bool> insert(const value_type& _Value)
iterator insert(const_iterator _Where, const value_type& _Value)
template<class _Iterator> void insert(_Iterator _First, _Iterator _Last)
template<class _Valty> ::std::pair<iterator, bool> insert(_Valty&& _Value)
```

向集合插入元素（线程安全）。对于 `concurrent_unordered_set`，返回插入结果对（迭代器和是否插入成功）；对于 `concurrent_unordered_multiset`，总是返回插入位置的迭代器。

#### `unsafe_erase()`

```cpp
iterator unsafe_erase(const_iterator _Where)
size_type unsafe_erase(const key_type& _Keyval)
iterator unsafe_erase(const_iterator _First, const_iterator _Last)
```

从集合删除元素（非线程安全）。

### 查找操作

#### `find()`

```cpp
iterator find(const key_type& _Keyval)
const_iterator find(const key_type& _Keyval) const
```

查找指定键的元素（线程安全）。

#### `count()`

```cpp
size_type count(const key_type& _Keyval) const
```

返回指定键的元素数量（线程安全）。

#### `equal_range()`

```cpp
::std::pair<iterator, iterator> equal_range(const key_type& _Keyval)
::std::pair<const_iterator, const_iterator> equal_range(const key_type& _Keyval) const
```

返回匹配指定键的元素范围（线程安全）。

### 桶操作

#### `bucket_count()`

```cpp
size_type bucket_count() const
```

返回桶的数量。

#### `bucket_size()`

```cpp
size_type bucket_size(size_type _Bucket) const
```

返回指定桶中的元素数量。

#### `bucket()`

```cpp
size_type bucket(const key_type& _Keyval) const
```

返回指定键所在的桶索引。

### 哈希策略

#### `load_factor()`

```cpp
float load_factor() const
```

返回当前负载因子。

#### `max_load_factor()`

```cpp
float max_load_factor() const
void max_load_factor(float _Newmax)
```

获取或设置最大负载因子。

#### `rehash()`

```cpp
void rehash(size_type _Buckets)
```

重新哈希，设置桶的数量。

#### `reserve()`

```cpp
void reserve(size_type _Count)
```

保留空间以容纳指定数量的元素。

### 工具函数

#### `hash_function()`

```cpp
hasher hash_function() const
```

返回哈希函数对象。

#### `key_eq()`

```cpp
key_equal key_eq() const
```

返回键相等比较函数对象。

## 内部实现机制

### 哈希表结构

基于分段哈希表实现：
- 多个哈希桶分散竞争
- 每个桶使用细粒度锁保护
- 读取操作通常无需锁定

### 并发控制

- **插入操作**：使用桶级锁保护
- **查找操作**：通常无锁，使用原子操作
- **删除操作**：使用桶级锁保护
- **遍历操作**：提供快照一致性

### 内存管理

支持自定义分配器：
- 桶级别的内存分配
- 异常安全的资源管理
- 移动语义优化

## 使用示例

### 基础并发无序集合

```cpp
#include <concurrent_unordered_set.h>
#include <print>
#include <thread>
#include <vector>
#include <random>

using namespace Concurrency;
using namespace std;

void basic_concurrent_unordered_set() {
    concurrent_unordered_set<int> number_set;
    
    // 多线程插入数据
    vector<thread> writers;
    for (int i = 0; i < 4; ++i) {
        writers.emplace_back([&number_set, i]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dis(1, 50);
            
            for (int j = 0; j < 10; ++j) {
                int value = dis(gen);
                auto result = number_set.insert(value);
                if (result.second) {
                    println("线程 {} 插入: {} (成功)", i, value);
                } else {
                    println("线程 {} 插入: {} (重复)", i, value);
                }
                this_thread::sleep_for(chrono::milliseconds(5));
            }
        });
    }
    
    // 等待写入完成
    for (auto& t : writers) t.join();
    
    // 多线程查找数据
    vector<thread> readers;
    for (int i = 0; i < 3; ++i) {
        readers.emplace_back([&number_set, i]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dis(1, 50);
            
            for (int j = 0; j < 8; ++j) {
                int value = dis(gen);
                auto it = number_set.find(value);
                if (it != number_set.end()) {
                    println("线程 {} 查找: {} (存在)", i, value);
                } else {
                    println("线程 {} 查找: {} (不存在)", i, value);
                }
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        });
    }
    
    // 等待读取完成
    for (auto& t : readers) t.join();
    
    // 输出统计信息
    println("集合大小: {}", number_set.size());
    println("桶数量: {}", number_set.bucket_count());
    println("负载因子: {:.2f}", number_set.load_factor());
    
    // 遍历所有元素
    println("集合内容:");
    for (const auto& value : number_set) {
        println("  {}", value);
    }
}
```

### 自定义类型和哈希函数

```cpp
#include <concurrent_unordered_set.h>
#include <print>
#include <string>

using namespace Concurrency;
using namespace std;

// 自定义用户类型
struct User {
    int id;
    string name;
    string email;
    
    User(int user_id, const string& user_name, const string& user_email)
        : id(user_id), name(user_name), email(user_email) {}
    
    // 相等比较运算符
    bool operator==(const User& other) const {
        return id == other.id;
    }
};

// 自定义用户哈希函数
struct UserHash {
    size_t operator()(const User& user) const {
        return hash<int>()(user.id);
    }
};

// 自定义用户相等比较
struct UserEqual {
    bool operator()(const User& a, const User& b) const {
        return a.id == b.id;
    }
};

void custom_type_example() {
    concurrent_unordered_set<User, UserHash, UserEqual> user_set;
    
    // 插入用户
    user_set.insert(User(1, "Alice", "alice@example.com"));
    user_set.insert(User(2, "Bob", "bob@example.com"));
    user_set.insert(User(3, "Charlie", "charlie@example.com"));
    
    // 查找用户
    User search_user(2, "", "");
    auto it = user_set.find(search_user);
    if (it != user_set.end()) {
        println("找到用户: ID={}, 姓名={}, 邮箱={}", it->id, it->name, it->email);
    }
    
    // 尝试插入重复ID的用户
    auto result = user_set.insert(User(1, "Another Alice", "another@example.com"));
    if (!result.second) {
        println("无法插入重复ID的用户");
    }
    
    // 输出所有用户
    println("所有用户:");
    for (const auto& user : user_set) {
        println("  ID: {}, 姓名: {}, 邮箱: {}", user.id, user.name, user.email);
    }
}
```

### 并发无序多重集合

```cpp
#include <concurrent_unordered_set.h>
#include <print>
#include <thread>
#include <vector>

using namespace Concurrency;
using namespace std;

void concurrent_unordered_multiset_example() {
    concurrent_unordered_multiset<int> number_multiset;
    
    // 多线程插入重复数据
    vector<thread> writers;
    for (int i = 0; i < 3; ++i) {
        writers.emplace_back([&number_multiset, i]() {
            for (int j = 0; j < 5; ++j) {
                int value = (i * 5 + j) % 10;  // 产生重复值
                number_multiset.insert(value);
                println("线程 {} 插入: {}", i, value);
                this_thread::sleep_for(chrono::milliseconds(2));
            }
        });
    }
    
    // 等待写入完成
    for (auto& t : writers) t.join();
    
    // 统计元素出现次数
    println("多重集合统计:");
    for (int i = 0; i < 10; ++i) {
        size_t count = number_multiset.count(i);
        if (count > 0) {
            println("  值 {} 出现 {} 次", i, count);
        }
    }
    
    // 输出所有元素
    println("所有元素:");
    for (const auto& value : number_multiset) {
        println("  {}", value);
    }
    
    println("总元素数量: {}", number_multiset.size());
}
```

## 适用业务场景

1. **并发缓存系统** - 存储和检索缓存数据
2. **去重处理系统** - 实时数据流去重
3. **会话管理** - 管理用户会话信息
4. **索引构建** - 构建并发索引结构
5. **数据分析** - 实时数据分析和统计
6. **网络服务** - 处理并发客户端连接

## 完整示例1：实时数据去重系统

下面展示一个完整的实时数据去重系统，使用并发无序集合处理高并发数据流：

```cpp
#include <concurrent_unordered_set.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>
#include <queue>
#include <shared_mutex>

using namespace Concurrency;
using namespace std;

// 数据记录结构
struct DataRecord {
    string id;
    string source;
    string content;
    chrono::system_clock::time_point timestamp;
    size_t hash_value;
    
    DataRecord(const string& record_id, const string& src, const string& cnt)
        : id(record_id), source(src), content(cnt),
          timestamp(chrono::system_clock::now()) {
        // 计算内容哈希值用于去重
        hash<string> hasher;
        hash_value = hasher(content);
    }
    
    // 用于哈希表的相等比较
    bool operator==(const DataRecord& other) const {
        return hash_value == other.hash_value && content == other.content;
    }
};

// 数据记录哈希函数
struct DataRecordHash {
    size_t operator()(const DataRecord& record) const {
        return record.hash_value;
    }
};

// 数据记录相等比较
struct DataRecordEqual {
    bool operator()(const DataRecord& a, const DataRecord& b) const {
        return a.hash_value == b.hash_value && a.content == b.content;
    }
};

// 实时数据去重器
class RealTimeDeduplicator {
private:
    concurrent_unordered_set<DataRecord, DataRecordHash, DataRecordEqual> m_seenRecords;
    atomic<long long> m_totalProcessed;
    atomic<long long> m_duplicatesFound;
    atomic<long long> m_uniqueRecords;
    shared_mutex m_statMutex;
    
public:
    RealTimeDeduplicator() 
        : m_totalProcessed(0), m_duplicatesFound(0), m_uniqueRecords(0) {}
    
    // 处理数据记录
    bool process_record(const DataRecord& record) {
        m_totalProcessed++;
        
        auto result = m_seenRecords.insert(record);
        
        if (result.second) {
            // 新记录
            m_uniqueRecords++;
            println("新记录: ID={}, 源={}, 内容={}...", 
                   record.id, record.source, 
                   record.content.substr(0, min(20ull, record.content.length())));
            return true;
        } else {
            // 重复记录
            m_duplicatesFound++;
            println("重复记录: ID={}, 源={}", record.id, record.source);
            return false;
        }
    }
    
    // 批量处理记录
    size_t process_batch(const vector<DataRecord>& records) {
        size_t new_count = 0;
        for (const auto& record : records) {
            if (process_record(record)) {
                new_count++;
            }
        }
        return new_count;
    }
    
    // 获取统计信息
    void get_statistics(long long& total, long long& duplicates, long long& unique) const {
        total = m_totalProcessed.load();
        duplicates = m_duplicatesFound.load();
        unique = m_uniqueRecords.load();
    }
    
    // 清空去重器
    void clear() {
        m_seenRecords.clear();
        m_totalProcessed = 0;
        m_duplicatesFound = 0;
        m_uniqueRecords = 0;
        println("去重器已清空");
    }
    
    // 获取当前唯一记录数量
    size_t unique_count() const {
        return m_seenRecords.size();
    }
    
    // 检查记录是否存在
    bool contains(const DataRecord& record) const {
        return m_seenRecords.find(record) != m_seenRecords.end();
    }
};

// 数据生成器
class DataGenerator {
private:
    atomic<bool> m_running;
    vector<thread> m_generatorThreads;
    random_device m_rd;
    
public:
    DataGenerator() : m_running(false) {}
    
    ~DataGenerator() {
        stop();
    }
    
    // 启动数据生成
    void start(RealTimeDeduplicator& deduplicator, int num_generators = 3) {
        m_running = true;
        
        for (int i = 0; i < num_generators; ++i) {
            m_generatorThreads.emplace_back([this, &deduplicator, i]() {
                generate_data(deduplicator, i);
            });
        }
        
        println("启动 {} 个数据生成器", num_generators);
    }
    
    // 停止数据生成
    void stop() {
        m_running = false;
        for (auto& thread : m_generatorThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_generatorThreads.clear();
        println("数据生成器已停止");
    }
    
private:
    void generate_data(RealTimeDeduplicator& deduplicator, int generator_id) {
        mt19937 gen(m_rd());
        uniform_int_distribution<> content_dist(1, 20);  // 控制重复率
        uniform_int_distribution<> delay_dist(1, 50);
        
        vector<string> data_templates = {
            "用户登录事件: 用户ID_{}, 时间戳_{}",
            "交易记录: 金额_{}, 商户_{}, 时间_{}",
            "系统日志: 级别_{}, 消息_{}, 模块_{}",
            "性能指标: CPU_{}%, 内存_{}MB, 时间_{}",
            "网络请求: 方法_{}, 路径_{}, 状态_{}"
        };
        
        uniform_int_distribution<> template_dist(0, 
            static_cast<int>(data_templates.size() - 1));
        
        int record_count = 0;
        string source = "Generator_" + to_string(generator_id);
        
        while (m_running && record_count < 100) {
            // 生成记录ID
            string record_id = format("{}_{}", source, record_count);
            
            // 选择数据模板
            string template_str = data_templates[template_dist(gen)];
            
            // 生成内容（部分重复）
            int content_id = content_dist(gen);
            string content = format(template_str, content_id, record_count, 
                                   chrono::system_clock::now().time_since_epoch().count());
            
            // 创建数据记录
            DataRecord record(record_id, source, content);
            
            // 处理记录
            deduplicator.process_record(record);
            
            record_count++;
            
            // 随机延迟
            this_thread::sleep_for(chrono::milliseconds(delay_dist(gen)));
        }
        
        println("数据生成器 {} 完成，生成 {} 条记录", generator_id, record_count);
    }
};

// 统计监控器
class StatisticsMonitor {
private:
    atomic<bool> m_running;
    thread m_monitorThread;
    
public:
    StatisticsMonitor() : m_running(false) {}
    
    ~StatisticsMonitor() {
        stop();
    }
    
    void start(RealTimeDeduplicator& deduplicator) {
        m_running = true;
        m_monitorThread = thread([this, &deduplicator]() {
            monitor_loop(deduplicator);
        });
        println("统计监控器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_monitorThread.joinable()) {
            m_monitorThread.join();
        }
        println("统计监控器停止");
    }
    
private:
    void monitor_loop(RealTimeDeduplicator& deduplicator) {
        while (m_running) {
            long long total, duplicates, unique;
            deduplicator.get_statistics(total, duplicates, unique);
            
            double duplicate_rate = (total > 0) ? 
                (static_cast<double>(duplicates) / total * 100.0) : 0.0;
            
            println("=== 统计信息 ===");
            println("总处理记录: {}", total);
            println("唯一记录: {}", unique);
            println("重复记录: {}", duplicates);
            println("重复率: {:.2f}%", duplicate_rate);
            println("当前集合大小: {}", deduplicator.unique_count());
            println("================\n");
            
            this_thread::sleep_for(chrono::seconds(2));
        }
    }
};

int main() {
    println("=== 实时数据去重系统演示 ===");
    
    try {
        // 创建去重器
        RealTimeDeduplicator deduplicator;
        
        // 创建数据生成器
        DataGenerator generator;
        
        // 创建统计监控器
        StatisticsMonitor monitor;
        
        // 启动系统
        monitor.start(deduplicator);
        generator.start(deduplicator, 4);  // 4个数据生成器
        
        // 运行一段时间
        println("系统运行中...");
        this_thread::sleep_for(chrono::seconds(10));
        
        // 停止系统
        generator.stop();
        
        // 显示最终统计
        this_thread::sleep_for(chrono::seconds(1));
        monitor.stop();
        
        // 最终统计信息
        long long total, duplicates, unique;
        deduplicator.get_statistics(total, duplicates, unique);
        
        println("=== 最终统计 ===");
        println("总处理记录: {}", total);
        println("唯一记录: {}", unique);
        println("重复记录: {}", duplicates);
        println("去重效果: {:.2f}% 的记录被去重", 
               (static_cast<double>(duplicates) / total * 100.0));
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：并发会话管理系统

```cpp
#include <concurrent_unordered_set.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>
#include <map>

using namespace Concurrency;
using namespace std;

// 用户会话类
class UserSession {
private:
    string m_sessionId;
    string m_userId;
    string m_username;
    chrono::system_clock::time_point m_loginTime;
    chrono::system_clock::time_point m_lastActivity;
    atomic<bool> m_active;
    
public:
    UserSession(const string& session_id, const string& user_id, const string& username)
        : m_sessionId(session_id), m_userId(user_id), m_username(username),
          m_loginTime(chrono::system_clock::now()),
          m_lastActivity(chrono::system_clock::now()),
          m_active(true) {}
    
    // 获取会话信息
    string get_session_id() const { return m_sessionId; }
    string get_user_id() const { return m_userId; }
    string get_username() const { return m_username; }
    chrono::system_clock::time_point get_login_time() const { return m_loginTime; }
    chrono::system_clock::time_point get_last_activity() const { return m_lastActivity; }
    bool is_active() const { return m_active.load(); }
    
    // 更新活动时间
    void update_activity() {
        m_lastActivity = chrono::system_clock::now();
    }
    
    // 注销会话
    void logout() {
        m_active.store(false);
    }
    
    // 计算会话持续时间
    chrono::seconds get_duration() const {
        auto now = chrono::system_clock::now();
        return chrono::duration_cast<chrono::seconds>(now - m_loginTime);
    }
    
    // 计算空闲时间
    chrono::seconds get_idle_time() const {
        auto now = chrono::system_clock::now();
        return chrono::duration_cast<chrono::seconds>(now - m_lastActivity);
    }
    
    // 用于哈希表的相等比较
    bool operator==(const UserSession& other) const {
        return m_sessionId == other.m_sessionId;
    }
    
    // 转换为字符串表示
    string to_string() const {
        auto duration = get_duration();
        auto idle = get_idle_time();
        
        return format("会话[ID:{}, 用户:{}, 状态:{}, 持续时间:{}s, 空闲:{}s]",
                     m_sessionId, m_username, 
                     m_active ? "活跃" : "非活跃",
                     duration.count(), idle.count());
    }
};

// 会话哈希函数
struct SessionHash {
    size_t operator()(const UserSession& session) const {
        return hash<string>()(session.get_session_id());
    }
};

// 会话相等比较
struct SessionEqual {
    bool operator()(const UserSession& a, const UserSession& b) const {
        return a.get_session_id() == b.get_session_id();
    }
};

// 并发会话管理器
class ConcurrentSessionManager {
private:
    concurrent_unordered_set<UserSession, SessionHash, SessionEqual> m_sessions;
    atomic<int> m_nextSessionId;
    mutable shared_mutex m_statMutex;
    
public:
    ConcurrentSessionManager() : m_nextSessionId(1) {}
    
    // 用户登录，创建新会话
    string login(const string& user_id, const string& username) {
        string session_id = generate_session_id();
        UserSession new_session(session_id, user_id, username);
        
        auto result = m_sessions.insert(new_session);
        if (result.second) {
            println("用户登录: {} (会话ID: {})", username, session_id);
            return session_id;
        } else {
            throw runtime_error("创建会话失败: 会话ID冲突");
        }
    }
    
    // 用户注销
    bool logout(const string& session_id) {
        UserSession search_session(session_id, "", "");
        auto it = m_sessions.find(search_session);
        
        if (it != m_sessions.end()) {
            // 注意：这里需要修改会话状态，但concurrent_unordered_set的元素是const
            // 在实际应用中，可能需要使用指针或不同的数据结构
            println("用户注销: 会话ID: {}", session_id);
            
            // 这里简化处理，直接从集合中移除
            m_sessions.unsafe_erase(it);
            return true;
        }
        
        println("注销失败: 未找到会话 {}", session_id);
        return false;
    }
    
    // 验证会话
    bool validate_session(const string& session_id) {
        UserSession search_session(session_id, "", "");
        auto it = m_sessions.find(search_session);
        return it != m_sessions.end(); // && it->is_active();
    }
    
    // 更新会话活动
    bool update_session_activity(const string& session_id) {
        UserSession search_session(session_id, "", "");
        auto it = m_sessions.find(search_session);
        
        if (it != m_sessions.end()) {
            // 在实际应用中，这里需要更新会话的活动时间
            // 由于集合元素不可变，这里简化处理
            println("更新会话活动: {}", session_id);
            return true;
        }
        
        return false;
    }
    
    // 获取会话信息
    optional<string> get_session_info(const string& session_id) {
        UserSession search_session(session_id, "", "");
        auto it = m_sessions.find(search_session);
        
        if (it != m_sessions.end()) {
            return it->to_string();
        }
        
        return nullopt;
    }
    
    // 获取所有活跃会话
    vector<string> get_all_sessions() const {
        vector<string> sessions;
        for (const auto& session : m_sessions) {
            sessions.push_back(session.to_string());
        }
        return sessions;
    }
    
    // 清理过期会话
    size_t cleanup_expired_sessions(chrono::seconds max_idle_time) {
        // 注意：这个操作不是线程安全的
        // 在生产环境中需要更复杂的清理策略
        
        size_t removed_count = 0;
        vector<UserSession> to_remove;
        
        auto now = chrono::system_clock::now();
        
        for (const auto& session : m_sessions) {
            auto idle_time = chrono::duration_cast<chrono::seconds>(
                now - session.get_last_activity());
            
            if (idle_time > max_idle_time) {
                to_remove.push_back(session);
            }
        }
        
        for (const auto& session : to_remove) {
            UserSession search_session(session.get_session_id(), "", "");
            auto it = m_sessions.find(search_session);
            if (it != m_sessions.end()) {
                m_sessions.unsafe_erase(it);
                removed_count++;
                println("清理过期会话: {}", session.get_session_id());
            }
        }
        
        return removed_count;
    }
    
    // 获取统计信息
    map<string, size_t> get_statistics() const {
        map<string, size_t> stats;
        stats["total_sessions"] = m_sessions.size();
        
        // 在实际应用中，可以统计更多信息
        // 如活跃会话数、按用户分组的会话数等
        
        return stats;
    }
    
private:
    // 生成唯一的会话ID
    string generate_session_id() {
        int session_num = m_nextSessionId++;
        return format("SESS_{:08X}_{}", session_num, 
                     chrono::system_clock::now().time_since_epoch().count());
    }
};

// 用户模拟器
class UserSimulator {
private:
    ConcurrentSessionManager& m_sessionManager;
    atomic<bool> m_running;
    vector<thread> m_userThreads;
    random_device m_rd;
    
public:
    UserSimulator(ConcurrentSessionManager& manager) 
        : m_sessionManager(manager), m_running(false) {}
    
    ~UserSimulator() {
        stop();
    }
    
    void start(int num_users = 5) {
        m_running = true;
        
        for (int i = 0; i < num_users; ++i) {
            m_userThreads.emplace_back([this, i]() {
                simulate_user_behavior(i);
            });
        }
        
        println("启动 {} 个用户模拟器", num_users);
    }
    
    void stop() {
        m_running = false;
        for (auto& thread : m_userThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_userThreads.clear();
        println("用户模拟器停止");
    }
    
private:
    void simulate_user_behavior(int user_id) {
        mt19937 gen(m_rd());
        uniform_int_distribution<> action_dist(0, 100);
        uniform_int_distribution<> delay_dist(100, 1000);
        
        string username = "User_" + to_string(user_id);
        string user_id_str = "UID_" + to_string(user_id);
        
        vector<string> sessions;
        
        while (m_running) {
            int action = action_dist(gen);
            
            if (action < 30 && sessions.size() < 3) {
                // 登录
                try {
                    string session_id = m_sessionManager.login(user_id_str, username);
                    sessions.push_back(session_id);
                    println("用户 {} 创建新会话: {}", username, session_id);
                } catch (const exception& e) {
                    println("用户 {} 登录失败: {}", username, e.what());
                }
            } else if (action < 60 && !sessions.empty()) {
                // 使用会话
                uniform_int_distribution<> session_dist(0, 
                    static_cast<int>(sessions.size() - 1));
                string session_id = sessions[session_dist(gen)];
                
                if (m_sessionManager.update_session_activity(session_id)) {
                    println("用户 {} 使用会话: {}", username, session_id);
                } else {
                    // 会话已失效，从本地列表中移除
                    println("用户 {} 的会话已失效: {}", username, session_id);
                    sessions.erase(remove(sessions.begin(), sessions.end(), session_id), 
                                 sessions.end());
                }
            } else if (action < 80 && !sessions.empty()) {
                // 注销会话
                uniform_int_distribution<> session_dist(0, 
                    static_cast<int>(sessions.size() - 1));
                string session_id = sessions[session_dist(gen)];
                
                if (m_sessionManager.logout(session_id)) {
                    println("用户 {} 注销会话: {}", username, session_id);
                    sessions.erase(remove(sessions.begin(), sessions.end(), session_id), 
                                 sessions.end());
                }
            } else {
                // 查询会话信息
                if (!sessions.empty()) {
                    uniform_int_distribution<> session_dist(0, 
                        static_cast<int>(sessions.size() - 1));
                    string session_id = sessions[session_dist(gen)];
                    
                    auto info = m_sessionManager.get_session_info(session_id);
                    if (info) {
                        println("用户 {} 查询会话: {}", username, info.value());
                    }
                }
            }
            
            this_thread::sleep_for(chrono::milliseconds(delay_dist(gen)));
        }
        
        // 退出前注销所有会话
        for (const auto& session_id : sessions) {
            m_sessionManager.logout(session_id);
        }
        
        println("用户 {} 模拟结束", username);
    }
};

// 会话监控器
class SessionMonitor {
private:
    ConcurrentSessionManager& m_sessionManager;
    atomic<bool> m_running;
    thread m_monitorThread;
    
public:
    SessionMonitor(ConcurrentSessionManager& manager) 
        : m_sessionManager(manager), m_running(false) {}
    
    ~SessionMonitor() {
        stop();
    }
    
    void start() {
        m_running = true;
        m_monitorThread = thread([this]() {
            monitor_loop();
        });
        println("会话监控器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_monitorThread.joinable()) {
            m_monitorThread.join();
        }
        println("会话监控器停止");
    }
    
private:
    void monitor_loop() {
        while (m_running) {
            // 获取统计信息
            auto stats = m_sessionManager.get_statistics();
            auto sessions = m_sessionManager.get_all_sessions();
            
            println("=== 会话监控 ===");
            println("总会话数: {}", stats.at("total_sessions"));
            println("活跃会话列表:");
            
            for (const auto& session_info : sessions) {
                println("  {}", session_info);
            }
            
            println("================\n");
            
            // 定期清理过期会话
            size_t cleaned = m_sessionManager.cleanup_expired_sessions(chrono::seconds(30));
            if (cleaned > 0) {
                println("清理了 {} 个过期会话", cleaned);
            }
            
            this_thread::sleep_for(chrono::seconds(5));
        }
    }
};

int main() {
    println("=== 并发会话管理系统演示 ===");
    
    try {
        // 创建会话管理器
        ConcurrentSessionManager session_manager;
        
        // 创建用户模拟器
        UserSimulator user_simulator(session_manager);
        
        // 创建会话监控器
        SessionMonitor session_monitor(session_manager);
        
        // 启动系统
        session_monitor.start();
        user_simulator.start(8);  // 8个并发用户
        
        // 运行一段时间
        println("系统运行中...");
        this_thread::sleep_for(chrono::seconds(30));
        
        // 停止系统
        user_simulator.stop();
        session_monitor.stop();
        
        // 显示最终统计
        auto final_stats = session_manager.get_statistics();
        println("=== 最终统计 ===");
        println("剩余会话数: {}", final_stats.at("total_sessions"));
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 性能优化建议

1. **合理设置初始桶数**：根据预期元素数量设置合适的初始桶数，减少重新哈希
2. **选择合适的哈希函数**：使用分布均匀的哈希函数减少冲突
3. **控制负载因子**：适时调整最大负载因子，平衡内存使用和性能
4. **批量操作**：在可能的情况下使用批量插入操作
5. **避免频繁重新哈希**：预先分配足够的桶空间
6. **合理使用迭代器**：注意迭代器的线程安全性限制

## 总结

`<concurrent_unordered_set.h>` 提供了高效的并发无序集合实现，特别适合需要高并发读写访问的场景。通过分段哈希表和细粒度锁设计，它在保持线程安全的同时提供了接近无锁容器的性能。无论是数据去重、会话管理还是并发缓存，都能从中获得显著的性能优势。

# MSVC并发运行时和并行模式库

# <concurrent_vector.h> 详解

## 概述

`<concurrent_vector.h>` 是 Microsoft Visual C++ 并发运行时库的重要组成部分，提供了线程安全的并发向量实现。它基于 Intel Threading Building Blocks 的实现，允许多个线程同时进行追加、元素访问、迭代器访问和迭代器遍历操作，同时保持动态数组的高效特性。

## 主要功能

- **并发安全**：支持多线程同时进行追加和读取操作
- **动态扩容**：自动管理内存，支持动态增长
- **随机访问**：提供高效的随机元素访问
- **迭代器支持**：提供随机访问迭代器
- **内存连续性**：元素在段内连续存储，优化缓存性能
- **异常安全**：提供异常处理机制，确保操作完整性
- **内存管理**：支持自定义分配器进行内存管理
- **移动语义**：支持移动构造和移动赋值，提高性能

## 核心类详解

### 基础内部类

#### `_Concurrent_vector_base_v4`

```cpp
class _Concurrent_vector_base_v4
```
并发向量基类，提供类型无关的基础操作和内存管理。

**主要特性：**
- 分段存储策略，使用2的幂次方段大小
- 支持动态扩容而不移动现有元素
- 使用嵌入式存储优化小向量性能

**主要方法：**
- `_Internal_reserve()`：内部预留空间
- `_Internal_grow_by()`：内部增长操作
- `_Internal_push_back()`：内部追加操作
- `_Internal_compact()`：内部压缩操作

#### `_Vector_iterator`

```cpp
template<typename _Container, typename _Value>
class _Vector_iterator
```
并发向量迭代器，提供随机访问迭代器功能。

**迭代器类别：**
- `iterator_category`：随机访问迭代器
- `value_type`：值类型
- `difference_type`：差值类型
- `pointer`：指针类型
- `reference`：引用类型

### 主向量类

#### `concurrent_vector`

```cpp
template<typename _Ty, class _Ax = ::std::allocator<_Ty>>
class concurrent_vector
```
并发向量主类，提供线程安全的动态数组操作。

**模板参数：**
- `_Ty`：向量中存储的元素类型
- `_Ax`：分配器类型，默认为 `std::allocator<_Ty>`

**类型定义：**
- `value_type`：存储的数据类型
- `allocator_type`：分配器类型
- `size_type`：大小类型
- `difference_type`：差值类型
- `reference`：元素引用类型
- `const_reference`：常量引用类型
- `pointer`：指针类型
- `const_pointer`：常量指针类型
- `iterator`：迭代器类型
- `const_iterator`：常量迭代器类型
- `reverse_iterator`：反向迭代器类型
- `const_reverse_iterator`：常量反向迭代器类型

## 构造函数详解

### 默认构造函数

```cpp
explicit concurrent_vector(const allocator_type &_Al = allocator_type())
```
创建空的并发向量，可选指定分配器。

### 拷贝构造函数

```cpp
concurrent_vector(const concurrent_vector& _Vector)
concurrent_vector(const concurrent_vector<_Ty, M>& _Vector, const allocator_type& _Al = allocator_type())
```
拷贝构造向量，支持同类型和不同类型分配器的拷贝。

### 移动构造函数

```cpp
concurrent_vector(concurrent_vector&& _Vector)
```
移动构造向量，提高性能。

### 容量构造函数

```cpp
explicit concurrent_vector(size_type _N)
concurrent_vector(size_type _N, const_reference _Item, const allocator_type& _Al = allocator_type())
```
创建具有指定容量或重复元素的向量。

### 迭代器范围构造函数

```cpp
template<class _InputIterator>
concurrent_vector(_InputIterator _Begin, _InputIterator _End, const allocator_type &_Al = allocator_type())
```
使用迭代器范围初始化向量。

## 主要成员函数

### 容量操作

#### `size()`

```cpp
size_type size() const
```
返回向量中的元素数量（线程安全）。

#### `empty()`

```cpp
bool empty() const
```
检查向量是否为空（线程安全）。

#### `capacity()`

```cpp
size_type capacity() const
```
返回向量的容量（线程安全）。

#### `max_size()`

```cpp
size_type max_size() const
```
返回向量可容纳的最大元素数量。

### 元素操作

#### `push_back()`

```cpp
iterator push_back(const_reference _Item)
iterator push_back(_Ty&& _Item)
```
向向量尾部追加元素（线程安全）。

#### `grow_by()`

```cpp
iterator grow_by(size_type _Delta)
iterator grow_by(size_type _Delta, const_reference _Item)
```
向向量尾部追加多个元素（线程安全）。

#### `grow_to_at_least()`

```cpp
iterator grow_to_at_least(size_type _N)
```
将向量扩展到至少指定大小（线程安全）。

### 元素访问

#### `operator[]`

```cpp
reference operator[](size_type _Index)
const_reference operator[](size_type _Index) const
```
通过下标访问元素（线程安全读取）。

#### `at()`

```cpp
reference at(size_type _Index)
const_reference at(size_type _Index) const
```
通过下标访问元素，带边界检查。

#### `front()`

```cpp
reference front()
const_reference front() const
```
访问第一个元素。

#### `back()`

```cpp
reference back()
const_reference back() const
```
访问最后一个元素。

### 容器管理

#### `reserve()`

```cpp
void reserve(size_type _N)
```
预留空间（非线程安全）。

#### `resize()`

```cpp
void resize(size_type _N)
void resize(size_type _N, const _Ty& _Val)
```
调整向量大小（非线程安全）。

#### `shrink_to_fit()`

```cpp
void shrink_to_fit()
```
压缩向量以优化内存使用（非线程安全）。

#### `clear()`

```cpp
void clear()
```
清空向量（非线程安全）。

#### `swap()`

```cpp
void swap(concurrent_vector &_Vector)
```
交换两个向量内容（非线程安全）。

### 迭代器操作

#### `begin()` / `end()`

```cpp
iterator begin()
iterator end()
const_iterator begin() const
const_iterator end() const
```
获取起始和结束迭代器。

#### `rbegin()` / `rend()`

```cpp
reverse_iterator rbegin()
reverse_iterator rend()
const_reverse_iterator rbegin() const
const_reverse_iterator rend() const
```
获取反向起始和结束迭代器。

### 分配器操作

#### `get_allocator()`

```cpp
allocator_type get_allocator() const
```
获取分配器副本。

## 内部实现机制

### 分段存储策略

向量使用分段存储策略：
- 段大小按2的幂次方增长（1, 2, 4, 8, ...）
- 每个段内部连续存储
- 支持动态扩容而不移动现有元素

### 并发控制机制

- **追加操作**：使用原子操作和细粒度锁
- **读取操作**：通常无锁，使用内存屏障
- **容量操作**：使用原子计数器

### 内存管理

支持自定义分配器：
- 分段内存分配
- 异常安全的构造和析构
- 移动语义优化

## 使用示例

### 基础并发向量操作

```cpp
#include <concurrent_vector.h>
#include <print>
#include <thread>
#include <vector>
#include <random>

using namespace Concurrency;
using namespace std;

void basic_concurrent_vector() {
    concurrent_vector<int> numbers;
    
    // 多线程追加数据
    vector<thread> writers;
    for (int i = 0; i < 4; ++i) {
        writers.emplace_back([&numbers, i]() {
            random_device rd;
            mt19937 gen(rd());
            uniform_int_distribution<> dis(1, 100);
            
            for (int j = 0; j < 10; ++j) {
                int value = dis(gen);
                numbers.push_back(value);
                println("线程 {} 追加: {}", i, value);
                this_thread::sleep_for(chrono::milliseconds(5));
            }
        });
    }
    
    // 等待写入完成
    for (auto& t : writers) t.join();
    
    // 多线程读取数据
    vector<thread> readers;
    for (int i = 0; i < 3; ++i) {
        readers.emplace_back([&numbers, i]() {
            for (int j = 0; j < 5; ++j) {
                if (j < numbers.size()) {
                    int value = numbers[j];
                    println("线程 {} 读取 [{}]: {}", i, j, value);
                }
                this_thread::sleep_for(chrono::milliseconds(10));
            }
        });
    }
    
    // 等待读取完成
    for (auto& t : readers) t.join();
    
    // 输出统计信息
    println("向量大小: {}", numbers.size());
    println("向量容量: {}", numbers.capacity());
    
    // 使用迭代器遍历
    println("向量内容:");
    for (const auto& num : numbers) {
        println("  {}", num);
    }
    
    // 使用grow_by批量追加
    auto it = numbers.grow_by(5, 999);
    println("批量追加后大小: {}", numbers.size());
}
```

### 批量操作和性能优化

```cpp
#include <concurrent_vector.h>
#include <print>
#include <chrono>

using namespace Concurrency;
using namespace std;

void batch_operations_example() {
    concurrent_vector<double> data;
    
    // 使用grow_by进行批量预分配和初始化
    auto start_time = chrono::high_resolution_clock::now();
    
    // 批量追加10000个元素
    data.grow_by(10000, 3.14159);
    
    auto end_time = chrono::high_resolution_clock::now();
    auto duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time);
    
    println("批量追加10000个元素耗时: {} 微秒", duration.count());
    println("数据大小: {}", data.size());
    println("数据容量: {}", data.capacity());
    
    // 使用grow_to_at_least确保最小容量
    data.grow_to_at_least(15000);
    println("扩展后容量: {}", data.capacity());
    
    // 压缩内存
    data.shrink_to_fit();
    println("压缩后容量: {}", data.capacity());
    
    // 随机访问测试
    if (data.size() > 1000) {
        println("第1000个元素: {}", data[999]);
        println("最后一个元素: {}", data.back());
    }
}
```

## 适用业务场景

1. **实时数据采集** - 多线程数据收集和存储
2. **科学计算** - 并行算法结果收集
3. **日志系统** - 并发日志记录
4. **任务队列** - 动态任务管理
5. **模拟系统** - 实体状态存储
6. **数据分析** - 实时数据处理流水线

## 完整示例1：实时数据采集系统

下面展示一个完整的实时数据采集系统，使用并发向量处理来自多个传感器的数据：

```cpp
#include <concurrent_vector.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>
#include <algorithm>
#include <numeric>

using namespace Concurrency;
using namespace std;

// 传感器数据结构
struct SensorData {
    int sensor_id;
    string sensor_name;
    double value;
    chrono::system_clock::time_point timestamp;
    int quality;  // 数据质量指标 0-100
    
    SensorData(int id, const string& name, double val, int qual = 100)
        : sensor_id(id), sensor_name(name), value(val), 
          timestamp(chrono::system_clock::now()), quality(qual) {}
    
    string to_string() const {
        auto time_t = chrono::system_clock::to_time_t(timestamp);
        return format("传感器[ID:{}, 名称:{}, 值:{:.2f}, 质量:{}, 时间:{}]",
                     sensor_id, sensor_name, value, quality, ctime(&time_t));
    }
};

// 数据采集器类
class DataCollector {
private:
    concurrent_vector<SensorData> m_data;
    atomic<long long> m_totalCollected;
    atomic<long long> m_invalidData;
    
public:
    DataCollector() : m_totalCollected(0), m_invalidData(0) {}
    
    // 采集单条数据
    void collect_data(const SensorData& data) {
        if (data.quality >= 50) {  // 质量检查
            m_data.push_back(data);
            m_totalCollected++;
            println("采集数据: {}", data.to_string());
        } else {
            m_invalidData++;
            println("丢弃低质量数据: 传感器 {}", data.sensor_name);
        }
    }
    
    // 批量采集数据
    void collect_batch(const vector<SensorData>& batch) {
        size_t valid_count = 0;
        for (const auto& data : batch) {
            if (data.quality >= 50) {
                m_data.push_back(data);
                valid_count++;
            } else {
                m_invalidData++;
            }
        }
        m_totalCollected += valid_count;
        println("批量采集: {} 条有效数据", valid_count);
    }
    
    // 获取统计信息
    void get_statistics(long long& total, long long& invalid, size_t& current_size) const {
        total = m_totalCollected.load();
        invalid = m_invalidData.load();
        current_size = m_data.size();
    }
    
    // 数据分析 - 计算统计值
    void analyze_data() const {
        if (m_data.empty()) {
            println("无数据可分析");
            return;
        }
        
        // 计算平均值
        double sum = 0.0;
        int count = 0;
        
        for (const auto& data : m_data) {
            if (data.quality >= 70) {  // 只使用高质量数据
                sum += data.value;
                count++;
            }
        }
        
        if (count > 0) {
            double average = sum / count;
            println("数据分析结果:");
            println("  总数据量: {}", m_data.size());
            println("  高质量数据: {} 条", count);
            println("  平均值: {:.3f}", average);
        }
    }
    
    // 按传感器ID筛选数据
    vector<SensorData> filter_by_sensor(int sensor_id) const {
        vector<SensorData> result;
        
        for (const auto& data : m_data) {
            if (data.sensor_id == sensor_id && data.quality >= 60) {
                result.push_back(data);
            }
        }
        
        return result;
    }
    
    // 获取所有数据（用于导出等操作）
    vector<SensorData> get_all_data() const {
        return vector<SensorData>(m_data.begin(), m_data.end());
    }
    
    // 清空数据
    void clear() {
        m_data.clear();
        m_totalCollected = 0;
        m_invalidData = 0;
        println("数据采集器已清空");
    }
    
    // 获取当前数据量
    size_t data_count() const {
        return m_data.size();
    }
};

// 传感器模拟器
class SensorSimulator {
private:
    DataCollector& m_collector;
    atomic<bool> m_running;
    vector<thread> m_sensorThreads;
    random_device m_rd;
    
public:
    SensorSimulator(DataCollector& collector) 
        : m_collector(collector), m_running(false) {}
    
    ~SensorSimulator() {
        stop();
    }
    
    void start(int num_sensors = 5) {
        m_running = true;
        
        vector<string> sensor_names = {
            "温度传感器", "压力传感器", "湿度传感器", 
            "流量传感器", "振动传感器", "电压传感器",
            "电流传感器", "位置传感器", "速度传感器"
        };
        
        for (int i = 0; i < num_sensors; ++i) {
            string name = sensor_names[i % sensor_names.size()] + "_" + to_string(i);
            m_sensorThreads.emplace_back([this, i, name]() {
                simulate_sensor(i, name);
            });
        }
        
        println("启动 {} 个传感器模拟器", num_sensors);
    }
    
    void stop() {
        m_running = false;
        for (auto& thread : m_sensorThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_sensorThreads.clear();
        println("传感器模拟器停止");
    }
    
private:
    void simulate_sensor(int sensor_id, const string& name) {
        mt19937 gen(m_rd());
        
        // 不同传感器的值范围
        uniform_real_distribution<double> temp_dist(15.0, 35.0);      // 温度
        uniform_real_distribution<double> pressure_dist(95.0, 105.0); // 压力
        uniform_real_distribution<double> humidity_dist(30.0, 80.0);  // 湿度
        uniform_real_distribution<double> flow_dist(0.5, 5.0);        // 流量
        uniform_real_distribution<double> vibration_dist(0.1, 2.0);   // 振动
        
        vector<uniform_real_distribution<double>> distributions = {
            temp_dist, pressure_dist, humidity_dist, flow_dist, vibration_dist
        };
        
        uniform_int_distribution<> quality_dist(40, 100);  // 数据质量
        uniform_int_distribution<> delay_dist(50, 500);    // 采集间隔
        
        int distribution_idx = sensor_id % distributions.size();
        int reading_count = 0;
        
        println("传感器 {} 开始工作", name);
        
        while (m_running && reading_count < 100) {
            double value = distributions[distribution_idx](gen);
            int quality = quality_dist(gen);
            
            SensorData data(sensor_id, name, value, quality);
            m_collector.collect_data(data);
            
            reading_count++;
            this_thread::sleep_for(chrono::milliseconds(delay_dist(gen)));
        }
        
        println("传感器 {} 完成工作，采集 {} 次读数", name, reading_count);
    }
};

// 数据监控器
class DataMonitor {
private:
    DataCollector& m_collector;
    atomic<bool> m_running;
    thread m_monitorThread;
    
public:
    DataMonitor(DataCollector& collector) 
        : m_collector(collector), m_running(false) {}
    
    ~DataMonitor() {
        stop();
    }
    
    void start() {
        m_running = true;
        m_monitorThread = thread([this]() {
            monitor_loop();
        });
        println("数据监控器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_monitorThread.joinable()) {
            m_monitorThread.join();
        }
        println("数据监控器停止");
    }
    
private:
    void monitor_loop() {
        while (m_running) {
            long long total, invalid;
            size_t current_size;
            m_collector.get_statistics(total, invalid, current_size);
            
            println("=== 数据监控 ===");
            println("总采集次数: {}", total);
            println("无效数据: {}", invalid);
            println("当前存储数据: {}", current_size);
            println("数据有效率: {:.1f}%", 
                   (total > 0 ? (static_cast<double>(total - invalid) / total * 100.0) : 0.0));
            
            // 定期分析数据
            m_collector.analyze_data();
            
            println("================\n");
            
            this_thread::sleep_for(chrono::seconds(3));
        }
    }
};

// 数据导出器
class DataExporter {
public:
    // 导出数据到文件（模拟）
    static void export_to_file(const vector<SensorData>& data, const string& filename) {
        println("导出 {} 条数据到文件: {}", data.size(), filename);
        
        // 在实际应用中，这里会写入文件
        // 这里简单打印前几条数据作为示例
        int count = min(5, static_cast<int>(data.size()));
        for (int i = 0; i < count; ++i) {
            println("  导出: {}", data[i].to_string());
        }
        
        if (data.size() > count) {
            println("  ... 还有 {} 条数据", data.size() - count);
        }
    }
    
    // 导出特定传感器的数据
    static void export_sensor_data(const DataCollector& collector, int sensor_id, const string& filename) {
        auto sensor_data = collector.filter_by_sensor(sensor_id);
        export_to_file(sensor_data, filename);
    }
};

int main() {
    println("=== 实时数据采集系统演示 ===");
    
    try {
        // 创建数据采集器
        DataCollector collector;
        
        // 创建传感器模拟器
        SensorSimulator simulator(collector);
        
        // 创建数据监控器
        DataMonitor monitor(collector);
        
        // 启动系统
        monitor.start();
        simulator.start(8);  // 8个传感器
        
        // 运行一段时间
        println("系统运行中...");
        this_thread::sleep_for(chrono::seconds(15));
        
        // 导出数据
        println("开始数据导出...");
        DataExporter::export_to_file(collector.get_all_data(), "all_data.csv");
        DataExporter::export_sensor_data(collector, 0, "sensor_0_data.csv");
        
        // 停止系统
        simulator.stop();
        monitor.stop();
        
        // 最终统计
        long long total, invalid;
        size_t current_size;
        collector.get_statistics(total, invalid, current_size);
        
        println("=== 最终统计 ===");
        println("总采集次数: {}", total);
        println("无效数据: {}", invalid);
        println("最终存储数据: {}", current_size);
        println("系统运行完成");
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 完整示例2：并行计算任务管理器

```cpp
#include <concurrent_vector.h>
#include <vector>
#include <thread>
#include <chrono>
#include <random>
#include <atomic>
#include <format>
#include <print>
#include <future>
#include <functional>

using namespace Concurrency;
using namespace std;

// 计算任务结构
struct ComputeTask {
    int task_id;
    string description;
    function<double()> computation;
    chrono::system_clock::time_point created_time;
    atomic<bool> completed;
    double result;
    
    ComputeTask(int id, const string& desc, function<double()> comp)
        : task_id(id), description(desc), computation(comp),
          created_time(chrono::system_clock::now()), completed(false), result(0.0) {}
    
    // 执行计算任务
    void execute() {
        try {
            result = computation();
            completed.store(true);
            
            auto end_time = chrono::system_clock::now();
            auto duration = chrono::duration_cast<chrono::milliseconds>(
                end_time - created_time);
                
            println("任务 {} 完成: {} (结果: {:.6f}, 耗时: {}ms)", 
                   task_id, description, result, duration.count());
        }
        catch (const exception& e) {
            println("任务 {} 执行失败: {} - {}", task_id, description, e.what());
            completed.store(true);
            result = numeric_limits<double>::quiet_NaN();
        }
    }
    
    // 检查是否完成
    bool is_completed() const {
        return completed.load();
    }
    
    // 获取任务信息
    string get_info() const {
        auto time_t = chrono::system_clock::to_time_t(created_time);
        string status = completed ? "已完成" : "进行中";
        return format("任务[ID:{}, 描述:{}, 状态:{}, 创建时间:{}]",
                     task_id, description, status, ctime(&time_t));
    }
};

// 并行任务管理器
class ParallelTaskManager {
private:
    concurrent_vector<ComputeTask> m_tasks;
    atomic<int> m_nextTaskId;
    vector<thread> m_workerThreads;
    atomic<bool> m_running;
    atomic<int> m_completedTasks;
    
public:
    ParallelTaskManager(int num_workers = 4) 
        : m_nextTaskId(1), m_running(false), m_completedTasks(0) {
        start_workers(num_workers);
    }
    
    ~ParallelTaskManager() {
        stop();
    }
    
    // 提交计算任务
    int submit_task(const string& description, function<double()> computation) {
        int task_id = m_nextTaskId++;
        ComputeTask task(task_id, description, computation);
        m_tasks.push_back(task);
        
        println("提交任务: {} (ID: {})", description, task_id);
        return task_id;
    }
    
    // 批量提交任务
    vector<int> submit_batch(const vector<pair<string, function<double()>>>& tasks) {
        vector<int> task_ids;
        task_ids.reserve(tasks.size());
        
        for (const auto& [description, computation] : tasks) {
            int task_id = submit_task(description, computation);
            task_ids.push_back(task_id);
        }
        
        return task_ids;
    }
    
    // 获取任务结果
    optional<double> get_task_result(int task_id) {
        for (const auto& task : m_tasks) {
            if (task.task_id == task_id && task.is_completed()) {
                return task.result;
            }
        }
        return nullopt;
    }
    
    // 等待任务完成
    bool wait_for_task(int task_id, chrono::milliseconds timeout = chrono::seconds(30)) {
        auto start_time = chrono::steady_clock::now();
        
        while (chrono::steady_clock::now() - start_time < timeout) {
            for (const auto& task : m_tasks) {
                if (task.task_id == task_id) {
                    if (task.is_completed()) {
                        return true;
                    }
                    break;
                }
            }
            this_thread::sleep_for(chrono::milliseconds(10));
        }
        
        return false;
    }
    
    // 获取所有任务状态
    vector<string> get_all_task_status() const {
        vector<string> status_list;
        for (const auto& task : m_tasks) {
            status_list.push_back(task.get_info());
        }
        return status_list;
    }
    
    // 获取统计信息
    void get_statistics(int& total_tasks, int& completed_tasks, int& pending_tasks) const {
        total_tasks = static_cast<int>(m_tasks.size());
        completed_tasks = m_completedTasks.load();
        pending_tasks = total_tasks - completed_tasks;
    }
    
    // 清理已完成任务
    void cleanup_completed_tasks() {
        // 注意：这个操作不是线程安全的
        // 在实际应用中需要更复杂的清理策略
        
        vector<ComputeTask> active_tasks;
        int completed_count = 0;
        
        for (const auto& task : m_tasks) {
            if (!task.is_completed()) {
                active_tasks.push_back(task);
            } else {
                completed_count++;
            }
        }
        
        if (completed_count > 0) {
            m_tasks.clear();
            for (const auto& task : active_tasks) {
                m_tasks.push_back(task);
            }
            println("清理了 {} 个已完成任务", completed_count);
        }
    }
    
private:
    // 启动工作线程
    void start_workers(int num_workers) {
        m_running = true;
        
        for (int i = 0; i < num_workers; ++i) {
            m_workerThreads.emplace_back([this, i]() {
                worker_loop(i);
            });
        }
        
        println("启动 {} 个工作线程", num_workers);
    }
    
    // 停止工作线程
    void stop() {
        m_running = false;
        for (auto& thread : m_workerThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }
        m_workerThreads.clear();
        
        println("任务管理器停止，总计完成: {} 个任务", m_completedTasks.load());
    }
    
    // 工作线程循环
    void worker_loop(int worker_id) {
        println("工作线程 {} 启动", worker_id);
        
        random_device rd;
        mt19937 gen(rd());
        uniform_int_distribution<> idle_dist(10, 100);
        
        while (m_running) {
            bool found_task = false;
            
            // 查找未完成的任务
            for (auto& task : m_tasks) {
                if (!task.is_completed()) {
                    // 尝试获取任务执行权
                    bool expected = false;
                    if (task.completed.compare_exchange_weak(expected, true)) {
                        found_task = true;
                        println("线程 {} 开始执行任务: {}", worker_id, task.description);
                        
                        task.execute();
                        m_completedTasks++;
                        
                        break;
                    }
                }
            }
            
            if (!found_task) {
                // 没有任务，短暂休眠
                this_thread::sleep_for(chrono::milliseconds(idle_dist(gen)));
            }
        }
        
        println("工作线程 {} 退出", worker_id);
    }
};

// 数学计算函数示例
class MathComputations {
public:
    // 计算π的蒙特卡洛方法
    static double compute_pi_monte_carlo(int samples = 1000000) {
        random_device rd;
        mt19937 gen(rd());
        uniform_real_distribution<> dis(0.0, 1.0);
        
        int inside_circle = 0;
        for (int i = 0; i < samples; ++i) {
            double x = dis(gen);
            double y = dis(gen);
            if (x * x + y * y <= 1.0) {
                inside_circle++;
            }
        }
        
        return 4.0 * inside_circle / samples;
    }
    
    // 计算斐波那契数列
    static double compute_fibonacci(int n) {
        if (n <= 1) return n;
        
        double a = 0, b = 1;
        for (int i = 2; i <= n; ++i) {
            double temp = a + b;
            a = b;
            b = temp;
        }
        return b;
    }
    
    // 数值积分
    static double compute_integral(function<double(double)> f, double a, double b, int segments = 1000000) {
        double segment_width = (b - a) / segments;
        double sum = 0.0;
        
        for (int i = 0; i < segments; ++i) {
            double x1 = a + i * segment_width;
            double x2 = x1 + segment_width;
            sum += (f(x1) + f(x2)) * segment_width / 2.0;
        }
        
        return sum;
    }
    
    // 矩阵乘法（简化版）
    static double compute_matrix_determinant(const vector<vector<double>>& matrix) {
        // 简化实现，只处理2x2矩阵
        if (matrix.size() == 2 && matrix[0].size() == 2 && matrix[1].size() == 2) {
            return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
        }
        return 0.0;
    }
};

// 任务监控器
class TaskMonitor {
private:
    ParallelTaskManager& m_taskManager;
    atomic<bool> m_running;
    thread m_monitorThread;
    
public:
    TaskMonitor(ParallelTaskManager& manager) 
        : m_taskManager(manager), m_running(false) {}
    
    ~TaskMonitor() {
        stop();
    }
    
    void start() {
        m_running = true;
        m_monitorThread = thread([this]() {
            monitor_loop();
        });
        println("任务监控器启动");
    }
    
    void stop() {
        m_running = false;
        if (m_monitorThread.joinable()) {
            m_monitorThread.join();
        }
        println("任务监控器停止");
    }
    
private:
    void monitor_loop() {
        while (m_running) {
            int total, completed, pending;
            m_taskManager.get_statistics(total, completed, pending);
            
            println("=== 任务监控 ===");
            println("总任务数: {}", total);
            println("已完成: {}", completed);
            println("待完成: {}", pending);
            println("完成率: {:.1f}%", 
                   (total > 0 ? static_cast<double>(completed) / total * 100.0 : 0.0));
            
            // 显示任务状态
            auto status_list = m_taskManager.get_all_task_status();
            if (!status_list.empty()) {
                println("任务状态:");
                for (const auto& status : status_list) {
                    println("  {}", status);
                }
            }
            
            println("================\n");
            
            this_thread::sleep_for(chrono::seconds(2));
        }
    }
};

int main() {
    println("=== 并行计算任务管理器演示 ===");
    
    try {
        // 创建任务管理器
        ParallelTaskManager task_manager(6);  // 6个工作线程
        
        // 创建任务监控器
        TaskMonitor monitor(task_manager);
        
        // 启动监控
        monitor.start();
        
        // 提交各种计算任务
        println("提交计算任务...");
        
        // 蒙特卡洛π计算
        task_manager.submit_task("蒙特卡洛π计算", []() {
            return MathComputations::compute_pi_monte_carlo(2000000);
        });
        
        // 斐波那契计算
        task_manager.submit_task("斐波那契数列 F(100000)", []() {
            return MathComputations::compute_fibonacci(100000);
        });
        
        // 数值积分
        task_manager.submit_task("数值积分 sin(x)从0到π", []() {
            return MathComputations::compute_integral(
                [](double x) { return sin(x); }, 0.0, 3.14159, 1000000);
        });
        
        // 更多任务
        vector<pair<string, function<double()>>> batch_tasks = {
            {"矩阵行列式计算", []() { 
                vector<vector<double>> matrix = {{1, 2}, {3, 4}};
                return MathComputations::compute_matrix_determinant(matrix);
            }},
            {"复杂函数计算", []() {
                double sum = 0;
                for (int i = 0; i < 1000000; ++i) {
                    sum += sqrt(static_cast<double>(i));
                }
                return sum;
            }},
            {"随机数统计", []() {
                random_device rd;
                mt19937 gen(rd());
                normal_distribution<> dis(0.0, 1.0);
                
                double sum = 0;
                for (int i = 0; i < 500000; ++i) {
                    sum += dis(gen);
                }
                return sum / 500000;
            }}
        };
        
        auto task_ids = task_manager.submit_batch(batch_tasks);
        
        // 等待特定任务完成并获取结果
        this_thread::sleep_for(chrono::seconds(2));
        
        if (!task_ids.empty()) {
            int first_task_id = task_ids[0];
            if (task_manager.wait_for_task(first_task_id, chrono::seconds(5))) {
                auto result = task_manager.get_task_result(first_task_id);
                if (result) {
                    println("任务 {} 的结果: {:.6f}", first_task_id, result.value());
                }
            }
        }
        
        // 让系统运行一段时间
        println("系统运行中...");
        this_thread::sleep_for(chrono::seconds(10));
        
        // 清理已完成任务
        task_manager.cleanup_completed_tasks();
        
        // 停止系统
        monitor.stop();
        
        // 最终统计
        int total, completed, pending;
        task_manager.get_statistics(total, completed, pending);
        
        println("=== 最终统计 ===");
        println("总任务数: {}", total);
        println("已完成: {}", completed);
        println("待完成: {}", pending);
        
    } catch (const exception& e) {
        println("系统错误: {}", e.what());
        return 1;
    }
    
    println("=== 演示完成 ===");
    return 0;
}
```

## 性能优化建议

1. **合理使用批量操作**：使用 `grow_by()` 而不是多次 `push_back()` 减少锁竞争
2. **预分配空间**：使用 `reserve()` 预分配空间避免多次重新分配
3. **选择合适的段大小**：根据元素大小和工作负载调整初始容量
4. **避免频繁的压缩操作**：`shrink_to_fit()` 操作较慢，应谨慎使用
5. **合理使用迭代器**：注意迭代器的线程安全性限制
6. **批量处理数据**：在可能的情况下使用批量读取和写入操作

## 总结

`<concurrent_vector.h>` 提供了高效的并发向量实现，特别适合需要高并发追加和读取操作的场景。通过分段存储策略和优化的并发控制机制，它在保持线程安全的同时提供了接近顺序容器的性能。无论是实时数据采集、并行计算还是任务管理，都能从中获得显著的性能优势。