# 基类与派生类

- **基类的析构函数必须定义为`virtual`**
- **子类重载父类的方法必须定义为`override`**
- **子类和基类有相同的成员或者非虚函数、非静态的成员函数，默认使用子类的如果想要使用基类成员，需要加上基类的名字作用域，基类::名字相同的方法()**
- **如果子类和基类的虚函数重名，但是参数类型不同，就不是重写而是隐藏，如果子类实现和基类一样的普通非虚函数成员函数，就是覆盖，会隐藏基类同名函数**，重载是函数名相同但是参数类型不同



1. 基类通过在其成员函数的声明语句之前加上关键字virtual使得该函数执行动态绑定。
2. 任何构造函数之外的非静态函数都可以是虚函数。
3. 关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
4. **如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数**。
5. <u>成员函数</u>如果**没被声明为虚函数**，则其**解析过程发生在编译时而非运行**时。



## 派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

## 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

## 继承与静态成员

如果基类定义了一个静态成员（方法/变量），则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。



## 被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而耐非仅仅声明：

```cpp
class Quote;
//声明但未定义
//错误：Quote必须被定义
class Bulk_quote : public Quote { /*...*/};
```

这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。

一个类是基类，同时它也可以是一个派生类：

```cpp
class Base {/*...*/};
class D1 : public Base {/*...*/};
class D2 : public D1 {/*..*/};
```

在这个继承关系中，Base是D1的直接基类(direct base),同时是D2的间接基类(indirect base)。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。



## 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型(static type)与该表达式表示对象的动态类型(dynamic type)区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

**如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致**。例如，Quote类型的变量永远是一个Quote对象，我们无论如何都不能改变该变量对应的对象的类型。
**基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因**。

不存在从基类向派生类的隐式类型转换…
之所以存在派生类向基类的类型转换是因为每个派生类对像都包含一个基类部分而基类的引用或指针可以绑定到该基类部分上。一个基类的对像既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对像的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。因为一个基类的对像可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换：

```cpp
Quote base;
Bulk_quote* bulkP = &base;  //错误：不能将基类转换成派生类
Bulk_quote& bulkRef = base; //错误：不能将基类转换成派生类
```

**如果上述赋值是合法的，则我们有可能会使用bulkP或bulkRef访问base中本不存在的成员。**

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类
对象上，我们也不能执行从基类向派生类的转换：

```cpp
Bulk_quote bulk;
Quote* itemP = &bulk;	//正确：动态类型是Bulk_quote
Bulk_quote *bulkP = itemP;//错误：不能将基类转换成派生类
```

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。

* **如果在基类中含有一个或多个虚函数，我们可以使用dynamic cast请求一个类型转换，该转换的安全检渣将在运行时执行**。
* **同样，如果我们已知谋个基类向派生类的转换是安全的，则我们可以使用static cast强制覆盖掉编译器的检查工作。**

**<u>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</u>**



## 总结基类与派生类关系

关键概念：存在继承关系的类型之间的转换规则
要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：

* 从派生类向基类的类型转换只对指针或引用类型有效。
* 基类向派生类不存在隐式类型转换。
* 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。。

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员。因此，我们通常能够将一个派生类对像拷贝、移动或赋值给一个基类对像。不过需要注意的是，这种操作只处理派生类对像的基类部分。



# 虚函数

如前所述，<u>在C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行**动态绑定**</u>。*因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义*。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。

**基类中的虚函数在派生类中隐含地也是一个虚函数**。**当派生类覆盖了某个虚函数时，该函数在<u>基类中的形参必须与派生类中的形参严格匹配</u>**。

```cpp
struct B {
	virtual void f1(int)const;
	virtual void f2();
	void f3();
};
struct C : B {
	virtual void f1(int) const override final ; //正确：f1与基类中的f1匹配
	//void f2(int) override; 	//错误：B没有形如f2(int)的函数
	//void f3() override;		//错误：f3不是虚函数
	//void f4() override;		//错误：B没有名为f4的函数
};
struct D : C {
	void f1(int) const override; //错误：final不能被重写
};

```



# 纯虚函数

类似java的接口

```cpp
struct A {
	virtual void print() = 0;
};
```



# friend

一个类声明了其他类是它的朋友，那么其他类可以访问protected、private的成员